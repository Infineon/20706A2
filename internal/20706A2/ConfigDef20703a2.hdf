SECTION "Config Data Entries" 0
{
    # COMMAND "" 0x00                                                   - Not an allowed value

    # COMMAND "IF_PLL" 0x01                                             - Fixed header only

    # COMMAND "DS and VS Locations" 0x02                                - Fixed header only

    COMMAND "Temperature Correction Algorithm" 0x03
    {

        doc "Enables or disables the temperature correction algorithm"
            PARAM "Enable"
            uint8
            doc "Enables the temperature correction algorithm if 1"
            "Bit 0 enable temperature correction algorithm for BT mode"
            "Bit 1 enable temperature correction algorithm for BLE mode.";
    }


    COMMAND "UHE Configuration" 0x04
    {
        doc "Configures various functional properties of USB HID emulation."
        PARAM "Enable default UHE implementation"
            bool8
            doc "Enables or disables UHE. Default is 1.";
        PARAM "USB VID"
            uint16
            doc "USB vendor ID as presented to the host in the device descriptor.";
        PARAM "USB PID"
            uint16
            doc "USB product ID as presented to the host in the device descriptor.";
        PARAM "Autopairing button minimum time"
            uint8
            doc "Indicates the minimum amount of time the autopairing button needs to be pressed"
                "for autopairing to start. 0 means autopairing is disabled so that the button can"
                "be used for other purposes.";
        PARAM "HID zero-length packet enable"
            bool8
            doc "If 1, enables USB to send zero length packets on endpoint 1 of the HID devices when"
                "needed. Some BIOSes can't handle the zero-length packet being sent. By default we will"
                "not send the zero length packet, but this flag can enable it.";
        PARAM "Reverse button polarity"
            bool8
            doc "If 1, reverses UHE autopairing button's polarity. Default is low.";
    }


    # COMMAND "GPIO Pads" 0x07                                  - Ravi needs to provide a definition


    COMMAND "Patch Entry" 0x08
    {
        doc "Installs a code patch entry.  There are three types of patches.  The first type is a"
            "simple replacement of an 8-byte block of instructions with another, and therefore does"
            "not make use of the Code byte array.  The second type contains replacement instructions"
            "which vector to a contiguous block of code, loaded from the Code parameter.  The third"
            "type contains replacement instructions which vector to a fragmented block of code, "
            "loaded from the Code byte array of the Patch Entry config item, with other associated"
            "code segments being loaded from one or more Data Patch config items."
        PARAM "Patch index"
            uint8
            doc "The patch register index to be used"
            max = 128;
        PARAM "Break out block address"
            uint32
            doc "The address of the block of code to be replaced.  It must fall on a four-byte"
                "boundary.";
        PARAM "Replacement instructions"
            uint8[4]
            doc "The instructions to be executed in place of the block of code to be replaced.";
        PARAM "Code size"
            uint16
            doc "The size of the code segment to be loaded."
            binary_message_only
            encode_value = ByteArrayValidLength("Code");
        PARAM "Code address"
            uint32
            doc "The address to which to load the code bytes in the Code byte array.";
        PARAM "Code"
            uint8[0xFF00] omit_pad_bytes
            doc "The actual code instructions to be loaded to the address specified by Code address";
    }

    COMMAND "Early Init BB Registers" 0x09
    {
        doc "This item is used to initialize the BB registers early in the initialization"
            "process, while the configuration data dynamic section is being processed."
        PARAM "Num entries"
            uint8
            doc "An abstract parameter used only for encoding purposes, not present in the"
                "actual configuration item. When encoding the configuration item, determines"
                "the number of address/value pairs to include."
            not_in_binary_message
            decode_value = 0                    # Can only decode, not encode
            max = 10;
        PARAM "Register address[0]"
            uint32
            doc "Address of the baseband register"
            present_if ("Num entries" > 0);
        PARAM "Value[0]"
            uint32
            doc "Data to be written to the baseband register"
            present_if ("Num entries" > 0);
        PARAM "Register address[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Value[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Register address[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Value[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Register address[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Value[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Register address[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Value[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Register address[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Value[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Register address[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Value[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Register address[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Value[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Register address[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Value[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Register address[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Value[9]"
            uint32
            present_if ("Num entries" > 9);
    }

    COMMAND "Data" 0x0A
    {
        doc "Reads arbitrary data, which could be code, into an arbitrary location in RAM."
        PARAM "Address"
            uint32
            doc "The address to which the Data bytes are to be loaded.";
        PARAM "Data"
            uint8[0xFF00] omit_pad_bytes
            doc "The data bytes to be loaded to the Address specified.";
    }

    COMMAND "Function Call" 0x0B
    {
        doc "Calls a function at the address specified.  The call is made from Thumb mode using a"
            "BL instruction."
        PARAM "Address"
            uint32
            doc "The address of the function to be called.";
    }


    COMMAND "Keyboard Report Descriptor" 0x0D
    {
        doc "USB report descriptor to be used by the keyboard port."
        PARAM "Length"
            uint16
            doc "The length of the descriptor which follows."
            binary_message_only
            encode_value = ByteArrayValidLength("Descriptor");
        PARAM "Descriptor"
            uint8[1024] omit_pad_bytes
            doc "USB report descriptor to be used by the keyboard port.  The"
                "maximum length is 64 for most builds, but is extended for one"
                "customer-specific build.";
    }


    COMMAND "Mouse Report Descriptor" 0x0E
    {
        doc "USB report descriptor to be used by the mouse port."
        PARAM "Length"
            uint16
            doc "The length of the descriptor which follows."
            binary_message_only
            encode_value = ByteArrayValidLength("Descriptor");
        PARAM "Descriptor"
            uint8[1024] omit_pad_bytes
            doc "USB report descriptor to be used by the mouse port.  The"
                "maximum length is 64 for most builds, but is extended for one"
                "customer-specific build.";
    }


    COMMAND "Hub Manufacturer ID String Descriptor" 0x0F
    {
        doc "(USB Hub Manufacture String Descriptor)"
        PARAM "Manufacturer ID length"                      # in bytes
            uint8
            doc "(Length of entire structure in bytes)"
            binary_message_only
            encode_value = (2 + ByteArrayValidLength("Manufacturer ID Unicode-16"));
        PARAM "Manufacturer ID descriptor type"
            uint8
            doc "(USB string descriptor value...do not change)"
            binary_message_only
            encode_value = 3;                               # string descriptor
        PARAM "Manufacturer ID Unicode-16"
            uint8[60] omit_pad_bytes                        # typically, use the UNICODE construct
            doc "(Descriptor text)"
            valid_length = ("Manufacturer ID length" - 2)   # in bytes
            min = 0;
    }


    COMMAND "Hub Product ID String Descriptor" 0x10
    {
        doc "(USB Hub Product String Descriptor)"
        PARAM "Product ID length"                           # in bytes
            uint8
            doc "(Length of entire structure in bytes)"
            binary_message_only
            encode_value = (2 + ByteArrayValidLength("Product ID Unicode-16"));
        PARAM "Product ID descriptor type"
            uint8
            doc "(USB string descriptor value...do not change)"
            binary_message_only
            encode_value = 3;                               # string descriptor
        PARAM "Product ID Unicode-16"
            uint8[60] omit_pad_bytes                        # typically, use the UNICODE construct
            doc "(Descriptor Text)"
            valid_length = ("Product ID length" - 2)        # in bytes
            min = 0;
    }


    COMMAND "USB Factory Keyboard Rechargeable" 0x11
    {
        doc "Enable USB Factory Keyboard Rechargeable"
        PARAM "Enable"
            bool8
            doc "Enables USB Factory Keyboard Rechargeable if true.";
    }


    COMMAND "USB Factory Mouse Rechargeable" 0x12
    {
        doc "Enable USB Factory Mouse Rechargeable"
        PARAM "Enable"
            bool8
            doc "Enables USB Factory Mouse Rechargeable if true.";
    }


    COMMAND "USB Remove Factory HID Devices on HCI Reset" 0x13
    {
        doc "Enable Removal of Factory HID Devices on Reset"
        PARAM "Enable"
            bool8
            doc "Enables Removal of Factory HID Devices if true.";
    }


    COMMAND "USB Bluetooth Keyboard Product ID" 0x14
    {
        doc "Defines a USB Bluetooth Keyboard's Product ID."
        PARAM "USB Bluetooth Keyboard PID"
            uint16
            doc "USB Bluetooth Keyboard's Product ID is part of the GetHIDDeviceList HID control command.";
    }


    COMMAND "USB Bluetooth Mouse Product ID" 0x15
    {
        doc "Defines a USB Bluetooth Mouse's Product ID."
        PARAM "USB Bluetooth Mouse PID"
            uint16
            doc "USB Bluetooth Mouse's Product ID is part of the GetHIDDeviceList HID control command.";
    }


    COMMAND "Application-specific Config" 0xDD
    {
        doc "Defines Application-specific Configuration."
        PARAM "Data"
            uint8[1024] omit_pad_bytes
            doc "Specifies some values that will be used by firmware but are not defined in the other specified "
                "purpose entries Its length varies based on the data entry"
            valid_length = ByteArrayValidLength("Data")
            min = 1;
    }


    COMMAND "UHE Keyboard Set-Report ID to Remember" 0x16
    {
        doc "If report ID is not 0, this will cause the UHE application to store and send upon re-connections,"
            "the latest set-report recieved for the keyboard with this report id."
        PARAM "Set report ID"
            uint8
            doc "The report ID to remember.";
    }

    COMMAND "I2C Speed" 0x18
    {
        doc "This item is used to specify the I2C clock speed"
        PARAM "Speed"
            uint8
            doc "I2C Speed"
            enum
            {
                {0x00, "400 KHz"},
                {0x10, "100 KHz"},
                {0x20, "800 KHz"},
                {0x30, "1000 KHz"}
            };
    }

    COMMAND "Tx Power Table For Class 1.5 Devices" 0x1A
    {
        doc "This config item is used only for class 1.5 devices"
            "For class 2 devices, use the RF Attenuation Table item, 0x5E"
            "This command sets the Tx power in dB (signed char) and register values for each power step"
            "Class 1.5 devices may also be configured for class 2 power output levels"

	PARAM "FAB ID"
	    uint8
	    doc "FAB ID";

        PARAM "Radio Tx power mode"
            uint8
            doc "When set the radio regs will be configured for class 1.5 mode"
                "When cleared the radio regs will be configured for class 2 mode"
            enum
            {
                {0x0, "Class 2 mode"},
                {0x1, "Class 1.5 mode"}
            };
        PARAM "Power table length"
            uint8
            doc "The number of entries in the power control table, range is 2 to 8"
            min = 0x2
            max = 0x8;
        PARAM "Testmode power table length"
            uint8
            doc "The number of entries in the testmode power control table, range is 2 to 8"
            min = 0x2
            max = 0x8;
        PARAM "Tx power in dB[0]"
            uint8
            doc "The Tx power in dB to report for the corresponding register value";
        PARAM "Register value[0]"
            uint8
            doc "The register value to use for the Tx power at this step";
        PARAM "Tx power in dB[1]"
            int8;
        PARAM "Register value[1]"
            uint8;
        PARAM "Tx power in dB[2]"
            int8;
        PARAM "Register value[2]"
            uint8;
        PARAM "Tx power in dB[3]"
            int8;
        PARAM "Register value[3]"
            uint8;
        PARAM "Tx power in dB[4]"
            int8;
        PARAM "Register value[4]"
            uint8;
        PARAM "Tx power in dB[5]"
            int8;
        PARAM "Register value[5]"
            uint8;
        PARAM "Tx power in dB[6]"
            int8;
        PARAM "Register value[6]"
            uint8;
        PARAM "Tx power in dB[7]"
            int8;
        PARAM "Register value[7]"
            uint8;
        PARAM "Testmode Tx power in dB[0]"
            int8
            doc "The Tx power in dB to report for the corresponding register value";
        PARAM "Testmode register value[0]"
            uint8
            doc "The register value to use for the Tx power at this step";
        PARAM "Testmode Tx power in dB[1]"
            int8;
        PARAM "Testmode register value[1]"
            uint8;
        PARAM "Testmode Tx power in dB[2]"
            int8;
        PARAM "Testmode register value[2]"
            uint8;
        PARAM "Testmode Tx power in dB[3]"
            int8;
        PARAM "Testmode register value[3]"
            uint8;
        PARAM "Testmode Tx power in dB[4]"
            int8;
        PARAM "Testmode register value[4]"
            uint8;
        PARAM "Testmode Tx power in dB[5]"
            int8;
        PARAM "Testmode register value[5]"
            uint8;
        PARAM "Testmode Tx power in dB[6]"
            int8;
        PARAM "Testmode register value[6]"
            uint8;
        PARAM "Testmode Tx power in dB[7]"
            int8;
        PARAM "Testmode register value[7]"
            uint8;
    }

    COMMAND "Compressed data" 0x1B
    {
        doc "Reads and decompresses arbitrary data, which could be code, into an arbitrary location in RAM."
        PARAM "Address"
            uint32
            doc "The address to which the (decompressed) data bytes are to be loaded.";
        PARAM "Data"
            uint8[0xFF00] omit_pad_bytes
            doc "The compressed data bytes to be loaded to the Address specified.";
    }


    COMMAND "MPAF APP Configuration" 0x3E
    {
        doc "Configures various  properties of MPAF and Applications"

        PARAM "Enable"
            uint8
            doc "Enable bit for MPAF.";
        PARAM "FeatureMap"
            uint32
            doc "MPAF configuration ' feature map."
                "  0x00000001: Enable USB HUB"
                "  0x00000002: Allow Any Connection"
                "  0x80000000: Allow Zero COD"
                "  Remaining are reserved"
            bitmap
            {
                {0x00000001, "Enable USB HUB"},
                {0x00000002, "Allow Any Connection"},
                {0x80000000, "Allow Zero COD"}
            };
        PARAM "NV Max Devinfo"
            uint8
            doc "Maximum Dev info storage. Default=8";
        PARAM "App trans Mode"
            uint8
            doc "BIT_0_3 => represents the RAW or HCI mode  RAWMODE =1 HCI mode =0 - Default 0"
                  "BIT_4-7 => represents the transport type in the RAW mode. H5 =1 UART =0 - Default 0";
        PARAM "MPAF Pkt type"
            uint8
            doc "MPAF Packet type indicator."
                "WARNING: Be Careful with Reserved Types: 1-CMD,2-ACL,3-SCO,4-EVENT"
                "Using Reserved Types might lead to conflicts";
        PARAM "Patch Start"
            uint32
            doc "The value of the PATCH_START macro."
                "It limits the dynamic MPAF memory allocation within this value."
                "Use zero to turn off this feature.";
        PARAM "Rx Buffer Size"
            uint16
            doc "RawMode RX Buffer size Default 512 for Baud rate 115200";
        PARAM "latency Timer Tick"
            uint16
            doc "RawMode Timer value Deafult -2 (Scale 10msec)";

        PARAM "App Enable Mask"
            uint32
            doc "Enable bitmask for MPAF applications .Default is 0"
            bitmap
            {
                {0x00000001, "UHE"},
                {0x00000002, "Remote Control"},
                {0x00000004, "SPP"},
                {0x00000008, "Nintendo"},
                {0x00000010, "3D TV"},
                {0x00000020, "3D PC"},
                {0x00000040, "3D IR2BT"},
                {0x00000080, "PNP Headset"},
                {0x00000100, "ITMGR"},
                {0x00000200, "3DTV_LGE"},
                {0x00000400, "RSVD_10"},
                {0x00000800, "RSVD_11"},
                {0x00001000, "WICED"},
                {0x00002000, "ATCE"},
                {0x00004000, "TVWAKE"},
                {0x00008000, "MPAF Test"},
                {0x00010000, "HIDD_APP"},
                {0x00020000, "RSVD_17"},
                {0x00040000, "RSVD_18"},
                {0x00080000, "RSVD_19"},
                {0x00100000, "RSVD_20"},
                {0x00200000, "RSVD_21"},
                {0x00400000, "RSVD_22"},
                {0x00800000, "RSVD_23"},
                {0x01000000, "RSVD_24"},
                {0x02000000, "RSVD_25"},
                {0x04000000, "RSVD_26"},
                {0x08000000, "RSVD_27"},
                {0x10000000, "RSVD_28"},
                {0x20000000, "RSVD_29"},
                {0x40000000, "RSVD_30"},
                {0x80000000, "RSVD_31"}
            };

        # Remote Control App related config entries
        PARAM "RC_DataInPktType"
            uint8
            doc "Packet type byte for the ACL data sent to host. Default: 2 (ACL)"
            enabled_if(("App Enable Mask" & 0x0002) = 0x0002);
        PARAM "RC_CmdReportId"
            uint8
            doc "Report ID for the commands issued to the Remote Control. Default: 0xF9"
            enabled_if(("App Enable Mask" & 0x0002) = 0x0002);
        PARAM "RC_Port"
            uint8
            doc "Port Number for the Data In channel. Default: 3 (PORT_4)"
            enabled_if(("App Enable Mask" & 0x0002) = 0x0002);
        PARAM "RC_Endpoint"
            uint8
            doc "Endpoint for the Data In channel. Default: 2"
            enabled_if(("App Enable Mask" & 0x0002) = 0x0002);
        PARAM "RC_cod"
            uint8[3]
            doc "Remote Control Class of Device. Default 0x00258C"
            enabled_if(("App Enable Mask" & 0x0002) = 0x0002);
        PARAM "RC_codMask"
            uint8[3]
            doc "Remote Control Class of Device Mask. Default 0x5E1F0C"
            enabled_if(("App Enable Mask" & 0x0002) = 0x0002);
        ################## SPP APP CONFIGS ############################
        # SPP App related config entries
        PARAM "SPP Role"
            bool8
            doc "SPP device type Server=0 Client=1. Default=0(Server)"
            enabled_if(("App Enable Mask" & 0x1004) != 0);#SPP,WICED
        PARAM "Transport Channel no"
            uint8
            doc "Channel Number Default 0 for Raw Mode ,For HCI mode Channel can be deined from 1-15"
            enabled_if(("App Enable Mask" & 0x1004) != 0);#SPP,WICED
        PARAM "spp_gpio_no"
            uint8
            doc "gpio used in deciding to switch to hci mode in Raw mode to add dev list Default 3"
            enabled_if(("App Enable Mask" & 0x0004) = 0x0004);
        PARAM "spp_gpio_polarity"
            bool8
            doc "polarity of the gpio Default 1"
            enabled_if(("App Enable Mask" & 0x0004) = 0x0004);
        PARAM "spp_mtu_size"
            uint16
            doc "Spp frame size Default 100"
            enabled_if(("App Enable Mask" & 0x3004) != 0);#SPP,ATCE,WICED
        PARAM "spp_cod"
            uint8[3]
            doc "Spp class of device  Default 0x10304"
            enabled_if(("App Enable Mask" & 0x3004) != 0);#SPP,ATCE,WICED
        PARAM "spp_cod_mask"
            uint8[3]
            doc "Spp class of device mask  Default 0xFFFFFF"
            enabled_if(("App Enable Mask" & 0x3004) != 0);#SPP,ATCE,WICED
        ################## TVWAKE APP CONFIGS ############################
        # TVWAKE App related config entries
        PARAM "rfc enable"
            bool8
            doc "rfc enable -Tvwake cmd over rfcomm -1 . Default=0(legacy tvwake app)"
            enabled_if(("App Enable Mask" & 0x4000) = 0x4000);
        PARAM "rfc UUID"
            uint16
            doc "UUID set for tvwake APP service  over RFCOM"
            enabled_if(("App Enable Mask" & 0x4000) = 0x4000);
        #########################################################
    }

    COMMAND "BT HID transport configuration" 0xA0
    {
        doc "Configuration for the BT HID transport driver"

        PARAM "classOfDevice"
            uint8[3]
            doc "The class of this device, e.g. keyboard, mouse, etc."
            valid_length = ByteArrayValidLength("classOfDevice")
            min = 0;
        PARAM "maxNumHosts"
            uint8
            doc "Maximum number of hosts we can keep in non-volatile storage. Only used"
                "if the host list is constructed by BtHidTransport";
        PARAM "autoPairingReportId"
            uint8
            doc "AutoPairingReportId";
        PARAM "reconnectInitiate"
            uint8
            doc "When non-zero, indicates that we can initiate a connection"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "normallyConnectable"
            uint8
            doc "When FALSE, the device does not enter Page Scan."
                "When TRUE, the device will enter Page Scan if there is one or more bonded hosts."
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "reenterDiscoverableOnFirstConnectAuthFailure"
            uint8
            doc "Flag indicating that we should reenter discoverable if authentication fails"
                "in the first connection after discoverable. This allows support of"
                "pin code entry reports that can only be sent if the host stack opens the"
                "interrupt channel before doing pairing"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "moveHostToTopOfListOnConnect"
            uint8
            doc "Flag indicating that a connected host should be moved to the top of the"
                "host list. This ensures that the host list is maintained in a most recently"
                "connected order and causes reconnect to be attempted to the most recently"
                "connected host, followed by the one before, etc."
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "exitDiscoverableOnAuthFailure"
            uint8
            doc "Flag indicating whether we should exit discoverable on an authentication"
                "failure"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "autoPairingEnabled"
            uint8
            doc "Flag indicating whether auto-pairing is enabled"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "abnormalDisconnectReasons"
           uint8[5]
           doc "Disconnect reasons, considered abnormal"
               "Initilalized as : e.g. {0xFF,0xFF,0xFF,0xFF,0xFF}"
               valid_length = ByteArrayValidLength("abnormalDisconnectReasons")
               min = 0;
        PARAM "securityMode"
            uint8
            doc "Security mode for the device. One of BTM_SEC_MODE_NONE,"
                "BTM_SEC_MODE_SERVICE, BTM_SEC_MODE_LINK."
                "Typically this is set to BTM_SEC_MODE_NONE which disables security in the"
                "BT core and then the actual security is enforced at the service"
                "level (for HIDs this means that any desired security is enforced at"
                "the control channel level)."
            enum
            {
                {0, "UNDEFINED"},
                {1, "NONE"},
                {2, "SERVICE"},
                {3, "LINK"},
                {4, "SSP"}
            };
        PARAM "ctrlChannelSecurity"
            uint8
            doc "Security requirements for HID control channel"
            enum
            {
                {0x00, "NONE"},
                {0x02, "IN_AUTHENTICATE"},
                {0x04, "IN_ENCRYPT"},
                {0x10, "OUT_AUTHENTICATE"},
                {0x20, "OUT_ENCRYPT"},
                {0x40, "BOND"}
            };
        PARAM "intrChannelSecurity"
            uint8
            doc "Security requirements for HID interrupt channel"
            enum
            {
                {0x00, "NONE"},
                {0x02, "IN_AUTHENTICATE"},
                {0x04, "IN_ENCRYPT"},
                {0x10, "OUT_AUTHENTICATE"},
                {0x20, "OUT_ENCRYPT"},
                {0x40, "BOND"}
            };
        PARAM "ioCapabilities"
            uint8
            doc "Input/Output capabilities of the current application to be used in secure simple pairing"
            enum
            {
                {0x00, "DISPLAY_ONLY"},
                {0x01, "DISPLAY_AND_KEYS"},
                {0x02, "KEYS_ONLY"},
                {0x03, "NONE"}
            };
        PARAM "oobCapable"
            uint8
            doc "Whether this application is capable and willing to do OOB SSP."
            enum
            {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
            };
        PARAM "mitmProtection"
            uint8
            doc "Man-in-the-middle protection requirements of this application"
            enum
            {
                {0x00, "NOT_REQUIRED_NON_BOND_AUTO_ACCEPT_OK"},
                {0x01, "REQUIRED_NON_BOND_USE_IO_CAP"},
                {0x02, "NOT_REQUIRED_DEDICATED_BOND_AUTO_ACCEPT_OK"},
                {0x03, "REQUIRED_DEDICATED_BOND_USE_IO_CAP"},
                {0x04, "NOT_REQUIRED_GENERAL_BOND_AUTO_ACCEPT_OK"},
                {0x05, "REQUIRED_GENERAL_BOND_USE_IO_CAP"}
            };
        PARAM "discoveryPeriodInSecs"
            uint16
            doc "Discoverable timeout in seconds";

        PARAM "discoveryTickBasePeriodInMs"
              uint16
              doc "Discovery tick base period in milliseconds";

        PARAM "incomingConnectionTimeoutInSecs"
            uint16
            doc "Connect timeout in seconds. Used when accepting connection in"
                "DISCOVERABLE/CONNECTABLE states";

        PARAM "reconnectTimeoutInSecs"
            uint16
            doc "When (re)connecting, a single BT connection will be given this"
                "much time to complete (open interrupt channel) before it"
                "will be torn down";

        PARAM "ctrlChSetupTimeoutInSecs"
            uint16
            doc "It is timeout value of the L2CAP Control Channel setup."
                "When (re)connecting, the control channnel setup will"
                "be given this much time before it is torn down (without"
                "the ACL being torn down) and an attempt will be made to"
                "re-establish the ctrlCh";

        PARAM "roleSwitchTimeoutInSecs"
            uint16
            doc "It is timeout value of the role switch."
                "When (re)connecting, the HID device tries to switch to the"
                "desired role if it is not in this role after this much time";

        PARAM "reconnectPageTimeout"
            uint16
            doc "Page timeout used for reconnecting";

        PARAM "abnormalReconnectTimeoutInSecs"
            uint16
            doc "When reconnecting because of an abnormal disconnect reconnect,"
                "a single BT connection will be given this"
                "much time to complete (open interrupt channel) before it"
                "will be torn down";

        PARAM "abnormalReconnectPageTimeout"
            uint16
            doc "Page timeout used for abnormal disconnect reconnect";

        PARAM "maxReconnectRetryCount"
            uint8
            doc "Maximum number of time an attempt will be made to reconnect to one host"
                "before deciding that it is not connectable and moving on to the next";

        PARAM "maxRoleSwitchRetryCount"
            uint8
            doc "Maximum number of time an attempt will be made to switch role";

        PARAM "maxAbnormalDisconnectRetryCount"
            uint8
            doc "Maximum number of time an attempt will be made to reconnect to the last host"
                "before deciding that it is not connectable and moving on to the next";

        PARAM "inquiryScanType"
            uint8
            doc "Inquiry scan type, interlaced or non-interlaced"
            enum
            {
                {0, "BTM_SCAN_TYPE_STANDARD"},
                {1, "BTM_SCAN_TYPE_INTERLACED"}
            };

        PARAM "inquiryScanMode"
            uint8
            doc "Inquiry scan mode, limited discoverable or general discoverable"
            enum
            {
                {0, "BTM_NON_DISCOVERABLE"},
                {1, "BTM_LIMITED_DISCOVERABLE"},
                {2, "BTM_GENERAL_DISCOVERABLE"}
            };

        PARAM "inquiryScanWindow"
            uint16
            doc "Inquiry scan window size in slots";

        PARAM "inquiryScanInterval"
            uint16
            doc "Inquiry scan interval in slots";

        PARAM "pageScanType"
            uint8
            doc "Page scan type, interlaced or non-interlaced"
            enum
            {
                {0, "BTM_SCAN_TYPE_STANDARD"},
                {1, "BTM_SCAN_TYPE_INTERLACED"}
            };

        PARAM "pageScanWindow"
            uint16
            doc "Page scan window size in slots";

        PARAM "pageScanInterval"
            uint16
            doc " Page scan interval in slots";

        PARAM "pktTypeDh5"
            uint16 {15}
            doc "DH5 Packet type enabled/disabled"
            enum
            {
                {0, "DISABLE"},
                {1, "ENABLE"}
            };

        PARAM "pktTypeDm5"
            uint16 {14}
            doc "DM5 Packet type enabled/disabled"
            enum
            {
                {0, "DISABLE"},
                {1, "ENABLE"}
            };

        PARAM "pktType3Dh5"
            uint16 {13}
            doc "3-DH5 packet type enabled/disabled"
            enum
            {
                {0, "ENABLE"},
                {1, "DISABLE"}
            };

        PARAM "pktType2Dh5"
            uint16 {12}
            doc "2-DH5 packet type enabled/disabled"
            enum
            {
                {0, "ENABLE"},
                {1, "DISABLE"}
            };

        PARAM "pktTypeDh3"
            uint16 {11}
            doc "DH3 packet type enabled/disabled"
            enum
            {
                {0, "DISABLE"},
                {1, "ENABLE"}
            };

        PARAM "pktTypeDm3"
            uint16 {10}
            doc "DM3 packet type enabled/disabled"
            enum
            {
                {0, "DISABLE"},
                {1, "ENABLE"}
            };

        PARAM "pktType3Dh3"
            uint16 {9}
            doc "3-DH3 packet type enabled/disabled"
            enum
            {
                {0, "ENABLE"},
                {1, "DISABLE"}
            };

        PARAM "pktType2Dh3"
            uint16 {8}
            doc "2-DH3 packet type enabled/disabled"
            enum
            {
                {0, "ENABLE"},
                {1, "DISABLE"}
            };

        PARAM "pktTypeHv3"
            uint16 {7}
            doc "HV3 packet type enabled/disabled"
            enum
            {
                {0, "DISABLE"},
                {1, "ENABLE"}
            };

        PARAM "pktTypeHv2"
            uint16 {6}
            doc "HV2 packet type enabled/disabled"
            enum
            {
                {0, "DISABLE"},
                {1, "ENABLE"}
            };

        PARAM "pktTypeHv1"
            uint16 {5}
            doc "HV1 packet type enabled/disabled"
            enum
            {
                {0, "DISABLE"},
                {1, "ENABLE"}
            };

        PARAM "pktTypeDh1"
            uint16 {4}
            doc "DH1 packet type enabled/disabled"
            enum
            {
                {0, "DISABLE"},
                {1, "ENABLE"}
            };

        PARAM "pktTypeDm1"
            uint16 {3}
            doc "DM1 packet type enabled/disabled"
            enum
            {
                {0, "DISABLE"},
                {1, "ENABLE"}
            };

        PARAM "pktType3Dh1"
            uint16 {2}
            doc "3DH1 packet type enabled/disabled"
            enum
            {
                {0, "ENABLE"},
                {1, "DISABLE"}
            };

        PARAM "pktType2Dh1"
            uint16 {1}
            doc "2DH1 packet type enabled/disabled"
            enum
            {
                {0, "ENABLE"},
                {1, "DISABLE"}
            };

        PARAM "pktTypeReserved"
            uint16 {0}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "pageScanRepMode"
            uint8
            doc "Page scan repetition mode. R0, R1 etc"
            enum
            {
                {0, "PAGE_SCAN_REP_MODE_R0"},
                {1, "PAGE_SCAN_REP_MODE_R1"},
                {2, "PAGE_SCAN_REP_MODE_R2"}
            };

        PARAM "pageScanMode"
            uint8
            doc "One of the optional or mandatory scan modes"
            enum
            {
                {0, "PAGE_SCAN_MANDATORY_MODE"},
                {1, "PAGE_SCAN_OPTIONAL_MODE_1"},
                {2, "PAGE_SCAN_OPTIONAL_MODE_2"},
                {3, "PAGE_SCAN_OPTIONAL_MODE_3"}
            };

        PARAM "allowSwitch"
            uint8
            doc "TRUE for allowing roll switch, FALSE otherwise"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };

        PARAM "becomeDiscoverableWhenNotConnected"
            uint8
			doc "When FALSE, the device does not response to Inquire/Page."
				"When TRUE, the device will response to Inquire/Page if there is one or more banded hosts."
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };

        PARAM "Link Supervision Timeout value"
            uint16
            doc "Time slots for link to timeout"
            default = 32000;

         PARAM "sleepInConnection"
            uint8
            doc "Disables sleep in connection when set to TRUE"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };

         PARAM "transportPollPeriod"
            uint32
            doc "Transport Poll Period in microseconds. Note that this will get rounded to the"
                "nearest 12.5 ms multiple"
            default = 11250;

         PARAM "removeHostFromListOnVcUnplug"
            uint8
            doc "When TRUE, will remove the bonded host when it receives a VC Unplug from it."
                "When FALSE, will only disconnect but still keep the bonded host in its list."
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };

         PARAM "maxTransportStateChangeObservers"
            uint8
            doc "Maximum number of observers that can register for state change notifications."
                "Has to be at least 1, defaults to 2"
            min = 1
            default = 2;

         PARAM "maxTransportActivityObservers"
            uint8
            doc "Maximum number of observers that can register for OTA activity notifications."
                "May be set to 0, defaults to 2."
            default = 2;

         PARAM "advanceTxOpportunityNotice"
            uint16
            doc "Advance wakeup in uS."
            default = 2500;

        PARAM "hostLpmReportId"
            uint8
            doc "Report ID of host controlled LPM";

        PARAM "proximityAssocEnabled"
            uint8
			doc "When FALSE, the device does not support proximity association"
				"When TRUE, the device is capable of looking for hosts to associate with based on their proximity."
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            }
            default = 0;

        PARAM "proximityAssocOnPowerUpWithNoVcHost"
            uint8
			doc "When FALSE, the device will not attempt proximity association on powering on with no virtually cabled hosts."
				"When TRUE, the device will attempt proximity association on powering on with no virtually cabled hosts."
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            }
            default = 0;

        PARAM "proximityAssocDefaultDurationInMs"
            uint16
            doc "The default duration of a proximity association attempt in milliseconds"
            default = 10000;

        PARAM "mcReconnectTimeoutInSlots"
            uint16
            doc "Timeout in BT slots for establishing a BRCM multicast connection"
            default = 8192;

        PARAM "mcReconnectRetryCount"
            uint8
            doc "Maximum number of attempts to establish a BRCM multicast connection."
            default = 1;

        PARAM "mcPseudoReportId"
            uint8
            doc "The pseudo HID report ID to use when passing the data to the application"
            default = 0xBC;

        PARAM "hidConnectionControlReportId"
            uint8
            doc "Report ID of the HID host feature report to enable/disable UCD/BRR/Multicast"
                "features of the HID and the UCD->connection oriented switch message";

        PARAM "l2capChannleOpenWaitTimeout"
            uint16
            doc "l2cap channle open delay timeout"
            default = 0;

        # Kunye: 2013/7/2, In current fw code, this member is not deifned
        ##PARAM "VcUnplugWorkAroundEnabled"
        ##    uint8
        ##    doc "On some hosts, they do not open the HID interrupt and control channels after pairing completes. According to the spec,"
        ##        "the HID channels need to be established in order for the VC Unplug (Pairing) information to be stored."
        ##        "we enable a work around for such hosts"
        ##    enum
        ##    {
        ##        {0, "FALSE"},
        ##        {1, "TRUE"}
        ##    }
        ##    default = 0;
   }

   COMMAND "Hid App LPM Configuration" 0xB3
   {
        doc "Hid application Low Power mode configuration"
        PARAM "Disconnect Low Power Mode"
                uint8
                doc "LOW power mode set to HIDOFF when disconnected"
                      "LOW power mode set to ADP when disconnected"
                       "LOW power mode set to SLEEP when disconnected"
                enum
                {
                    { 0,     "HID_OFF"},
                    { 1,     "APD"},
                    { 2,     "SLEEP"}
                };

        PARAM "Max Support Objects to query"
                uint8
                doc "max supported objects to query";
   }

   COMMAND "HID application configuration" 0xA1
   {
        doc "Hid application configuration. Defines behavior of the common HID"
            "portion of an application"
        PARAM "vcUnplugOnConnectButtonPress"
            uint8
            doc "Whether to generate a VC unplug on connect button press"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "becomeDiscoverableOnConnectButtonPress"
            uint8
            doc "Whether to become discoverable on connect button press"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "becomeDiscoverableOnPowerUp"
            uint8
            doc "Whether to become discoverable on power up"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "defaultReportProtocol"
            uint8
            doc "This is the reporting protocol used upon connection establishment"
            enum
            {
                {0, "PROTOCOL_BOOT"},
                {1,"PROTOCOL_REPORT"}
            };
        PARAM "defaultIdleRate"
            uint8
            doc "This is the idle rate used upon connection establishment";
        PARAM "connectButtonHeldDurationInHalfSlots"
            uint16
            doc "Duration in half slots for which the connect button needs to be held before"
                "events are generated. Note that if hid-off is in use, connect button"
                "while coming out of hid-off cannot be measured. In this situation, either"
                "connect button held duration should be set to 0, i.e. a mometary press, or it"
                "should be set so that it excludes the startup time, which is specific"
                "to each product. For example, if the startup time is 300 ms, a connect button held"
                "duration of 100 ms will react to connect button presses of 300+100 = 400 ms minimum"
                "or longer. Detection of 300 ms or less is not possible in this example.";
        PARAM "powerSwitchID"
            uint8
            doc "ID of the power switch - the default driver uses the index in the definitation table as ID";
        PARAM "discoveryLedEnabled"
            uint8
            doc "Enable discovery LED support. Note that the associated GPIO must be configured"
                "for output seperately (via gpio config)"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "discoveryLedPort"
            uint8
            doc "Port to which the discovery LED is connected to";
        PARAM "discoveryLedPin"
            uint8
            doc "Pin to which the discovery LED is connected to";
        PARAM "discoveryLedGpioValueToTurnOn"
            uint8
            doc "GPIO value that turns the discovery LED on";
        PARAM "discoveryLEDOnPeriod"
            uint8
            doc "LED on period in ticks - set to 0 to keep the LED on forever";
        PARAM "discoveryLEDOffPeriod"
            uint8
            doc "LED off period in ticks";
        PARAM "disableIdleMode"
            uint8
            doc "Whether to disable idle mode, which is deprecated in HID 1.1"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "RESERVED"
            uint8 {7:2}
            doc "Reserved";
            #binary_message_only
            #encode_value = 0;
        PARAM "sleepConnGpioWakeupSourceEnabled"
            uint8 {1}
            doc "Gpio Wakeup Source Enabled during sleep when connected"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "sleepDiscGpioWakeupSourceEnabled"
            uint8 {0}
            doc "Gpio Wakeup Source Enabled during sleep when disconnected"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
    }


    COMMAND "KB application configuration" 0xA2
    {
        doc "Keyboard application configuration. Defines behavior of the keyboard"
            "application"
        PARAM "stdRptID"
            uint8
            doc "ID of the standard report";
        PARAM "maxKeysInStdRpt"
            uint8
            doc "Maximum number of keys in standard key report. Should be set to 6";
        PARAM "bitReportID"
            uint8
            doc "Report ID for the bit mapped report";
        PARAM "numBitMappedKeys"
            uint8
            doc "Number of bit mapped keys. Size of the bit report is automatically calculated from this value"
                "according to the following formula:"
                "report size = ((num bit mapped keys) + 7)/8";
        PARAM "sleepReportID"
            uint8
            doc "Report ID for the bit mapped report";
        PARAM "pinReportID"
            uint8
            doc "Report ID of the pin entry report";
        PARAM "ledReportID"
            uint8
            doc "Report ID of the LED (output) report";
        PARAM "defaultLedState"
            uint8
            doc "Default LED state. Note that the default implementation does not tie the LED value to physical LEDs";
        PARAM "connectButtonScanIndex"
            uint8
            doc "Scan code of the connect button";
        PARAM "recoveryPollCount"
            uint8
            doc "After an error has occurred, events from multiple poll cycles are combined to ensure that transient"
                "events are not generated. The count below specifies the recovery period in poll cycles.";
        PARAM "hwFifoThresholdForIdleRateReports"
            uint8
            doc "HW fifo threshold to stop generating idle rate reports. Idle rate report will be generated"
                "as long as the number of packets in the HW fifo is below this number";
        PARAM "repeatRateInBTClocksForRolloverRpt"
            uint16
            doc "This parameter defines the rate at which a rollover report is generated when an error state (ghost or overflow) is "
                "maintained for long periods of time. The rate is in BT clock periods. If set to 0, it disables regeneration of"
                "the rollover report.";
        PARAM "hwFifoThresholdForRolloverRepeats"
            uint8
            doc "Rollover reports will only be repeated as long as the number of packets in the HW fifo is less than this threshold";
        PARAM "funcLockReportID"
            uint8
            doc "Report ID for func-lock reports";
        PARAM "defaultFuncLockState"
            uint8
            doc "Default func lock state"
             enum
            {
                {0, "FUNC_LOCK_STATE_OFF"},
                {1, "FUNC_LOCK_STATE_ON"}
            };
        PARAM "scrollReportID"
            uint8
            doc "Scroll report ID";
        PARAM "scrollReportLen"
            uint8
            doc "Length of scroll report";
        PARAM "negateScroll"
            uint8
            doc "Negate scroll data"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "scrollScale"
            uint8
            doc "Scale values for scroll wheel data. Should be set to zero if no scaling is desired"
                "Scaling always divides the input data, i.e. its a shift right.";
        PARAM "pollsToKeepFracScrollData"
            uint8
            doc "Maximum number of ticks for which fractional scroll wheel motion data is kept,"
                "i.e. if no additional motion is detected, remaining fractional data is discarded."
                "If set to 0, data is never discarded. If scroll scaling is not used, should be set to"
                "0 to improve execution efficiency.";
        PARAM "scrollCombining"
            uint8
            doc "Flag indicating whether multiple scroll events should be combined into a single report"
                "Note that this will not combine any other type of event with scroll info."
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "maxEventSize"
            uint8
            doc "Size of each element in the app event queue. Note: This has to be at least as large as the"
                "largest event that the app will handle"
            min = 6;
        PARAM "maxEventNum"
            uint8
            doc "Maximum number of events that the app event queue can hold.";

    }


    COMMAND "KB key configuration" 0xBA
    {
        doc "This is the key translation table used to convert key scan codes returned by the keyscan driver to"
            "bits or codes in the key reports. Translation is a two step process. First the key type must be specified."
            "Valid types include standard keys that go in the standard key reports, modifier keys that go in the modifier"
            "key section of the standard report, bit-mapped keys that are reoprted as a bit in a bit map, the sleep and function lock"
            "keys which are classified seperately since they are special cases, and up to 8 user defined key types. Based on the"
            "key type the firmware calls the appropriate handler function which than uses the translation code to complete"
            "the task of putting the key in the appropriate report. Translation codes depend on the key type. For standard keys"
            "they are the USB usage codes for the keys. For modifier keys the code is a bit mapped field indicating the modifier key"
            "that it represents. For bit-mapped keys the code represents the bit number in the report controlled by the key."
            "Byte 0 in the bit report represents bit numbers 0(LSB)-7(MSB), byte 1 represents bit numbers 8(LSB)-15(MSB), and so on"

        PARAM "Number of columns"
            uint8
            doc "Defines the number of columns in the key translation table. Should be identical to the number of"
                "columns configured in the keyscan driver if the keyscan driver is in use"
            not_in_binary_message
            decode_value = 0
            min = 1
            max = 20;
        PARAM "Number of rows"
            uint8
            doc "Defines the number of rows in the key translation table. Should be identical to the number of"
                "rows configured in the keyscan driver if the keyscan driver is in use"
            not_in_binary_message
            decode_value = 0
            min = 1
            max = 8;


        PARAM "Key[Row0][Col0].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 0) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col0].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 0) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col0].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 0) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col0].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 0) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col0].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 0) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col0].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 0) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col0].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 0) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col0].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 0) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col0].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 0) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col0].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 0) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col0].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 0) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col0].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 0) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col0].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 0) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col0].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 0) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col0].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 0) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col0].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 0) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col1].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 1) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col1].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 1) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col1].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 1) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col1].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 1) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col1].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 1) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col1].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 1) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col1].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 1) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col1].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 1) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col1].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 1) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col1].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 1) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col1].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 1) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col1].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 1) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col1].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 1) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col1].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 1) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col1].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 1) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col1].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 1) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col2].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 2) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col2].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 2) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col2].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 2) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col2].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 2) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col2].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 2) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col2].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 2) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col2].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 2) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col2].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 2) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col2].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 2) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col2].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 2) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col2].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 2) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col2].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 2) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col2].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 2) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col2].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 2) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col2].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 2) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col2].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 2) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col3].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 3) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col3].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 3) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col3].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 3) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col3].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 3) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col3].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 3) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col3].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 3) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col3].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 3) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col3].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 3) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col3].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 3) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col3].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 3) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col3].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 3) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col3].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 3) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col3].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 3) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col3].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 3) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col3].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 3) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col3].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 3) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col4].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 4) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col4].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 4) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col4].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 4) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col4].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 4) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col4].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 4) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col4].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 4) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col4].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 4) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col4].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 4) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col4].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 4) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col4].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 4) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col4].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 4) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col4].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 4) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col4].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 4) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col4].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 4) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col4].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 4) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col4].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 4) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col5].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 5) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col5].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 5) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col5].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 5) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col5].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 5) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col5].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 5) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col5].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 5) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col5].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 5) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col5].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 5) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col5].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 5) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col5].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 5) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col5].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 5) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col5].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 5) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col5].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 5) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col5].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 5) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col5].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 5) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col5].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 5) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col6].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 6) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col6].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 6) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col6].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 6) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col6].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 6) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col6].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 6) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col6].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 6) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col6].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 6) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col6].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 6) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col6].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 6) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col6].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 6) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col6].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 6) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col6].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 6) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col6].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 6) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col6].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 6) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col6].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 6) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col6].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 6) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col7].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 7) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col7].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 7) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col7].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 7) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col7].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 7) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col7].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 7) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col7].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 7) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col7].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 7) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col7].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 7) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col7].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 7) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col7].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 7) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col7].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 7) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col7].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 7) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col7].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 7) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col7].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 7) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col7].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 7) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col7].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 7) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col8].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 8) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col8].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 8) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col8].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 8) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col8].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 8) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col8].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 8) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col8].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 8) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col8].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 8) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col8].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 8) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col8].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 8) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col8].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 8) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col8].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 8) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col8].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 8) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col8].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 8) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col8].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 8) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col8].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 8) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col8].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 8) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col9].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 9) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col9].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 9) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col9].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 9) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col9].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 9) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col9].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 9) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col9].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 9) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col9].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 9) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col9].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 9) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col9].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 9) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col9].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 9) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col9].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 9) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col9].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 9) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col9].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 9) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col9].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 9) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col9].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 9) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col9].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 9) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col10].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 10) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col10].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 10) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col10].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 10) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col10].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 10) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col10].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 10) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col10].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 10) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col10].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 10) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col10].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 10) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col10].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 10) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col10].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 10) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col10].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 10) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col10].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 10) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col10].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 10) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col10].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 10) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col10].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 10) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col10].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 10) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col11].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 11) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col11].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 11) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col11].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 11) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col11].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 11) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col11].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 11) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col11].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 11) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col11].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 11) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col11].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 11) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col11].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 11) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col11].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 11) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col11].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 11) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col11].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 11) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col11].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 11) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col11].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 11) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col11].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 11) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col11].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 11) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col12].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 12) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col12].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 12) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col12].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 12) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col12].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 12) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col12].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 12) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col12].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 12) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col12].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 12) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col12].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 12) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col12].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 12) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col12].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 12) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col12].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 12) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col12].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 12) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col12].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 12) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col12].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 12) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col12].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 12) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col12].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 12) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col13].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 13) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col13].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 13) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col13].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 13) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col13].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 13) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col13].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 13) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col13].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 13) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col13].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 13) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col13].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 13) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col13].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 13) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col13].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 13) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col13].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 13) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col13].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 13) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col13].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 13) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col13].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 13) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col13].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 13) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col13].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 13) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col14].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 14) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col14].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 14) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col14].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 14) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col14].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 14) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col14].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 14) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col14].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 14) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col14].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 14) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col14].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 14) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col14].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 14) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col14].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 14) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col14].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 14) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col14].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 14) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col14].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 14) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col14].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 14) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col14].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 14) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col14].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 14) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col15].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 15) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col15].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 15) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col15].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 15) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col15].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 15) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col15].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 15) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col15].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 15) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col15].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 15) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col15].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 15) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col15].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 15) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col15].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 15) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col15].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 15) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col15].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 15) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col15].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 15) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col15].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 15) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col15].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 15) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col15].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 15) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col16].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 16) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col16].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 16) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col16].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 16) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col16].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 16) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col16].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 16) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col16].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 16) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col16].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 16) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col16].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 16) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col16].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 16) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col16].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 16) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col16].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 16) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col16].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 16) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col16].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 16) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col16].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 16) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col16].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 16) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col16].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 16) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col17].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 17) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col17].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 17) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col17].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 17) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col17].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 17) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col17].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 17) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col17].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 17) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col17].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 17) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col17].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 17) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col17].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 17) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col17].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 17) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col17].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 17) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col17].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 17) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col17].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 17) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col17].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 17) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col17].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 17) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col17].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 17) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col18].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 18) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col18].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 18) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col18].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 18) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col18].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 18) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col18].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 18) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col18].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 18) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col18].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 18) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col18].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 18) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col18].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 18) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col18].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 18) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col18].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 18) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col18].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 18) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col18].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 18) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col18].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 18) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col18].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 18) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col18].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 18) and ("Number of rows" > 7));

        PARAM "Key[Row0][Col19].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 19) and ("Number of rows" > 0));
        PARAM "Key[Row0][Col19].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 19) and ("Number of rows" > 0));
        PARAM "Key[Row1][Col19].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 19) and ("Number of rows" > 1));
        PARAM "Key[Row1][Col19].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 19) and ("Number of rows" > 1));
        PARAM "Key[Row2][Col19].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 19) and ("Number of rows" > 2));
        PARAM "Key[Row2][Col19].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 19) and ("Number of rows" > 2));
        PARAM "Key[Row3][Col19].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 19) and ("Number of rows" > 3));
        PARAM "Key[Row3][Col19].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 19) and ("Number of rows" > 3));
        PARAM "Key[Row4][Col19].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 19) and ("Number of rows" > 4));
        PARAM "Key[Row4][Col19].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 19) and ("Number of rows" > 4));
        PARAM "Key[Row5][Col19].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 19) and ("Number of rows" > 5));
        PARAM "Key[Row5][Col19].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 19) and ("Number of rows" > 5));
        PARAM "Key[Row6][Col19].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 19) and ("Number of rows" > 6));
        PARAM "Key[Row6][Col19].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 19) and ("Number of rows" > 6));
        PARAM "Key[Row7][Col19].Type"
            uint8
            doc "See description of 'Key Translation Codes'"
            enum
            {
                {0, "None"},
                {1, "Standard"},
                {2, "Modifier"},
                {3, "Bit-Mapped"},
                {4, "Sleep"},
                {5, "Function Lock"},
                {6, "Function Lock Dependent"},
                {16, "User Defined 0"},
                {17, "User Defined 1"},
                {18, "User Defined 2"},
                {19, "User Defined 3"},
                {20, "User Defined 4"},
                {21, "User Defined 5"},
                {22, "User Defined 6"},
                {23, "User Defined 7"}
            }
            present_if (("Number of columns" > 19) and ("Number of rows" > 7));
        PARAM "Key[Row7][Col19].TranslationCode"
            uint8
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of columns" > 19) and ("Number of rows" > 7));
    }


    COMMAND "Func Lock Dependent Key Translation Codes" 0xBF
    {
        doc "This is the extended key translation table for func-lock dependent keys. Func-lock dependent keys"
            "can show up in either the bit mapped key report or in standard report. Typically these are the old"
            "style function keys that have been overloaded with additional meaning depending on the state of"
            "the func lock key. When func-lock is on, the keys act identically to the old function keys and are"
            "included in the standard key report along with the rest of the standard keys. When func-lock is off"
            "these keys become bit mapped keys that are reported with the rest of the consumer keys. Since the keys"
            "have multiple meanings, the key translation doesn't have room to provide the translation code for"
            "both behaviors. Instead the translation codes used for the bit mapped and standard reports are kept"
            "in this extended table and the standard translation table contains an index into the extended table"
            "for the func-lock dependent keys."
        PARAM "Number Of Keys"
            uint8
            doc "Defines the number of func-lock dependent keys in this extended table"
            not_in_binary_message
            decode_value = 0
            min = 1
            max = 24;

        PARAM "KeyIndex[0].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 0);
        PARAM "KeyIndex[0].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 0);

        PARAM "KeyIndex[1].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 1);
        PARAM "KeyIndex[1].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 1);

        PARAM "KeyIndex[2].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 2);
        PARAM "KeyIndex[2].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 2);

        PARAM "KeyIndex[3].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 3);
        PARAM "KeyIndex[3].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 3);

        PARAM "KeyIndex[4].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 4);
        PARAM "KeyIndex[4].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 4);

        PARAM "KeyIndex[5].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 5);
        PARAM "KeyIndex[5].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 5);

        PARAM "KeyIndex[6].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 6);
        PARAM "KeyIndex[6].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 6);

        PARAM "KeyIndex[7].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 7);
        PARAM "KeyIndex[7].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 7);

        PARAM "KeyIndex[8].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 8);
        PARAM "KeyIndex[8].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 8);

        PARAM "KeyIndex[9].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 9);
        PARAM "KeyIndex[9].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 9);

        PARAM "KeyIndex[10].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 10);
        PARAM "KeyIndex[10].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 10);

        PARAM "KeyIndex[11].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 11);
        PARAM "KeyIndex[11].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 11);

        PARAM "KeyIndex[12].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 12);
        PARAM "KeyIndex[12].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 12);

        PARAM "KeyIndex[13].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 13);
        PARAM "KeyIndex[13].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 13);

        PARAM "KeyIndex[14].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 14);
        PARAM "KeyIndex[14].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 14);

        PARAM "KeyIndex[15].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 15);
        PARAM "KeyIndex[15].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 15);

        PARAM "KeyIndex[16].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 16);
        PARAM "KeyIndex[16].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 16);

        PARAM "KeyIndex[17].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 17);
        PARAM "KeyIndex[17].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 17);

        PARAM "KeyIndex[18].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 18);
        PARAM "KeyIndex[18].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 18);

        PARAM "KeyIndex[19].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 19);
        PARAM "KeyIndex[19].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 19);

        PARAM "KeyIndex[20].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 20);
        PARAM "KeyIndex[20].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 20);

        PARAM "KeyIndex[21].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 21);
        PARAM "KeyIndex[21].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 21);

        PARAM "KeyIndex[22].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 22);
        PARAM "KeyIndex[22].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 22);

        PARAM "KeyIndex[23].BitMappedTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 23);
        PARAM "KeyIndex[23].StandardTranslationCode"
            uint8
            doc "See description of main item"
            present_if ("Number Of Keys" > 23);
   }


    COMMAND "LE TCA Table" 0xB4
    {
        doc "TCA temperature compensation tables. This format supports"
            "up to 15 8-bit and 5 16-bit register assignments and "
            "up to 6 temperature zones. Supports 32-bit addressing"
            "with 16-bit addressing offsets for each page of 5 registers."
            "------------------------------------------------------------------------"
            "                   Temperature switching points."
            " Temperatures are floored, i.e. the temperature listed is the minimum"
            " temperature for the designated zone."
            "------------------------------------------------------------------------"
            "                      8-bit and 16-bit page descriptors."
            " The page descriptors are used  to encapsulate the information common to"
            " a register  for all temperature ranges. This includes the base address,"
            " the address offsets, and the bitmasks."
            " Legend:"
            " Single array index = [Page]"
            " Dual array index = [Page][Reg]"
            "------------------------------------------------------------------------"
            "                       8-bit and 16-bit page data."
            " The page data are the temperature-dependent data for each register"
            " listed in the page descriptors above"
            " Legend: "
            " Triple Array Indices: [TStep][Page][Reg] "
            " Triple Array Indices: [TStep][Page][Reg] "
        PARAM "FAB ID"
            uint8
            doc "8-bit unique code for identifying the actual foundary at which"
                "this device was manufactured. Used to allow variable tuning for"
                "parts from different foundaries in the same products."
            default = 0xff;
        PARAM "Num TSteps"
            uint8
            doc "The number of temperature minimum switching points. The value"
                 "is actually the desired temperature plus a 50 degree Celsius offset"
                 "For example, a switching point of -5C would be input as 45"
                 "NOTE: The accuracy of the temperature sensor is around +/- 8C,"
                 "therefore switching points should be chosen carefully to avoid"
                 "repeated adjustments around a switching point."
            min = 1
            max = 6;

        # TSSI Target Settings - GFSK
        PARAM "Num TssiTargets"
            uint8
            doc "No of Tssi Target values - single or per frequency bin"
                "Set value either 1 or 5."
            min = 1
            max = 5;

        PARAM "TssiTarget[0][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "TssiTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1);
        PARAM "TssiTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);
        PARAM "TssiTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3);
        PARAM "TssiTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4);

        PARAM "TssiTarget[1][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep1 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "TssiTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));

        PARAM "TssiTarget[2][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep2 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "TssiTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));

        PARAM "TssiTarget[3][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep3 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "TssiTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));

        PARAM "TssiTarget[4][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep4 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "TssiTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));

        PARAM "TssiTarget[5][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep5 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "TssiTarget[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));


        # TSSI ranges - GFSK
        PARAM "TssiRangeLow[0]"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
                "the lowest temperature setting.";
        PARAM "TssiRangeHigh[0]"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
                "the lowest temperture setting.";
        PARAM "TssiRangeLow[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeHigh[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeLow[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeHigh[2]"
            uint8
            present_if("Num TSteps" > 2);
         PARAM "TssiRangeLow[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeHigh[3]"
            uint8
            present_if("Num TSteps" > 3);
         PARAM "TssiRangeLow[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeHigh[4]"
            uint8
            present_if("Num TSteps" > 4);
         PARAM "TssiRangeLow[5]"
            uint8
            present_if("Num TSteps" > 5);
        PARAM "TssiRangeHigh[5]"
            uint8
            present_if("Num TSteps" > 5);

        # Temperature dependent PA gain calibration factors
        PARAM "Num Pages8"
            uint8
            doc "Number of 8-bit data pages."
            min = 1
            max = 3;

        PARAM "Num Pages16"
            uint8
            doc "Number of 16-bit data pages."
            min = 0
            max = 1;
        ######################################################################
        #                              PAGE DESCRIPTORS
        #
        # Legend:
        # Single array index = [Page]
        # Dual array index   = [Page][Reg]
        #######################################################################
        #######################################################################
        #
        # 8 - BIT PAGE DESCRIPTORS
        #
        #######################################################################
        # Page 0 is reserved for the PA Driver gain control
        # Page 0
        PARAM "BaseAddress8[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages8" > 0);
        PARAM "NumRegs8[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages8" > 0);
        PARAM "AdrOffset8[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "Bitmask8[0][0]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "AdrOffset8[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "Bitmask8[0][1]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "AdrOffset8[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "Bitmask8[0][2]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "AdrOffset8[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "Bitmask8[0][3]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "AdrOffset8[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
        PARAM "Bitmask8[0][4]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));


        # Page 1
        PARAM "BaseAddress8[1]"
            uint32
            doc " 32-bit base address for Page 1"
            present_if("Num Pages8" > 1);
        PARAM "NumRegs8[1]"
            uint8
            doc " Number of registers in Page 1"
            min = 1
            max = 5
            present_if("Num Pages8" > 1);
        PARAM "AdrOffset8[1][0]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "Bitmask8[1][0]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "AdrOffset8[1][1]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "Bitmask8[1][1]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "AdrOffset8[1][2]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "Bitmask8[1][2]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "AdrOffset8[1][3]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "Bitmask8[1][3]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "AdrOffset8[1][4]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
        PARAM "Bitmask8[1][4]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));

        # Page 2
        PARAM "BaseAddress8[2]"
            uint32
            doc " 32-bit base address for Page 2"
            present_if("Num Pages8" > 2);
        PARAM "NumRegs8[2]"
            uint8
            doc " Number of registers in Page 2"
            min = 1
            max = 5
            present_if("Num Pages8" > 2);
        PARAM "AdrOffset8[2][0]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "Bitmask8[2][0]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "AdrOffset8[2][1]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "Bitmask8[2][1]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "AdrOffset8[2][2]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "Bitmask8[2][2]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "AdrOffset8[2][3]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "Bitmask8[2][3]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "AdrOffset8[2][4]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
        PARAM "Bitmask8[2][4]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));

        #######################################################################
        #
        # 16-BIT PAGE DESCRIPTORS
        #
        #######################################################################
        # Page 0
        PARAM "BaseAddress16[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages16" > 0);
        PARAM "NumRegs16[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages16" > 0);
        PARAM "AdrOffset16[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "Bitmask16[0][0]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "AdrOffset16[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "Bitmask16[0][1]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "AdrOffset16[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "Bitmask16[0][2]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "AdrOffset16[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "Bitmask16[0][3]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "AdrOffset16[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));
        PARAM "Bitmask16[0][4]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));

        #######################################################################
        # PAGE DATA
        #
        # Legend:
        # Triple Array Indices: [TStep][Page][Reg]
        #######################################################################
        #######################################################################
        #
        # 8-BIT PAGE DATA
        #
        #######################################################################
        # TStep 0
        # Page 0
        PARAM "Data8[0][0][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[0][0][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[0][0][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[0][0][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[0][0][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[0][1][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[0][1][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[0][1][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[0][1][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[0][1][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[0][2][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[0][2][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[0][2][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[0][2][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[0][2][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # TStep 1
        # Page 0
        PARAM "Data8[1][0][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[1][0][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[1][0][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[1][0][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[1][0][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[1][1][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[1][1][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[1][1][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[1][1][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[1][1][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[1][2][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[1][2][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[1][2][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[1][2][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[1][2][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # TStep 2
        # Page 0
        PARAM "Data8[2][0][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[2][0][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[2][0][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[2][0][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[2][0][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[2][1][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[2][1][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[2][1][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[2][1][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[2][1][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[2][2][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[2][2][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[2][2][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[2][2][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[2][2][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # TStep 3
        # Page 0
        PARAM "Data8[3][0][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[3][0][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[3][0][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[3][0][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[3][0][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[3][1][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[3][1][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[3][1][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[3][1][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[3][1][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[3][2][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[3][2][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[3][2][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[3][2][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[3][2][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # TStep 4
        # Page 0
        PARAM "Data8[4][0][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[4][0][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[4][0][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[4][0][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[4][0][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[4][1][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[4][1][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[4][1][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[4][1][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[4][1][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[4][2][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[4][2][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[4][2][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[4][2][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[4][2][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # TStep 5
        # Page 0
        PARAM "Data8[5][0][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[5][0][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[5][0][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[5][0][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[5][0][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[5][1][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[5][1][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[5][1][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[5][1][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[5][1][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[5][2][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[5][2][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[5][2][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[5][2][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[5][2][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );

        # 16-BIT PAGE DATA

        # TStep 0
        # Page 0
        PARAM "Data16[0][0][0]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 0"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[0][0][1]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 1"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[0][0][2]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 2"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[0][0][3]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 3"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[0][0][4]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 4"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # TStep 1
        # Page 0
        PARAM "Data16[1][0][0]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 0"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[1][0][1]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 1"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[1][0][2]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 2"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[1][0][3]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 3"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[1][0][4]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 4"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # TStep 2
        # Page 0
        PARAM "Data16[2][0][0]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 0"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[2][0][1]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 1"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[2][0][2]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 2"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[2][0][3]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 3"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[2][0][4]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 4"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # TStep 3
        # Page 0
        PARAM "Data16[3][0][0]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 0"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[3][0][1]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 1"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[3][0][2]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 2"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[3][0][3]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 3"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[3][0][4]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 4"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # TStep 4
        # Page 0
        PARAM "Data16[4][0][0]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 0"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[4][0][1]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 1"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[4][0][2]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 2"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[4][0][3]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 3"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[4][0][4]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 4"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # TStep 5
        # Page 0
        PARAM "Data16[5][0][0]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 0"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[5][0][1]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 1"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[5][0][2]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 2"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[5][0][3]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 3"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[5][0][4]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 4"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
    }


    COMMAND "PAPD Parameters" 0xB6
    {
        doc "This item is used to config papd parameters. It will be loaded to global array papd_params."
        PARAM "enable"
            uint8
            doc "Enables PAPD";
        PARAM "mode"
            uint8
            doc "PAPD mode"
            enum
            {
                {0x00, "PAPD_BOOT_ONLY"},
                {0x01, "PAPD_PERIODIC"},
                {0x02, "PAPD_TEMPERATURE_CHANGE"}
            };
        PARAM "periodic"
            uint32
            doc "periodic interval when the mode is PAPD_PERIODIC";
        PARAM "papd_delHoldMax"
            uint16
            doc "default: 0x200";
        PARAM "papd_delWait"
            uint16
            doc "default: 0x100";
        PARAM "papd_delHoldMin"
            uint16
            doc "default: 0x100";
        PARAM "papd_MaxCount"
            uint16
            doc "default: 0x780";
        PARAM "direct_rw"
            uint8
            doc "default: 1";
        PARAM "channel"
            uint16
            doc "default: 2441";
        PARAM "papd_pd"
            uint8
            doc "default: 0";
        PARAM "rx_dig_gain_0"
            uint16
            doc "default: 0x3906";
        PARAM "rx_dig_gain_1"
            uint16
            doc "default: 0x82f1";
        PARAM "rx_gain_0"
            uint16
            doc "default: 0x8000";
        PARAM "rx_gain_1"
            uint16
            doc "default: 0x0013";
        PARAM "rx_bpf_mode"
            uint16
            doc "default: 0x3c";
        PARAM "thresh_low"
            uint8
            doc "default: 0x0c";
        PARAM "thresh_high"
            uint8
            doc "default: 0x20";
        PARAM "anchor"
            uint8
            doc "default: 0x0a";
        PARAM "papd_tbl_overwrite"
            uint8
            doc "default: 0";
        PARAM "papd_mag_reg_val[0]"
            uint16
            doc "papd magnitude override value[0]";
        PARAM "papd_mag_reg_val[1]"
            uint16
            doc "papd magnitude override value[1]";
        PARAM "papd_mag_reg_val[2]"
            uint16
            doc "papd magnitude override value[2]";
        PARAM "papd_mag_reg_val[3]"
            uint16
            doc "papd magnitude override value[3]";
        PARAM "papd_mag_reg_val[4]"
            uint16
            doc "papd magnitude override value[4]";
        PARAM "papd_mag_reg_val[5]"
            uint16
            doc "papd magnitude override value[5]";
        PARAM "papd_mag_reg_val[6]"
            uint16
            doc "papd magnitude override value[6]";
        PARAM "papd_mag_reg_val[7]"
            uint16
            doc "papd magnitude override value[7]";
        PARAM "papd_mag_reg_val[8]"
            uint16
            doc "papd magnitude override value[8]";
        PARAM "papd_mag_reg_val[9]"
            uint16
            doc "papd magnitude override value[9]";
        PARAM "papd_mag_reg_val[10]"
            uint16
            doc "papd magnitude override value[10]";
        PARAM "papd_mag_reg_val[11]"
            uint16
            doc "papd magnitude override value[11]";
        PARAM "papd_mag_reg_val[12]"
            uint16
            doc "papd magnitude override value[12]";
        PARAM "papd_mag_reg_val[13]"
            uint16
            doc "papd magnitude override value[13]";
        PARAM "papd_mag_reg_val[14]"
            uint16
            doc "papd magnitude override value[14]";
        PARAM "papd_mag_reg_val[15]"
            uint16
            doc "papd magnitude override value[15]";
        PARAM "papd_mag_reg_val[16]"
            uint16
            doc "papd magnitude override value[16]";
        PARAM "papd_ph_reg_val[0]"
            uint16
            doc "papd phase override value[0]";
        PARAM "papd_ph_reg_val[1]"
            uint16
            doc "papd phase override value[1]";
        PARAM "papd_ph_reg_val[2]"
            uint16
            doc "papd phase override value[2]";
        PARAM "papd_ph_reg_val[3]"
            uint16
            doc "papd phase override value[3]";
        PARAM "papd_ph_reg_val[4]"
            uint16
            doc "papd phase override value[4]";
        PARAM "papd_ph_reg_val[5]"
            uint16
            doc "papd phase override value[5]";
        PARAM "papd_ph_reg_val[6]"
            uint16
            doc "papd phase override value[6]";
        PARAM "papd_ph_reg_val[7]"
            uint16
            doc "papd phase override value[7]";
        PARAM "papd_ph_reg_val[8]"
            uint16
            doc "papd phase override value[8]";
        PARAM "papd_ph_reg_val[9]"
            uint16
            doc "papd phase override value[9]";
        PARAM "papd_ph_reg_val[10]"
            uint16
            doc "papd phase override value[10]";
        PARAM "papd_ph_reg_val[11]"
            uint16
            doc "papd phase override value[11]";
        PARAM "papd_ph_reg_val[12]"
            uint16
            doc "papd phase override value[12]";
        PARAM "papd_ph_reg_val[13]"
            uint16
            doc "papd phase override value[13]";
        PARAM "papd_ph_reg_val[14]"
            uint16
            doc "papd phase override value[14]";
        PARAM "papd_ph_reg_val[15]"
            uint16
            doc "papd phase override value[15]";
        PARAM "papd_ph_reg_val[16]"
            uint16
            doc "papd phase override value[16]";
    }


    COMMAND "Serial Flash Write Protect Config" 0xB7
    {
        doc "Used to enable the write protect features and specify the GPIO to use for the HW write protect bit"
        PARAM "spare"
            uint8{ 7:6 }
            doc "padding or HW Write Protect GPIO (HWP) Port Number"
            "default = BT GPIO"
            enum
            {
                {0, "BT GPIO"},
                {1, "HW Write Protection HID Port 0"},
                {2, "HW Write Protection HID Port 1"},
                {3, "HW Write Protection HID Port 2"}
            };
        PARAM "HW Write Protection GPIO"
            uint8{5:2}
            doc "The GPIO to be used for the HW Write protect (HWP) feature. When driven low, the HWP is asserted.";
        PARAM "HW Write Protection Enable"
            uint8{1}
            doc "When set to 1, HW Write Protect is enabled";
        PARAM "SW Write Protection Enable"
            uint8{0}
            doc "When set to 1, SW Write Protect is enabled";
    }


    COMMAND "RSSI Offset Valid Range" 0xB8
    {
        doc "Define valid range for RSSI offset calculated from RSSI measurements command"
        PARAM "Lower limit"
            int8
            doc "Lower limit for RSSI offset";
        PARAM "Upper limit"
            int8
            doc "Upper limit for RSSI offset";
    }

    COMMAND "Miscellaneous HID Config" 0xA4
    {
        doc "Miscellaneous configuration items for HID applications."
        PARAM "EEPROM WP Port"
            uint8 {7:5}
            doc "GPIO port to which the EEPROM Write protect line is connected."
                "To disable EEPROM Write Protection feature, set to 0b111";
        PARAM "EEPROM WP Pin"
            uint8 {4:0}
            doc "GPIO pin to which the EEPROM Write protect line is connected"
                "To disable EEPROM Write Protection feature, set to 0b11111";
        PARAM "EEPROM Custom area offset"
            uint32
            doc "Location of the application dedicated area in the EEPROM";
        PARAM "EEPROM Custom area length"
            uint32
            doc "Size of the application dedicated area in the EEPROM";
        PARAM "sFlash Custom area offset"
            uint32
            doc "Location of the application dedicated area in the sFlash";
        PARAM "sFlash Custom area length"
            uint32
            doc "Size of the application dedicated area in the sFlash";
        PARAM "DEBUG_UART"
            uint8
            doc "if DEBUG_UART is TRUE, GPIO 19 will be used as TX and GPIO 20 as RX"
            enum
		{
            {0, "FALSE"},
			{1, "TRUE"}
		};
        PARAM "DEBUG_TX"
            uint8
            doc "IF TRUE, GPIO 19 will be used as TX"
            enum
		{
            {0, "FALSE"},
			{1, "TRUE"}
		};

        PARAM "DEBUG_RX"
            uint8
            doc "IF TRUE, GPIO 19 will be used as RX"
            enum
		{
            {0, "FALSE"},
			{1, "TRUE"}
		};

    }

    COMMAND "App Init hidd_app_post_stack_init Function" 0xA5
    {
        doc "Post-stack Application Initialization Function location specifier"
        PARAM "Address"
            uint32
            doc "The address of the application initialization function (it's in little endian).";
    }


    COMMAND "Adc Driver Configuration" 0xA6
    {
        doc "Configure ADC driver"

        PARAM "Reserved_1"
            uint32 {31}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "ADC internal clock division"
            uint32 {30}
            doc "ADC internal clock division"
            enum
            {
                {1,  "Enable divide-by-2"},
                {0,  "Disable divide-by-2"}
            };

        PARAM "ADC input range selection for DC measurement path"
            uint32 {29}
            doc "ADC input range selection for DC measurement path"
            enum
            {
                {0,  "3.6V"},
                {1,  "1.8V"}
            };

        PARAM "Reserved_0"
            uint32 {28:26}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "Global bias current programmability"
            uint32 {25:24}
            doc "Global bias current programmability"
            default = 0x0;

        PARAM "Internal/External BG SCF power up sequence selection"
            uint32 {23}
            doc "Internal/External BG SCF power up sequence selection"
            enum
            {
                {1, "use external power up sequence"},
                {0, "use internal power up sequence"}
            };

        PARAM "External power up sequence for BG SCF bypass"
            uint32 {22}
            doc "External power up sequence for BG SCF bypass"
            enum
            {
                {1, "Bypass"},
                {0, "Not bypass"}
            };

        PARAM "BG REF switch cap filter bypass"
            uint32 {21}
            doc "BG REF switch cap filter bypass"
            enum
            {
                {1, "Bypass switch cap filter"},
                {0, "Enable switch cap filter"}
            };

        PARAM " Switch cap filter clock frequency selection"
            uint32 {20:19}
            doc " Switch cap filter clock frequency selection"
            enum
            {
                {0, "SCF_CLK_DIV_50KHz"},
                {1, "SCF_CLK_DIV_25KHz"},
                {2, "SCF_CLK_DIV_100KHz"},
                {3, "SCF_CLK_DIV_1p6MHz"}
            };

        PARAM "ADC reference voltage programmability"
            uint32 {18:15}
            doc "ADC reference voltage programmability"
            enum
            {
                {0, "850"},
                {1, "856.1"},
                {2, "862.1"},
                {3, "868.2"},
                {4, "874.3"},
                {5, "880.4"},
                {6, "886.4"},
                {7, "892.5"},
                {8, "801.4"},
                {9, "807.5"},
                {10, "813.6"},
                {11, "819.6"},
                {12, "825.7"},
                {13, "831.8"},
                {14, "837.9"},
                {15, "843.9"}
            };

        PARAM "BG CTAT current adjustment"
            uint32 {14:12}
            doc "BG CTAT current adjustment"
            enum
            {
                {0, "CTAT Current adjustment 0"},
                {1, "CTAT Current adjustment 0.92"},
                {2, "CTAT Current adjustment 1.92"},
                {3, "CTAT Current adjustment 3.02"},
                {4, "CTAT Current adjustment -3.51"},
                {5, "CTAT Current adjustment -2.68"},
                {6, "CTAT Current adjustment -1.82"},
                {7, "CTAT Current adjustment -0.93"}
            };

        PARAM "BG PTAT current adjustment"
            uint32 {11:9}
            doc "BG PTAT current adjustment"
            enum
            {
                {0, "PTAT Current adjustment 0"},
                {1, "PTAT Current adjustment 1.11"},
                {2, "PTAT Current adjustment 2.32"},
                {3, "PTAT Current adjustment 3.62"},
                {4, "PTAT Current adjustment -4.10"},
                {5, "PTAT Current adjustment -3.19"},
                {6, "PTAT Current adjustment -2.17"},
                {7, "PTAT Current adjustment -1.11"}
            };

        PARAM "Chip global power down control"
            uint32 {8}
            doc "Chip global power down control"
            enum
            {
                {1, "Power down"},
                {0, "Power up"}
            };

        PARAM "MIC path power up/down control selection in DC measurement mode"
            uint32 {7}
            doc "MIC path power up/down control selection in DC measurement mode"
            enum
            {
                {1, "Power up"},
                {0, "Power down"}
            };

        PARAM "MIC (Audio) input and DC measurement input selection"
            uint32 {6}
            doc "MIC (Audio) input and DC measurement input selection"
            enum
            {
                {1, "ADC in Audio mode"},
                {0, "ADC in DC mode"}
            };

        PARAM "Output synchronization clock phase controls"
            uint32 {5}
            doc "Output synchronization clock phase control"
            enum
            {
                {1, "Inverted click phase"},
                {0, "Non-inverted clock phase"}
            };

        PARAM "MIC bias power up/down"
            uint32 {4}
            doc "MIC bias power up/down"
            enum
            {
                {1, "Power up"},
                {0, "Power down"}
            };

        PARAM "ADC MIC (Audio) path power up/down control"
            uint32 {3}
            doc "ADC MIC (Audio) path power up/down control"
            enum
            {
                {1, "Power up"},
                {0, "Power down"}
            };

        PARAM "ADC core power up/down"
            uint32 {2}
            doc "ADC core power up/down"
            enum
            {
                {1, "Power up"},
                {0, "Power down"}
            };

        PARAM "ADC BG & REF power up/down"
            uint32 {1}
            doc "ADC BG & REF power up/down"
            enum
            {
                {1, "Power up"},
                {0, "Power down"}
            };

        PARAM "ADC IP level main power up/down control"
            uint32 {0}
            doc "ADC IP level main power up/down control"
            enum
            {
                {1, "Power up"},
                {0, "Power down"}
            };


        PARAM "Reserved_3"
            uint32 {31:23}
            doc "Reserved (Pin)"
            binary_message_only
            encode_value = 0;

        PARAM "MIC negative input select"
            uint32 {22}
            doc "MIC negative input select"
                "default 0x0"
            default = 0x0;

        PARAM "MIC_PGA_incmres_ctl"
            uint32 {21:20}
            doc "MIC_PGA_incmres_ctl"
                "default 0x0"
            default = 0x0;

        PARAM "PGA output common mode control"
            uint32 {19:18}
            doc "PGA output common mode control"
                "default = 0.6V"
            enum
            {
                {0x0,  "0.6V"},
                {0x1,  "0.7V"},
                {0x2,  "0.5V"}
            };

        PARAM "PGA input common mode control"
            uint32 {17:16}
            doc "PGA input common mode control"
                "default = 0.4*AVDD"
            enum
            {
                {0x0,  "0.4*AVDD"},
                {0x1,  "0.45*AVDD"},
                {0x2,  "0.35*AVDD"}
            };

        PARAM "MIC PGA gain control"
            uint32 {15:12}
            doc "MIC PGA gain control: 3dB steps"
                "default = 0dB"
            enum
            {
                {0x0,  "0dB"},
                {0x1,  "3dB"},
                {0x2,  "6dB"},
                {0x3,  "9dB"},
                {0x4,  "12dB"},
                {0x5,  "15dB"},
                {0x6,  "18dB"},
                {0x7,  "21dB"},
                {0x8,  "24dB"},
                {0x9,  "27dB"},
                {0xA,  "30dB"},
                {0xB,  "33dB"},
                {0xC,  "36dB"},
                {0xD,  "39dB"},
                {0xE,  "42dB"}
            };

        PARAM "MIC bias output impedance control"
            uint32 {11}
            doc "MIC bias low/high output impedance control during power down mode"
                "default = MIC bias output is HZ in power down mode"
            enum
            {
                {0x0,  "MIC bias output is HZ in power down mode"},
                {0x1,  "MIC bias output is LZ in power down mode"}
            };

        PARAM "Internal/External MIC bias SCF power up sequence selection"
            uint32 {10}
            doc "Internal/External MIC bias SCF power up sequence selection"
            enum
            {
                {0x0,  "Use internal power up sequence"},
                {0x1,  "Use external power up sequence"}
            };

        PARAM "External power up sequence for MIC bias SCF bypass"
            uint32 {9}
            doc "External power up sequence for MIC bias SCF bypass"
            default = 0x0;


        PARAM "Reserved_2"
            uint32 {8}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "MIC bias switch cap filter bypass"
            uint32 {7}
            doc "MIC bias switch cap filter bypass"
                "default = Enable switch cap filter"
            enum
            {
                {0x0,  "Enable switch cap filter"},
                {0x1,  "Bypass switch cap filter"}
            };

        PARAM "MIC bias reference filter clock programmability"
            uint32 {6:5}
            doc "MIC bias reference filter clock programmability"
                "default = 50KHz"
            enum
            {
                {0x0,  "50KHz"},
                {0x1,  "25KHz"},
                {0x2,  "100KHz"},
                {0x3,  "1.6MHz"}
            };

        PARAM "MIC bias reference selection"
            uint32 {4}
            doc "MIC bias reference selection"
                "default = Supply as MIC bias reference"
            enum
            {
                {0x0,  "Supply as MIC bias reference. MIC bias output voltage scaled with supply voltage"},
                {0x1,  "BG voltage as MIC bias reference to have constant MIC bias output voltage"}
            };

        PARAM "MIC bias output voltage programmability"
            uint32 {3:2}
            doc "MIC bias output voltage programmability"
                "default = 1.12 X Reference Voltage"
            enum
            {
                {0x0,  "1.12 X Reference Voltage"},
                {0x1,  "1.14 X Reference Voltage"},
                {0x2,  "1.17 X Reference Voltage"},
                {0x3,  "1.10 X Reference Voltage"}
            };

        PARAM "MIC bias reference voltage programmability"
            uint32 {1:0}
            doc "MIC bias reference voltage programmability"
                "default = 75% of Audio Supply"
            enum
            {
                {0x0,  "75% of Audio Supply"},
                {0x1,  "70% of Audio Supply"},
                {0x2,  "80% of Audio Supply"},
                {0x3,  "70% of Audio Supply"}
            };


        PARAM "Spare_0"
            uint32 {31:22}
            doc "Spare register"
            binary_message_only
            encode_value = 0;

        PARAM "Reserved_4"
            uint32 {21:9}
            doc "Reserved (Pin)"
            binary_message_only
            encode_value = 0;


        PARAM "Disable reset function on DC measurement"
            uint32 {8}
            doc "Disable reset function on DC measurement"
            enum
            {
                {1,  "Enable"},
                {0,  "Disable"}
            };


        PARAM "Disable the shuffler"
            uint32 {7}
            doc "Disable the shuffler"
                "Disable"
            enum
            {
                {1,  "Enable"},
                {0,  "Disable"}
            };

        PARAM "Dither Sequence control"
            uint32 {6:5}
            doc "Dither Sequence control"
                "No dither"
            enum
            {
                {0,  "No dither"},
                {1,  "prbs15"},
                {2,  "prbs23"},
                {3,  "prbs31"}
            };

        PARAM "ADC DC input selection"
            uint32 {4:0}
            doc "ADC DC input selection"
            enum
            {
                {0x0,  "ADC_INPUT_P17"},
                {0x1,  "ADC_INPUT_P16"},
                {0x2,  "ADC_INPUT_P15"},
                {0x3,  "ADC_INPUT_P14"},
                {0x4,  "ADC_INPUT_P13"},
                {0x5,  "ADC_INPUT_P12"},
                {0x6,  "ADC_INPUT_P11"},
                {0x7,  "ADC_INPUT_P10"},
                {0x8,  "ADC_INPUT_P9"},
                {0x9,  "ADC_INPUT_P8"},
                {0xA,  "ADC_INPUT_P1"},
                {0xB,  "ADC_INPUT_P0"},
                {0xC,  "ADC_INPUT_VDDIO"},
                {0xD,  "ADC_INPUT_VDD_CORE"},
                {0xE,  "ADC_INPUT_ADC_BGREF"},
                {0xF,  "ADC_INPUT_ADC_REFGND"},
                {0x10,  "ADC_INPUT_P38"},
                {0x11,  "ADC_INPUT_P37"},
                {0x12,  "ADC_INPUT_P36"},
                {0x13,  "ADC_INPUT_P35"},
                {0x14,  "ADC_INPUT_P34"},
                {0x15,  "ADC_INPUT_P33"},
                {0x16,  "ADC_INPUT_P32"},
                {0x17,  "ADC_INPUT_P31"},
                {0x18,  "ADC_INPUT_P30"},
                {0x19,  "ADC_INPUT_P29"},
                {0x1A,  "ADC_INPUT_P28"},
                {0x1B,  "ADC_INPUT_P23"},
                {0x1C,  "ADC_INPUT_P22"},
                {0x1D,  "ADC_INPUT_P21"},
                {0x1E,  "ADC_INPUT_P19"},
                {0x1F,  "ADC_INPUT_P18"}
            };

        PARAM "Reserved_6"
            uint32 {31:24}
            doc "Reserved (Pin)"
            binary_message_only
            encode_value = 0;

        PARAM "ADC latency count max."
            uint32 {23:16}
            doc "ADC latency count max., value = (divide ratio - 1), for example, 0xf = divide by 16"
                "Default = 0xf"
            default = 0xf;

        PARAM "Reserved_5"
            uint32 {15:14}
            doc "Reserved (Pin)"
            binary_message_only
            encode_value = 0;

        PARAM "ADC latency count software reset"
            uint32 {13}
            doc "ADC latency count software reset"
            enum
            {
                {0,  "No effect"},
                {1,  "Software reset latency_cnt to adc_latency_cnt_max"}
            };

        PARAM "ADC uses latency count"
            uint32 {12}
            doc "ADC uses latency count"
            enum
            {
                {0,  "latency_cnt has no effect"},
                {1,  "latency_cnt has effect"}
            };

        PARAM "ADC debug output select"
            uint32 {11:9}
            doc "ADC debug output select"
            enum
            {
                {0,  "adc_sample_o[23:20], adc_sample_o[13:10], adc_sample_o[19:14], adc_sample_o[9:8], adc_sample_tick"},
                {1,  "adc_sample_o[23:8], adc_sample_tick"},
                {2,  "adc_sample_o[15:0], adc_sample_tick"},
                {3,  "13'b0, rst_clk_adc_n, clk_adc_lv, ds2b"},
                {4,  "14'b0, DMACCLR, DMACBREQ, DMACLBREQ"},
                {5,  "12'b0, api_rclk_lv, api_fclk, api_bclk, api_serDatOut, adc_sample_ready"},
                {6,  "adc_fifo_sample[15:0], DMACCLR"},
                {7,  "adc_fifo_sample[31:16], DMACCLR"}
            };

        PARAM "Data alignment mode of ADC DMA interface and pattern generator"
            uint32 {8}
            doc "Data alignment mode of ADC DMA interface and pattern generator"
            enum
            {
                {0,  "MSB aligned"},
                {1,  "LSB aligned"}
            };

        PARAM "pattern generator init source select"
            uint32 {7}
            doc "pattern generator init source select"
            enum
            {
                {0,  "adc_pat_gen_init register"},
                {1,  "ADC DMA interface"}
            };

        PARAM "ADC API interface input select"
            uint32 {6}
            doc "ADC API interface input select"
            enum
            {
                {0,  "ADC filter output"},
                {1,  "pattern generator output"}
            };

        PARAM "ADC DMA interface input select"
            uint32 {5}
            doc "ADC DMA interface input select"
            enum
            {
                {0,  "ADC filter output"},
                {1,  "pattern generator output"}
            };

        PARAM "Pattern generator software init"
            uint32 {4}
            doc "Pattern generator software init, only has effect when adc_pat_gen_source == 0"
            default = 0;

        PARAM "Pattern generator clock enable"
            uint32 {3}
            doc "Pattern generator clock enable"
            enum
            {
                {0,  "Disable"},
                {1,  "Enable"}
            };

        PARAM "Pattern generator output mode"
            uint32 {2:0}
            doc "Pattern generator output mode"
            enum
            {
                {0,  "MODE_24B_W32B"},
                {1,  "MODE_24B_OFF3"},
                {2,  "MODE_24B_SAME"},
                {3,  "MODE_8B"},
                {4,  "MODE_16B_SAME"},
                {5,  "MODE_16B_OFF2"},
                {6,  "MODE_ZERO"},
                {7,  "MODE_FF"}
            };


        PARAM "Reserved_7"
            uint32 {31:3}
            doc "Reserved (Pin)"
            binary_message_only
            encode_value = 0;

        PARAM "Mode of operation of the CIC filter"
            uint32 {2:0}
            doc "Mode of operation of the CIC filter"
                "default FILTER_CTL0_REG_DF_MODE_96KHz"
            enum
            {
                {0,  "DF_MODE_12KHz"},
                {1,  "DF_MODE_24KHz"},
                {2,  "DF_MODE_16KHz"},
                {3,  "DF_MODE_48KHz"},
                {5,  "DF_MODE_96KHz"}
            };


        PARAM "High Pass Filter Denominator Co-efficient"
            uint32 {31:16}
            doc "High Pass Filter Denominator Co-efficient"
            default = 0x7fcf;

        PARAM "High Pass Filter Numerator Co-efficient"
            uint32 {15:0}
            doc "High Pass Filter Numerator Co-efficient"
            default = 0x7ffd;


        PARAM "Biquad 2 numerator  - 1 (LPF)"
            uint32 {31:16}
            doc "Biquad 2 numerator  - 1 (LPF)"
            default = 0xb109;

        PARAM "Biquad 1 numerator - 1 (LPF)"
            uint32 {15:0}
            doc "Biquad 1 numerator - 1 (LPF)"
            default = 0xa7fe;


        PARAM "Biquad 4 numerator - 1 (LPF)"
            uint32 {31:16}
            doc "Biquad 4 numerator - 1 (LPF)"
            default = 0x39bd;

        PARAM "Biquad 3 numerator - 1 (LPF)"
            uint32 {15:0}
            doc "Biquad 3 numerator - 1 (LPF)"
            default = 0xfdf1;


        PARAM "Biquad 2 numerator - 2 (LPF)"
            uint32 {31:16}
            doc "Biquad 2 numerator - 2 (LPF)"
            default = 0x3fa8;

        PARAM "Biquad 1 numerator - 2 (LPF)"
            uint32 {15:0}
            doc "Biquad 1 numerator - 2 (LPF)"
            default = 0x3ffd;


        PARAM "Biquad 4 numerator -2 (LPF)"
            uint32 {31:16}
            doc "Biquad 4 numerator -2 (LPF)"
            default = 0x0c62;

        PARAM "Biquad 3 numerator - 2 (LPF)"
            uint32 {15:0}
            doc "Biquad 3 numerator - 2 (LPF)"
            default = 0x2ada;


        PARAM "Biquad 2 denominator - 1 (LPF)"
            uint32 {31:16}
            doc "Biquad 2 denominator - 1 (LPF)"
            default = 0xa607;

        PARAM "Biquad 1 denominator - 1 (LPF)"
            uint32 {15:0}
            doc "Biquad 1 denominator - 1 (LPF)"
            default = 0xa656;


        PARAM "Biquad 4 denominator - 1 (LPF)"
            uint32 {31:16}
            doc "Biquad 4 denominator - 1 (LPF)"
            default = 0xa1cd;

        PARAM "Biquad 3 denominator - 1 (LPF)"
            uint32 {15:0}
            doc "Biquad 3 denominator - 1 (LPF)"
            default = 0xa44c;


        PARAM "Biquad 2 denominator - 2 (LPF)"
            uint32 {31:16}
            doc "Biquad 2 denominator - 2 (LPF)"
            default = 0x2ab5;

        PARAM "Biquad 1 denominator - 2 (LPF)"
            uint32 {15:0}
            doc "Biquad 1 denominator - 2 (LPF)"
            default = 0x20f0;


        PARAM "Biquad 4 denominator - 2 (LPF)"
            uint32 {31:16}
            doc "Biquad 4 denominator - 2 (LPF)"
            default = 0x3d43;

        PARAM "Biquad 3 denominator - 2 (LPF)"
            uint32 {15:0}
            doc "Biquad 3 denominator - 2 (LPF)"
            default = 0x35e7;


        PARAM "ADC output precision"
            uint32 {31:30}
            doc "ADC output precision"
                "default = 24 Bits"
            enum
            {
                {0,  "24 Bits"},
                {1,  "16 Bits"},
                {2,  "8 Bits"}
            };

        PARAM "Low pass filter rate"
            uint32 {29:28}
            doc "Low pass filter rate"
                "default = 64KHz"
            enum
            {
                {0,  "8KHz"},
                {1,  "16KHz"},
                {2,  "64KHz"},
                {3,  "128KHz"}
            };

        PARAM "Bypass mapper"
            uint32 {27}
            doc "Bypass mapper"
            enum
            {
                {0,  "No bypass"},
                {1,  "Bypass"}
            };

        PARAM "ADC output rate"
            uint32 {26:24}
            doc "ADC output rate, Used to vary sampling rate of the high pass filter"
            default = 0x4;

        PARAM "auxAdcMpr"
            uint32 {23}
            doc "auxAdcMpr"
            default = 0x0;

        PARAM "To select between dc measurement and audio"
            uint32 {22}
            doc "To select between dc measurement and audio"
            enum
            {
                {0,  "DC mode"},
                {1,  "Audio mode"}
            };

        PARAM "Flag to bypass high pass filter (if there is no DC)"
            uint32 {21}
            doc "Flag to bypass high pass filter (if there is no DC)"
            enum
            {
                {0,  "Not bypass filter"},
                {1,  "Bypass filter"}
            };

        PARAM "Output strobe rate that is used to decimate the output:  1 - 16KHz, 0 - 8KHz"
            uint32 {20}
            doc "Output strobe rate that is used to decimate the output:  1 - 16KHz, 0 - 8KHz"
                "default = 8KHz"
            enum
            {
                {0,  "8KHz"},
                {1,  "16KHz"}
            };

        PARAM "Gain corresponding to second-order-section (biquad) implementation"
            uint32 {19:0}
            doc "Gain corresponding to second-order-section (biquad) implementation"
            default = 0x764;


        PARAM "Spare_1"
            uint32 {31:16}
            doc "Spare register"
            binary_message_only
            encode_value = 0;

        PARAM "Reserved_8"
            uint32 {15:8}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "Mapper input corresponding to 11"
            uint32 {7:6}
            doc "Mapper input corresponding to 11"
            default = 0x1;

        PARAM "Mapper input corresponding to 10 - Same as Mapper input corresponding to 01"
            uint32 {5:4}
            doc "Mapper input corresponding to 10 - Same as Mapper input corresponding to 01"
            default = 0x0;

        PARAM "Mapper input corresponding to 01"
            uint32 {3:2}
            doc "Mapper input corresponding to 01"
            default = 0x0;

        PARAM "Mapper input corresponding to 00"
            uint32 {1:0}
            doc "Mapper input corresponding to 00"
            default = 0x3;


        PARAM "Reserved_9"
            uint32 {31:8}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "ADC API interface output data shift mode"
            uint32 {7:6}
            doc "ADC API interface output data shift mode"
                "default = SHIFT_MODE_24B_8B0"
            enum
            {
                {0,  "SHIFT_MODE_24B_8B0"},
                {1,  "SHIFT_MODE_24B_8B0"},
                {2,  "SHIFT_MODE_8B0_24B"},
                {3,  "SHIFT_MODE_4B0_24B_4B0"}
            };

        PARAM "ADC API interface output alignment mode"
            uint32 {5}
            doc "ADC API interface output alignment mode"
            enum
            {
                {0,  "API interface outputs data as MSB aligned"},
                {1,  "API interface outputs data as LSB aligned"}
            };

        PARAM "ADC API interface input alignment mode"
            uint32 {4}
            doc "ADC API interface input alignment mode"
            enum
            {
                {0,  "API interface treats input data as MSB aligned"},
                {1,  "API interface treats input data as LSB aligned"}
            };

        PARAM "API data mode"
            uint32 {3:2}
            doc "API data mode"
            enum
            {
                {0,  "MODE_16BIT"},
                {1,  "MODE_8BIT"},
                {2,  "MODE_24BIT"},
                {3,  "MODE_16BIT"}
            };

        PARAM "Reserved_10"
            uint32 {1}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "API enable"
            uint32 {0}
            doc "API enable"
            enum
            {
                {0,  "Disable"},
                {1,  "Enable"}
            };


        PARAM "Reserved_13"
            uint32 {31:26}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "apiBclkClrByDen"
            uint32 {25}
            doc "apiBclkClrByDen"
            default = 0x0;

        PARAM "apiBclkSetByDen"
            uint32 {24}
            doc "apiBclkSetByDen"
            default = 0x0;

        PARAM "apiBclkClrByInit"
            uint32 {23}
            doc "apiBclkClrByInit"
            default = 0x0;

        PARAM "apiBclkSetByInit"
            uint32 {22}
            doc "apiBclkSetByInit"
            default = 0x0;

        PARAM "apiBclkTogF"
            uint32 {21:16}
            doc "apiBclkTogF"
            default = 0x7;

        PARAM "Reserved_12"
            uint32 {15:14}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "apiBclkH2l"
            uint32 {13:8}
            doc "apiBclkH2l"
            default = 0x3;

        PARAM "Reserved_11"
            uint32 {7:6}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "apiBclkLl2h"
            uint32 {5:0}
            doc "apiBclkLl2h"
            default = 0x7;


        PARAM "Reserved_14"
            uint32 {31:28}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "Set API frame clock output high to low"
            uint32 {27:22}
            doc "bclk_cnt value to set API frame clock output high to low, only has effect when api_fclk_h2l_bclk_on = 1"
            default = 0x0;

        PARAM "set API frame clock output low to high"
            uint32 {21:16}
            doc "bclk_cnt value to set API frame clock output low to high, only has effect when api_fclk_l2h_bclk_on = 1"
            default = 0x0;

        PARAM "API frame clock output high to low ignores bclk_cnt or not"
            uint32 {15}
            doc "API frame clock output high to low ignores bclk_cnt or not"
            enum
            {
                {0,  "Ignores bclk_cnt"},
                {1,  "Checks bclk_cnt"}
            };

        PARAM "API frame clock output low to high ignores bclk_cnt or not"
            uint32 {14}
            doc "API frame clock output low to high ignores bclk_cnt or not"
            enum
            {
                {0,  "Ignores bclk_cnt"},
                {1,  "Checks bclk_cnt"}
            };

        PARAM "fclk_cnt value to set API frame clock output high to low"
            uint32 {13:9}
            doc "fclk_cnt value to set API frame clock output high to low"
            default = 0x0;

        PARAM "fclk_cnt value to set API frame clock output low to high"
            uint32 {8:4}
            doc "fclk_cnt value to set API frame clock output low to high"
            default = 0x1e;

        PARAM "apiFclkClrByDen"
            uint32 {3}
            doc "apiFclkClrByDen"
            enum
            {
                {0,  "No effect"},
                {1,  "API frame clock output reset to 0 by every input data sample"}
            };

        PARAM "apiFclkSetByDen"
            uint32 {2}
            doc "apiFclkSetByDen"
            enum
            {
                {0,  "No effect"},
                {1,  "API frame clock output set to 1 by every input data sample"}
            };

        PARAM "apiFclkClrByInit"
            uint32 {1}
            doc "apiFclkClrByInit"
            enum
            {
                {0,  "No effect"},
                {1,  "API frame clock output reset to 0 at init (enable from low to high)"}
            };

        PARAM "apiFclkSetByInit"
            uint32 {0}
            doc "apiFclkSetByInit"
            enum
            {
                {0,  "No effect"},
                {1,  "API frame clock output set to 1 at init (enable from low to high)"}
            };


        PARAM "Reserved_15"
            uint32 {31:13}
            doc "Reserved"
            binary_message_only
            encode_value = 0;

        PARAM "fclk_cnt reset value, this offset can be used to shift output data position"
            uint32 {12:8}
            doc "fclk_cnt reset value, this offset can be used to shift output data position"
            default = 0x1f;

        PARAM "apiFclkCntMaxEn"
            uint32 {7}
            doc "apiFclkCntMaxEn"
            enum
            {
                {0,  "fclk_cnt[4:0] increments until wrap around"},
                {1,  "fclk_cnt[4:0] wrap around at api_fclk_cnt_max"}
            };

        PARAM "fclk_cnt wrap around value, only effective when api_fclk_cnt_max_en == 1"
            uint32 {6:2}
            doc "fclk_cnt wrap around value, only effective when api_fclk_cnt_max_en == 1"
            default = 0x1f;

        PARAM "apiRclkAlwaysOn"
            uint32 {1}
            doc "apiRclkAlwaysOn"
            enum
            {
                {0,  "API reference clock output is gated when api_enable == 0"},
                {1,  "API reference clock output is not gated when api_enable == 0"}
            };

        PARAM "API reference clock output inversion"
            uint32 {0}
            doc "API reference clock output inversion"
            enum
            {
                {0,  "No invert"},
                {1,  "Invert"}
            };


        PARAM "ADC power on delay"
            uint8
            doc "ADC power on delay in us"
                "Default 20"
            max = 255
            default = 20;


        PARAM "bandgap reference channel"
            uint8
            doc "bandgap reference channel"
                "Default 14"
            max = 31
            default = 14;


        PARAM "Calibration Reading Ave Count"
            uint8
            doc "Auto calibration reading average count."
                "Default 8"
            max = 255
            default = 8;

        PARAM "Input Range"
            uint8
            doc "ADC input range select. Default is 0-1.2v"

            enum
            {
                {0, "0V-3.6V"},
                {1, "0V-1.8V"}
            }
            default = 0;

        PARAM "Reference MicroVoltage"
            uint32
            doc "ADC calibration reference voltage in mV"
                "Default 500mV"
            default = 500;

        PARAM "ADCBandgapDelta[0]"
            int16
            doc "Offset to VSS to be applied to get bandgap for 0-1.2V range"
            default = 0;

        PARAM "ADCBandgapDelta[1]"
            int16
            doc "Offset to VSS to be applied to get bandgap for 0-2.4V range"
            default = 0;

         PARAM "ADCBandgapDelta[2]"
            int16
            doc "Offset to VSS to be applied to get bandgap for 0-3.6V range"
            default = 0;

        PARAM "ADC api enable"
            uint8
            doc "AADC api enable"
            enum
            {
                {0, "Disable ADC API"},
                {1, "Enable ADC API"}
            }
            default = 0;

        PARAM "ADC audio fifo number"
            uint8
            doc "ADC audio fifo number"
                "Default 5"
            max = 255
            default = 5;

        PARAM "ADC audio fifo size"
            uint32
            doc "ADC audio fifo size"
                "Default 240"
            default = 240;
    }


##    COMMAND "Adc Driver Configuration" 0xA6
##    {
##        doc "Configure ADC driver"
##
##        PARAM "Reserved_1"
##            uint32 {31:15}
##            doc "Reserved"
##            binary_message_only
##            encode_value = 0;
##
##        PARAM "RC Calibration for ADC"
##            uint32 {14:10}
##            doc "RC Calibration for ADC"
##            min = 0
##            max = 31
##            default = 0x6;
##
##        PARAM "Bandgap Temperature Constant"
##            uint32 {9:8}
##            doc "Bandgap temperature constant."
##            default = 0x0;
##
##        PARAM "Bandgap Output Current Trim"
##            uint32 {7:4}
##            doc "trim the bandgap output current form 9~53uA"
##            enum
##            {
##                {0,   "Gives min current of ~9uA"},
##                {0x6, "Gives min current of ~26uA"},
##                {0xf, "gimvs min current of ~53uA"}
##            };
##
##        PARAM "Bandgap Noise Fiter Constant"
##            uint32 {3:2}
##            doc "Bandgap noise filter time constant."
##            enum
##            {
##                {0,   "high"},
##                {0x3, "low"}
##            };
##
##        PARAM "Dither Power Down"
##            uint32 {1}
##            doc "Dither power down"
##            enum
##            {
##                {1,   "Dither OFF"},
##                {0,  "Ditehr ON"}
##            };
##
##        PARAM "Reserved_1"
##            uint32 {0}
##            doc "Reserved"
##            binary_message_only
##            encode_value = 0;
##
##
##        PARAM "Reserved_2"
##            uint32 {31:15}
##            doc "Reserved (Pin)"
##            binary_message_only
##            encode_value = 0;
##
##        PARAM "IDAC Trimming 2nd OPAMP"
##            uint32 {14:11}
##            doc "IDAC trimming code for the 2nd OPAMP"
##                "default 0x6"
##            default = 0x6;
##
##        PARAM "IDAC Trimming 1st OPAMP"
##            uint32 {10:7}
##            doc "IDAC trimming code for the 1st OPAMP"
##                "default 0x6"
##            default = 0x6;
##
##        PARAM "Comparator Reference Voltage"
##            uint32 {6:3}
##            doc "Reference voltage selector for the comparator."
##                "Default 650mV."
##            enum
##            {
##                {0x0,  "550mV"},
##                {0x1,  "600mV"},
##                {0x3,  "650mV"},
##                {0x7,  "700mV"},
##                {0xf,  "750mV"}
##            };
##
##        PARAM "OPAMP Reference Voltage"
##            uint32 {2:0}
##            doc "Reference voltage selector for the OPAMP"
##                "default = 500mv"
##            enum
##            {
##                {0x0,  "400mV"},
##                {0x1,  "450mV"},
##                {0x3,  "500mV"},
##                {0x7,  "550mV"}
##            };
##
##
##        PARAM "Reserved_3"
##            uint32 {31:8}
##            doc "Reserved (Pin)"
##            binary_message_only
##            encode_value = 0;
##
##
##        PARAM "OPAMP Power Down"
##            uint32 {7}
##            doc "ADC OPAMP power down contrl"
##            enum
##            {
##                {1,  "Power OFF"},
##                {0,  "Power ON"}
##            };
##
##
##        PARAM "Sampling Clock Polarity"
##            uint32 {6}
##            doc "Sampleing clock output from ADC polarity control."
##                "Default Negative Edgie of 24MHz"
##            enum
##            {
##                {1,  "Negative Edge"},
##                {0,  "Positive Edge"}
##            };
##
##        PARAM "Dither Clock Polarity"
##            uint32 {5}
##            doc "Dither input to ADC clock polarity control."
##                "Default Positive Edge"
##            enum
##            {
##                {1,  "Negative Edge"},
##                {0,  "Positive Edge"}
##            };
##
##        PARAM "Comparator Bias Current Control"
##            uint32 {4}
##            doc "Bias current control for comparator."
##                "Current is generated by V/R (not by a current source),"
##                "if R varies, then this bit can be used to increase the bias current."
##            enum
##            {
##                {1,  "5.6uA"},
##                {0,  "4.3uA"}
##            };
##
##
##        PARAM "RESERVED"
##            uint32 {3:0}
##            doc "Reserved (Pin)"
##            binary_message_only
##            encode_value = 0;
##
##        PARAM "ADC Power Up Delay"
##            uint8
##            doc "Power Up delay for ADC block in uS."
##                "Default 20 us"
##            default = 20;
##
##        PARAM "Calibration Reference Channel"
##            uint8
##            doc "Calibration reference channel."
##
##               enum
##               {
##               {0, "ADC_INPUT_VSS"},
##               {1, "ADC_INPUT_P38"},
##               {2, "ADC_INPUT_P37"},
##               {3, "ADC_INPUT_P36"},
##
##               {4, "ADC_INPUT_P35"},
##               {5, "ADC_INPUT_P34"},
##               {6, "ADC_INPUT_P33"},
##               {7, "ADC_INPUT_P32"},
##
##               {8,  "ADC_INPUT_P31"},
##               {9,  "ADC_INPUT_P30"},
##               {10, "ADC_INPUT_P29"},
##               {11, "ADC_INPUT_P28"},
##
##               {12, "ADC_INPUT_P23"},
##               {13, "ADC_INPUT_P22"},
##               {14, "ADC_INPUT_P21"},
##               {15, "ADC_INPUT_BG_REFERENCE"},
##
##               {16, "ADC_INPUT_NOTUSE"},
##               {17, "ADC_INPUT_P18"},
##               {18, "ADC_INPUT_P17"},
##               {19, "ADC_INPUT_P16"},
##
##               {20, "ADC_INPUT_P15"},
##               {21, "ADC_INPUT_P14"},
##               {22, "ADC_INPUT_P13"},
##               {23, "ADC_INPUT_P12"},
##
##               {24, "ADC_INPUT_P11"},
##               {25, "ADC_INPUT_P10"},
##               {26, "ADC_INPUT_P9"},
##               {27, "ADC_INPUT_P8"},
##
##               {28, "ADC_INPUT_P1"},
##               {29, "ADC_INPUT_P0"},
##               {30, "ADC_INPUT_VDD_CORE"},
##               {31, "ADC_INPUT_VDDIO"}
##               }
##            default = 16;
##
##
##        PARAM "Calibration Reading Ave Count"
##            uint8
##            doc "Auto calibration reading average count."
##                "Default 8"
##            max = 255
##            default = 8;
##
##        PARAM "Input Range"
##            uint8
##            doc "ADC input range select. Default is 0-1.2v"
##
##               enum
##               {
##               {0, "0V-1.2V"},
##               {1, "0V-2.4V"},
##               {2, "0V-3.6V"}
##               }
##            default = 0;
##
##        PARAM "Reference MicroVoltage"
##            uint32
##            doc "ADC calibration reference voltage in mV"
##                "Default 500mV"
##            default = 500;
##
##        PARAM "ADCBandgapDelta[0]"
##            int16
##            doc "Offset to VSS to be applied to get bandgap for 0-1.2V range"
##            default = 0;
##
##        PARAM "ADCBandgapDelta[1]"
##            int16
##            doc "Offset to VSS to be applied to get bandgap for 0-2.4V range"
##            default = 0;
##
##         PARAM "ADCBandgapDelta[2]"
##            int16
##            doc "Offset to VSS to be applied to get bandgap for 0-3.6V range"
##            default = 0;
##    }


    # COMMAND "BD_ADDR" 0x40        - Fixed header only

    COMMAND "Local Name" 0x41
    {
        doc "Sets the local name of the device."
        PARAM "Name"
            utf8[248] omit_pad_bytes
            doc "The local name for this device.";
    }

    COMMAND "Device Descriptor" 0x42
    {
        doc "($$$ COPY FROM 105_49)"
        PARAM "Length"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 0x12;
        PARAM "Descriptor type"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 0x01;                                            # device descriptor
        PARAM "USB spec version"
            uint16
            doc "($$$ COPY FROM 105_49)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Device class"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Device subclass"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Device protocol"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Max packet size"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Vendor ID"
            uint16
            doc "($$$ COPY FROM 105_49)";
        PARAM "Product ID"
            uint16
            doc "($$$ COPY FROM 105_49)";
        PARAM "Device release number"
            uint16
            doc "($$$ COPY FROM 105_49)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Manufacturer string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Product string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Serial number string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Number of configurations"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 1;
    }

    COMMAND "Configuration Descriptor" 0x43
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Descriptor"
            uint8[255] omit_pad_bytes
            doc "($$$ NEEDS EXPLANATION)";
    }


    COMMAND "Keyboard Device Descriptor" 0x44
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Length"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 0x12;
        PARAM "Descriptor type"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 0x01;                                            # device descriptor
        PARAM "USB spec version"
            uint16
            doc "($$$ NEEDS EXPLANATION)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Device class"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Device subclass"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Device protocol"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Max packet size"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Vendor ID"
            uint16
            doc "($$$ COPY FROM 105_49)";
        PARAM "Product ID"
            uint16
            doc "($$$ COPY FROM 105_49)";
        PARAM "Device release number"
            uint16
            doc "($$$ COPY FROM 105_49)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Manufacturer string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Product string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Serial number string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Number of configurations"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 1;
    }


    COMMAND "Keyboard Configuration Descriptor" 0x45
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Descriptor"
            uint8[64] omit_pad_bytes
            doc "($$$ NEEDS EXPLANATION)";
    }


    COMMAND "USB WHQL Workaround" 0x46
    {
        doc "Enable USB WHQL workaround for UHE mode to show all ports"
            "(Bluetooth, mouse, keyboard) at the same time, and not remove the"
            "Bluetooth port after a USB bus reset."
        PARAM "Enable"
            bool8
            doc "Enables WHQL workaround if true.";
    }


    COMMAND "Mouse Device Descriptor" 0x47
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Length"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 0x12;
        PARAM "Descriptor type"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 0x01;                                            # device descriptor
        PARAM "USB spec version"
            uint16
            doc "($$$ NEEDS EXPLANATION)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Device class"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Device subclass"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Device protocol"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Max packet size"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Vendor ID"
            uint16
            doc "($$$ COPY FROM 105_49)";
        PARAM "Product ID"
            uint16
            doc "($$$ COPY FROM 105_49)";
        PARAM "Device release number"
            uint16
            doc "($$$ COPY FROM 105_49)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Manufacturer string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Product string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Serial number string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Number of configurations"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 1;
    }


    COMMAND "Mouse Configuration Descriptor" 0x48
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Descriptor"
            uint8[64] omit_pad_bytes
            doc "($$$ NEEDS EXPLANATION)";
    }


    # COMMAND "RF_PLL Trim" 0x49                                        - Fixed header only

    COMMAND "Language ID String Descriptor" 0x4A
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Language ID length"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 4;
        PARAM "Language ID descriptor type"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 3;                               # string descriptor
        PARAM "Language ID"
            uint16
            doc "($$$ NEEDS EXPLANATION)"
            default = 0x0409;
    }


    COMMAND "Manufacturer ID String Descriptor" 0x4B
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Manufacturer ID length"                      # in bytes
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = (2 + ByteArrayValidLength("Manufacturer ID Unicode-16"));
        PARAM "Manufacturer ID descriptor type"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 3;                               # string descriptor
        PARAM "Manufacturer ID Unicode-16"
            uint8[40] omit_pad_bytes                        # typically, use the UNICODE construct
            doc "($$$ NEEDS EXPLANATION)"
            valid_length = ("Manufacturer ID length" - 2)   # in bytes
            min = 0;
    }


    COMMAND "Product ID String Descriptor" 0x4C
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Product ID length"                           # in bytes
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = (2 + ByteArrayValidLength("Product ID Unicode-16"));
        PARAM "Product ID descriptor type"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 3;                               # string descriptor
        PARAM "Product ID Unicode-16"
            uint8[100] omit_pad_bytes                       # typically, use the UNICODE construct
            doc "($$$ NEEDS EXPLANATION)"
            valid_length = ("Product ID length" - 2)        # in bytes
            min = 0;
    }


    COMMAND "USB Port Control" 0x4D
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Enabled ports"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            bitmap
            {
                {0x01, "Port 1"},
                {0x02, "Port 2"},
                {0x04, "Port 3"},
                {0x08, "Port 4"},
                {0x80, "Hub"}
            };
    }


    COMMAND "Hub Device Descriptor" 0x4E
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Length"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 0x12;
        PARAM "Descriptor type"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 0x01;                                            # device descriptor
        PARAM "USB spec version"
            uint16
            doc "($$$ NEEDS EXPLANATION)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Device class"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Device subclass"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Device protocol"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Max packet size"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Vendor ID"
            uint16
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Product ID"
            uint16
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Device release number"
            uint16
            doc "($$$ NEEDS EXPLANATION)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Manufacturer string index"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Product string index"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Serial number string index"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Number of configurations"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 1;
    }


    COMMAND "Hub Configuration Descriptor" 0x4F
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Descriptor"
            uint8[0x19]
            doc "($$$ NEEDS EXPLANATION)";
    }


    COMMAND "Hub Descriptor" 0x50
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Descriptor"
            uint8[0x09]
            doc "($$$ NEEDS EXPLANATION)";
    }


    COMMAND "Keyboard Product ID String Descriptor" 0x51
    {
        doc "This item configures the keyboard device's product id string descriptor"
        PARAM "Product ID length"                           # in bytes
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = (2 + ByteArrayValidLength("Product ID Unicode-16"));
        PARAM "Product ID descriptor type"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 3;                               # string descriptor
        PARAM "Product ID Unicode-16"
            uint8[100] omit_pad_bytes                       # typically, use the UNICODE construct
            doc "($$$ NEEDS EXPLANATION)"
            valid_length = ("Product ID length" - 2)        # in bytes
            min = 0;
    }


    COMMAND "Mouse Product ID String Descriptor" 0x52
    {
        doc "This item configures the mouse device's product id string descriptor"
        PARAM "Product ID length"                           # in bytes
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = (2 + ByteArrayValidLength("Product ID Unicode-16"));
        PARAM "Product ID descriptor type"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 3;                               # string descriptor
        PARAM "Product ID Unicode-16"
            uint8[100] omit_pad_bytes                       # typically, use the UNICODE construct
            doc "($$$ NEEDS EXPLANATION)"
            valid_length = ("Product ID length" - 2)        # in bytes
            min = 0;
    }

    COMMAND "DFU Device Descriptor" 0x53
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Length"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 0x12;
        PARAM "Descriptor type"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 0x01;                                            # device descriptor
        PARAM "USB spec version"
            uint16
            doc "($$$ NEEDS EXPLANATION)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Device class"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Device subclass"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Device protocol"
            uint8
            doc "($$$ NEEDS EXPLANATION)";
        PARAM "Max packet size"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Vendor ID"
            uint16
            doc "($$$ COPY FROM 105_49)";
        PARAM "Product ID"
            uint16
            doc "($$$ COPY FROM 105_49)";
        PARAM "Device release number"
            uint16
            doc "($$$ COPY FROM 105_49)"
            note "BCD, version 1.10 = 0x0110";
        PARAM "Manufacturer string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Product string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Serial number string index"
            uint8
            doc "($$$ COPY FROM 105_49)";
        PARAM "Number of configurations"
            uint8
            doc "($$$ COPY FROM 105_49)"
            binary_message_only
            encode_value = 1;
    }

    COMMAND "DFU Configuration Descriptor" 0x54
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Descriptor"
            uint8[0x19]
            doc "($$$ NEEDS EXPLANATION)";
    }


    COMMAND "DFU Manufacturer ID String Descriptor" 0x55
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Manufacturer ID length"                                      # in bytes
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = (2 + ByteArrayValidLength("Manufacturer ID Unicode-16"));
        PARAM "Manufacturer ID descriptor type"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 3;                                               # string descriptor
        PARAM "Manufacturer ID Unicode-16"
            uint8[0x1A] omit_pad_bytes                        # typically, use the UNICODE construct
            doc "($$$ NEEDS EXPLANATION)"
            valid_length = ("Manufacturer ID length" - 4)                   # in bytes
                min = 0;
    }


    COMMAND "DFU Product ID String Descriptor" 0x56
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Product ID length"                                           # in bytes
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = (2 + ByteArrayValidLength("Product ID Unicode-16"));
        PARAM "Product ID descriptor type"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = 3;                                               # string descriptor
        PARAM "Product ID Unicode-16"
            uint8[0x44] omit_pad_bytes                        # typically, use the UNICODE construct
            doc "($$$ NEEDS EXPLANATION)"
            valid_length = ("Product ID length" - 4)                        # in bytes
                min = 0;
    }


    COMMAND "UART Configuration" 0x57
    {
        doc "Configures the baud rate, mode, and thresholds for the UART transport"
        PARAM "Transport UART baud rate"
            uint32
            doc "The baud rate used for the transport UART";
        PARAM "Debug UART baud rate"
            uint32
            doc "The baud rate used for the debug UART";
        PARAM "Flow control water mark"
            uint16
            doc "The number of bytes being unread in the UART receive FIFO, below which the peer"
                "will receive a flow on indication and above which the peer will receive a flow off"
                "indication."
            max = 480
            default = 345;
        PARAM "Transmit DMA threshold"
            uint16
            doc "The number of bytes in a packet being transmitted, above which DMA will be used"
                "and below which the data will be read directly from the FIFO by firmware."
            max = 480
            default = 60;
        PARAM "Receive DMA threshold"
            uint16
            doc "The number of bytes in a packet being recevied, above which DMA will be used"
                "and below which the data will be written directly to the FIFO by firmware."
            max = 480
            default = 5;
        PARAM "SLIP mode"
            uint8
            doc "Enables slip mode operation"
            enum
            {
                {0x00, "Disable"},
                {0x01, "Enable for SLIP interoperability with FTE"},
                {0x81, "Enable with RFC 1071 compliance"}
            };
    }


    COMMAND "Bluetooth 2.0+ Features" 0x58
    {
        doc "Enables or disables Bluetooth 2.0 or newer fetures"
        PARAM "Enable"
            uint8
            doc "Bitmap indicating which Bluetooth 2.0 or newer features to enable. By default"
                "(without the configuration item) Bluetooth 2.0 is enabled."
            bitmap
            {
                {0x01, "Bluetooth 2.0"},
                {0x02, "Bluetooth 3.0"},
                {0x04, "Lisbon features - Bluetooth 2.1"},
                {0x08, "Enhanced Power Control"},
                {0x10, "Bluetooth 4.0"},
                {0x20, "Bluetooth 4.1"}
            };
    }


    COMMAND "LPO Test Mode" 0x59
    {
        doc "Enables USB LPO test mode 0."
        PARAM "Enable"
            bool8
            doc "Boolean parameter to enable or disable USB LPO test mode 0.  Since USB LPO test"
                "mode 0 is disabled by default, this parameter need only ever be set to true";
    }


    COMMAND "AFH Channel Classification Internal Configuration" 0x5A
    {
		doc	"AFH configuration BRCM Internal Usage only"

        PARAM "bypassScan"
            uint16{15}
            doc  "Whether to run active RSSI scan "
            enum
            {
                {0x0, "Run "},
                {0x1, "Bypass active RSSI scan "}
            }
            default = 0x0;

        PARAM "filterRxRssi"
                uint16{14}
                doc  "Enable filter passive RSSI values"
                enum
                {
                    {0x0, "No filtering"},
                    {0x1, "Filtering"}
                }
                default = 0x0;

        PARAM "enAbsReclaimTh"
			uint16{13}
			doc	"Enable absolute reclaim RSSI threshold"
			enum
			{
				{0x0, "Relative RSSI thresholding for reclaim"},
				{0x1, "Absolute RSSI thresholding for reclaim"}
			}
                        default = 0x0;
		PARAM "avoidLeAdChs"
			uint16{12}
			doc	"When set, fw will avoid the BLE adv channels"
			enum
			{
				{0x0, "Don't"},
				{0x1, "Do"}
			}
            default = 0x1;
		PARAM "enforceRules"
			uint16{11}
			doc	"Enforce association rules"
			enum
			{
				{0x0, "Do not enforce association rules"},
				{0x1, "Enforce association rules"}
			}
            default = 0x1;
		PARAM "bypassCC"
			uint16{10}
			doc	"bypassCC"
			enum
			{
				{0x0, "Run channel classification"},
				{0x1, "Bypass channel classification"}
			}
            default = 0x0;
		PARAM "considerSlaveMap"
			uint16{9}
			doc	"slave map"
			enum
			{
				{0x0, "Ignore slave maps"},
				{0x1, "Take slave maps into consideration"}
			}
            default = 0x1;
		PARAM "scan_coex"
			uint16{8}
			doc	"coex"
			enum
			{
				{0x0, "Ignore coex settings"},
				{0x1, "Take coex maps into consideration"}
			}
            default = 0x1;
		PARAM "hdrFecTuple"
			uint16{7:3}
			doc	"Number of FEC tuple errors before classifying to bad packets for statistics only"
            default = 0x0;
		PARAM "site_survey"
			uint16{2}
			doc	"FEC"
			enum
			{
				{0x0, "Normal operation (scan with links)"},
				{0x1, "Scan without links"}
			}
            default = 0x0;
		PARAM "afhcc_log"
			uint16{1:0}
			doc	"Logging"
			enum
			{
				{0x0, "No log"},
				{0x1, "RSSI log"},
				{0x2, "CC log"},
				{0x3, "RSSI and CC log"}
			}
            default = 0x0;
		PARAM "PLL_Settling_Time"
			uint8
			doc	"Settling time in us for most channels"
			note "us"
			min = 50
            default = 120;
		PARAM "Extra_Settling_Time"
			uint8
			doc	"Settling time in us for the first swithced-in channels"
			note "us"
            default = 30;

		PARAM "afhccAsscRuleEn"
			uint32
			doc "Enable bit for assocation rules"
            default = 0x003fffff;

		PARAM "PER_Shift"
			uint8
			doc"Shift factor for channel PER filter [1-6]"
            default = 5;
		PARAM "minPackets"
			uint8
			doc "Min. packets before enable PER based condemnation"
            default = 3;
		PARAM "lazyResetTh"
			uint8
			doc "Threshold for lazy reset"
            default = 0x1f;
		PARAM "bci_modem_clk"
			uint8
			doc "Modem Clock (MHz)"
            default = 12;

		PARAM "bci_swp_duration"
			uint16
			doc "Sweep duration (us)"
            default = 450;
		PARAM "bci_pause_1"
			uint8
			doc "Pause_1 (us)"
            default = 80;
		PARAM "bci_pause_2"
			uint8
			doc "Pause_2 (us)"
            default = 80;

		PARAM "rxSensitivity"
			int8
			doc "RX sensitivity from the eye of AFH"
            default = -82;
		PARAM "rxMaxGain"
			uint8
			doc "RX chain gains (dB)"
            default = 56;
		PARAM "rxrssi_th"
			int8
			doc "Threshold for good/weak signal level (dBm)"
            default = -70;
		PARAM "condemnCnt"
			uint8
			doc "Number of RSSI scans release condemning a channel"
            default = 10;

		PARAM "condemnSnrGoodSig"
			int8
			doc "SNR margin for condemning under good signal level"
            default = 5;
		PARAM "condemnSnrWeakSig"
			int8
			doc "SNR margin for condemning under weak signal level"
            default = 0;
		PARAM "regroupTh"
			uint16
			doc "Number of CC runs before reclaim all channel for defragmentation purpose"
            default = 0xFFFF;

		PARAM "syncToTh"
			uint8
			doc "Sync TO margin for condemning under strong signal level"
            default = 7;
        PARAM "swp_th_high"
            int8
            doc "High threshold of sweep (dBm)"
            default = -29;
        PARAM "calDelay"
            uint8
            doc "Delay for RF calibration (us)"
            default = 50;
        PARAM "bciChOffset"
            uint8
            doc "Channel offset number"
            default = 0;

		PARAM "absCondemnTh"
			int8
			doc "Absolute RSSI threshold for future-proof ETSI regulation"
            default = 127;
        PARAM "absReclaimTh"
            int8
            doc "Absolute RSSI threshold for reclaim"
            default = -88;
        PARAM "bleRssiTh"
            int16
            doc "BLE RSSI threshold for condemnation"
            default = -58;
	}

    COMMAND "ACL Pool Configuration" 0x5B
    {
        doc "Configures the buffer size and count of the ACL buffers"
        PARAM "Host claim ACL down payload size"
            uint16
            doc "The ACL buffer size (payload only) claimed to the host in response to"
                "Read_Buffer_Size. The default value is 1021.";
        PARAM "ACL down buffer size"
            uint16
            doc "The actual size of ACL down buffers (host to device direction), including header."
                "The default value is 1104.";
        PARAM "ACL up buffer size"
            uint16
            doc "The actual size of ACL up buffers (device to host direction), including header and"
                "internal transport prefix structures. The default value is 1060.";
        PARAM "Host claim ACL down payload count"
            uint8
            doc "The ACL buffer count claimed to the host in response to Read_Buffer_Size. The"
                "default value is 8.";
        PARAM "ACL down buffer count"
            uint8
            doc "The actual number of ACL down buffers (host to device direction). The default"
                "value is 7.";
        PARAM "Preserve UHE memory area"
            bool in uint8{7}
            doc "If UHE is not in use, this configuration item should be included with this flag"
                "cleared, in which case the memory used by the ROM UHE code will be recycled for"
                "the memory buffer pools. The default value is 1, which preserves the UHE memory.";
        PARAM "ACL up buffer count"
            uint8{6:0}
            doc "The actual number of ACL up buffers (device to host direction). The default value"
                "is 3.";
    }


    COMMAND "HCI Transport Type" 0x5C
    {
        doc "This item specifies the HCI transport type. If not present the device will do"
            "transport sensing"
        PARAM "Transport Type"
            uint8
            doc "Transport type"
            enum
            {
                {0x00, "Enable UART"},
                {0x01, "Enable USB transport"},
                {0x02, "Enable SPI transport"},
                {0x03, "Enable SLIM BUS transport"},
                {0x04, "Enable SDIO transport"},
                {0x05, "Enable I2C transport"},
                {0x06, "Enable SPIFFY transport"},
                {0x07, "Enable SPIFFY2 transport"},
                {0x08, "Undefined transport. Do transport sensing"}
            };
    }


    COMMAND "Link Quality Thresholds" 0x5D
    {
        doc "The thresholds used to switch between packet types"
        PARAM "Min number of packets for LQ calculation"
            uint8
            doc "If there are less than this number of packets in the stats"
                "buffer then the BER will be 255";
        PARAM "3-DH5 to 2-DH5 LQ threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
        PARAM "2-DH5 to 3-DH5 LQ threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
        PARAM "2-DH5 to 3-DH5_RSSI"
	    int8
            doc "The Raw RSSI must be at or above this threshold to switch to 3-DH5 from 2-DH5";
        PARAM "2-DH5 to 2-DH3 LQ threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
        PARAM "2-DH3 to 2-DH5 LQ threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
        PARAM "DH5 to DM5 threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
        PARAM "DM5 to DH5 threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
        PARAM "DM5 to DM3 threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
        PARAM "DM3 to DM5 threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
        PARAM "DM3 to DM1 threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
        PARAM "DM1 to DM3 threshold"
            uint8
            doc "The threshold to switch between these 2 packet types, range is 255 to 0, 255 is"
                "best quality";
    }


    COMMAND "RF Attenuation Table" 0x5E
    {
        doc "This config item is used only for Class 2 devices."
            "For Class 1.5 devices, use the Tx Power Table command, 0x1A"
            "This command sets the attenuation and register values for each power step."
        PARAM "Power table length"
            uint8
            doc "The number of entries in the power control table, range is 2 to 8"
            min = 0x2
            max = 0x8;
        PARAM "Testmode Power table length"
            uint8
            doc "The number of entries in the Testmode power control table, range is 2 to 8"
            min = 0x2
            max = 0x8;
        PARAM "Estimated attenuation[0]"
            uint8
            doc "The attenuation value to report for the corresponding register value, in 4 dB per"
                "step. Estimated attenuation[n] and Register value[n] are interleaved and repeated"
                "for Power table length entries.";
        PARAM "Register value[0]"
            uint8
            doc "The register value to use for this step, increasing by 2 for each 4 dB step."
                "Estimated attenuation[n] and Register value[n] are interleaved and repeated"
                "for Power table length entries.";
        PARAM "Estimated attenuation[1]"
            uint8;
        PARAM "Register value[1]"
            uint8;
        PARAM "Estimated attenuation[2]"
            uint8;
        PARAM "Register value[2]"
            uint8;
        PARAM "Estimated attenuation[3]"
            uint8;
        PARAM "Register value[3]"
            uint8;
        PARAM "Estimated attenuation[4]"
            uint8;
        PARAM "Register value[4]"
            uint8;
        PARAM "Estimated attenuation[5]"
            uint8;
        PARAM "Register value[5]"
            uint8;
        PARAM "Estimated attenuation[6]"
            uint8;
        PARAM "Register value[6]"
            uint8;
        PARAM "Estimated attenuation[7]"
            uint8;
        PARAM "Register value[7]"
            uint8;
        PARAM "Testmode Estimated attenuation[0]"
            uint8
            doc "The attenuation value to report for the corresponding register value, in 4 dB per"
                "step. Estimated attenuation[n] and Register value[n] are interleaved and repeated"
                "for Power table length entries.";
        PARAM "Testmode Register value[0]"
            uint8
            doc "The register value to use for this step, increasing by 2 for each 4 dB step."
                "Estimated attenuation[n] and Register value[n] are interleaved and repeated"
                "for Power table length entries.";
        PARAM "Testmode Estimated attenuation[1]"
            uint8;
        PARAM "Testmode Register value[1]"
            uint8;
        PARAM "Testmode Estimated attenuation[2]"
            uint8;
        PARAM "Testmode Register value[2]"
            uint8;
        PARAM "Testmode Estimated attenuation[3]"
            uint8;
        PARAM "Testmode Register value[3]"
            uint8;
        PARAM "Testmode Estimated attenuation[4]"
            uint8;
        PARAM "Testmode Register value[4]"
            uint8;
        PARAM "Testmode Estimated attenuation[5]"
            uint8;
        PARAM "Testmode Register value[5]"
            uint8;
        PARAM "Testmode Estimated attenuation[6]"
            uint8;
        PARAM "Testmode Register value[6]"
            uint8;
        PARAM "Testmode Estimated attenuation[7]"
            uint8;
        PARAM "Testmode Register value[7]"
            uint8;
    }


    COMMAND "RSSI Config" 0x5F
    {
        doc "Sets the RSSI thresholds and interval used for increment and decrement power decisions"
        PARAM "Low Power Limit"
            uint8
            doc "When abs(RSSI) is above this limit, firmware sends LMP_incr_power_req. Raw RSSI"
                "readings are from 0 to -110 dB.";
        PARAM "High Power Limit"
            uint8
            doc "When abs(RSSI) is below this limit, firmware sends LMP_decr_power_req. Raw RSSI"
                "readings are from 0 to -110 dB.";
        PARAM "Increment Interval Count"
            uint8
            doc "The minimum number of 125 mSec periods between increment lmp messages"
                "After the period has expired and other conditions are met, an lmp may be sent.";
        PARAM "Increment Mode"
            uint8
            doc "If set to 0 any sample below the golden range triggers an incr lmp"
                "If set to 1 the avg. power must be below the golden range to trigger an incr pwr lmp";
        PARAM "Decrement Interval Count"
            uint8
            doc "The minimum number of 125 mSec periods between decrement lmp messages"
                "After the period has expired and other conditions are met, an lmp may be sent.";
        PARAM "Disable Local Power Control"
            uint8
            doc "When set to 1, local power control will be disabled. The firmware will not change"
                "the Tx power regardless of any received incr or decr lmp.";
        PARAM "Max Class 2 Power Level"
            uint8
            doc "The Tx power setting in dbm used when the remote device does not support power control";
        PARAM "Agc Status Register Offset"
            int8
            doc "This value is an offset added to the AGC status reg. reading to calculate the correct RSSI";
        PARAM "Max Pwr Request Power Delta Trigger"
            int8
            doc "If the rx power delta between samples is >= this limit, ask the remote device to send max power";
    }


    # COMMAND "Command Sample Point" 0x60 - Someone needs to provide a definition

    COMMAND "DHM SCO RX Lengh Threshold" 0x61
    {
        doc "DHM SCO receive length threshold"
        PARAM "Threshold"
            uint8
            doc "This threshold defines the minimum number of SCO bytes received over the air"
                "to be sent to the host";
    }

    COMMAND "CSA thread stack size" 0x62
    {
        doc "Sets the size of the CSA thread stack"
        PARAM "Size in UINT32s"
            uint16
            doc "This value determines the stack size in UINT32s.";
    }

    # COMMAND "FEC Error Count Threshold" 0x63 - Someone needs to provide a definition

    COMMAND "Max Supported Piconet Count" 0x64
    {
        doc "Sets the number of piconets which can be simultaneously participated in, without"
            "distinguishing between a master or slave role."
        PARAM "Size"
            uint8
            doc "The number of supported piconets.  The default value is 4, and the maximum is 4."
            default = 4
            max = 4;
    }


    # COMMAND "XD PAD Config 2 Pull Up/Down" 0x65 - Someone needs to provide a definition


    COMMAND "SDIO Clock Cutoff Control" 0x66
    {
        doc "Parameters for SDIO clock cutoff control."
        PARAM "SDIO clock cutoff enable"
            uint8
            doc "SDIO Clock cutoff enable"
            enum
            {
                {0x00, "Disabled"},
                {0x01, "Enabled"}
            }
            default = 0x00;
        PARAM "SDIO clock cutoff polarity"
            uint8
            doc "SDIO clock cutoff polarity"
            enum
            {
                {0x00, "Cutoff on 1"},
                {0x01, "Cutoff on 0"}
            }
            default = 0x00;
        PARAM "SDIO clock cutoff signal"
            uint8
            doc "SDIO clock cutoff signal"
            enum
            {
               {0x00, "SDIO_CLOCK_CUTOFF_SIG_GPIO_0"},
               {0x01, "SDIO_CLOCK_CUTOFF_SIG_GPIO_1"},
               {0x02, "SDIO_CLOCK_CUTOFF_SIG_GPIO_2"},
               {0x03, "SDIO_CLOCK_CUTOFF_SIG_GPIO_3"},
               {0x04, "SDIO_CLOCK_CUTOFF_SIG_GPIO_4"},
               {0x05, "SDIO_CLOCK_CUTOFF_SIG_GPIO_5"},
               {0x06, "SDIO_CLOCK_CUTOFF_SIG_GPIO_6"},
               {0x07, "SDIO_CLOCK_CUTOFF_SIG_GPIO_7"},
               {0x08, "SDIO_CLOCK_CUTOFF_SIG_PCM_CLK"},
               {0x09, "SDIO_CLOCK_CUTOFF_SIG_PCM_SYNC"},
               {0x0a, "SDIO_CLOCK_CUTOFF_SIG_PCM_OUT"},
               {0x0b, "SDIO_CLOCK_CUTOFF_SIG_PCM_IN"},
               {0x0c, "SDIO_CLOCK_CUTOFF_COEX_OUT0"},
               {0x0d, "SDIO_CLOCK_CUTOFF_COEX_OUT1"},
               {0x0e, "SDIO_CLOCK_CUTOFF_COEX_SDA"},
               {0x0f, "SDIO_CLOCK_CUTOFF_COEX_SCL"}
            }
            default = 0;
    }


    COMMAND "SCO Parameters" 0x68
    {
        doc "Sets the SCO and PCM interface parameters."
        PARAM "RESERVED"
            uint32{31:25}
            doc "Pad bits included to fill the parameters out to a uint32."
            binary_message_only
            encode_value = 0
            enabled_if (0 = 1);     # Never
        PARAM "I2S enable"
            uint32{24:24}
            doc "Enables the I2S/PCM interface."
            enum
            {
                {0x00, "False"},
                {0x01, "True"}
            };
        PARAM "Sample rate"
            uint32{23:22}
            doc "Sets the sampling rate of the PCM/I2S Interface."
            enum
            {
                {0x00, "8 KBps"},
                {0x01, "16 KBps"},
                {0x02, "4 KBps"}
            };
        PARAM "SCO routing"
            uint32{21:19}
            doc "Sets the SCO data source and destination to either transport or PCM."
            enum
            {
                {0x00, "PCM"},
                {0x01, "Transport"}
            };
        PARAM "Clock mode"
            uint32{18:18}
            doc "Specifies whether Bluetooth module to be the master or slave for PCM_CLK signal"
            enum
            {
                {0x00, "Slave"},
                {0x01, "Master"}
            };
        PARAM "SCO time slot"
            uint32{17:14}
            doc "Time slot assignment";
        PARAM "Justify"
            uint32{13:13}
            doc "Indicates the data to right justify (fill data shifted out first) or not. Default is left justify"
                "(fill data shifted out last)."
            enum
            {
                {0x00, "Left"},
                {0x01, "Right"}
            };
        PARAM "Fill bits"
            uint32{12:10}
            doc "Specifies the number of bits to be filled.  The maximum value is three."
            max = 3;
        PARAM "Fill data"
            uint32{9:8}
            doc "Indicates the method of filling unused data bits"
            enum
            {
                {0x00, "0's"},
                {0x01, "1's"},
                {0x02, "Signed"},
                {0x03, "Programmable"}
            };
        PARAM "Fill value"
            uint32{7:6}
            doc "Specifies the value with which to fill unused bits if Fill_Data is set to"
                "programmable"
            enabled_if ("Fill data" = 0x03)
            max =   if      ("Fill bits" = 0) then  0
                    else if ("Fill bits" = 1) then  1
                    else if ("Fill bits" = 2) then  3
                    else                            7;
        PARAM "PCM interface rate"
            uint32{5:3}
            doc "Indicates the PCM clock frequency."
            enum
            {
                {0x00, "128 KBps"},
                {0x01, "256 KBps"},
                {0x02, "512 KBps"},
                {0x03, "1024 KBps"},
                {0x04, "2048 KBps"}
            };
        PARAM "Frame type"
            uint32{2:2}
            doc "Indicates the PCM frame type: short frame or long frame"
            enum
            {
                {0x00, "Short"},
                {0x01, "Long"}
            };
        PARAM "Sync mode"
            uint32{1:1}
            doc "Indicates whether Bluetooth module is the master or slave for PCM_SYNC signal"
            enum
            {
                {0x00, "Slave"},
                {0x01, "Master"}
            };
        PARAM "Bit order"
            uint32{0:0}
            doc "Indicates whether the LSB bit is shifted out first or not for serial PCM data"
            enum
            {
                {0x00, "MSB first"},
                {0x01, "LSB first"}
            };
    }


    COMMAND "Daul Boot Control" 0xFB
    {
        doc "The Dual boot control block"
        PARAM "DS1_Offset"
            uint32
            doc "DS1 section offset";
        PARAM "DS2_Offset"
            uint32
            doc "DS2 section offset";
        PARAM "FailReturn"
            uint8
            doc "Fail Return count";
        PARAM "EndOfBootSection"
            uint8
            doc "End of Boot section";
    }


    COMMAND "FW CRC32" 0xFC
    {
        doc "The crc32 of the EEPROM image"
        PARAM "Crc32"
            uint32
            doc "The crc32 of the EEPROM image place holder";
    }


    COMMAND "Config Data Version" 0x69
    {
        doc "Sets the configuration data version of the released configuration data file. The value"
            "is set when the CGS source file is compiled to a formal release in CGR format."
        PARAM "Config data version"
            uint16
            doc "The version of configuration data, range is 0x000 to 0xFFF."
            max = 0x0FFF
            binary_message_only
            encode_value = ReleaseParameter("Config data version");
    }


    COMMAND "LED Control" 0x6A
    {
        doc "Sets the LED behavior as a function of chip state"
        PARAM "LED Global Disable"
            uint8{ 7:7 }
            doc "If set to TRUE then LED logic not used";
        PARAM "GPIO used for led control"
            uint8{ 6:0 }
            doc "The GPIO (0-7) that controls the LED state"
            max = 0x7;
        PARAM "GPIO Open Drain Mode"
            uint8{ 7:7 }
            doc "If set to TRUE then the GPIO is operated in open drain mode";
        PARAM "GPIO sense used to turn LED ON"
            uint8{ 6:0 }
            doc "Sets the sense of the LED GPIO to turn the LED ON"
            enum
            {
                {0x0, "Set low"},
                {0x1, "Set high"}
            };
        PARAM "Power-up state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED."
                "The range of Priority is 0 to 15 decimal."
            min = 0x0
            max = 0xF;
        PARAM "Power-up state mode"
            uint8{ 3:0 }
            doc "The operating mode"
                "For states other than the Power-up state, the mode may"
                "be set to State not used."
                "States that are not used will not control the LED behavior"
            enum
            {
                {0x0, "State not used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Power-up state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Power-up state mode" = 0x03);
        PARAM "Power-up state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Power-up state mode" = 0x03);
        PARAM "Power-up state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Power-up state mode" = 0x03);
        PARAM "USB global suspend state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "USB global suspend state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "USB global suspend state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("USB global suspend state mode" = 0x03);
        PARAM "USB global suspend state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("USB global suspend state mode" = 0x03);
        PARAM "USB global suspend state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("USB global suspend state mode" = 0x03);
        PARAM "USB selective suspend state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "USB selective suspend state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "USB selective suspend state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("USB selective suspend state mode" = 0x03);
        PARAM "USB selective suspend state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("USB selective suspend state mode" = 0x03);
        PARAM "USB selective suspend state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("USB selective suspend state mode" = 0x03);
        PARAM "Connected state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "Connected state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Connected state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Connected state mode" = 0x03);
        PARAM "Connected state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Connected state mode" = 0x03);
        PARAM "Connected state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Connected state mode" = 0x03);
        PARAM "Transmit - receive state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "Transmit - receive state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Transmit - receive state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Transmit - receive state mode" = 0x03);
        PARAM "Transmit - receive state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Transmit - receive state mode" = 0x03);
        PARAM "Transmit - receive state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Transmit - receive state mode" = 0x03);
        PARAM "Autopairing Phase 1 state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "Autopairing Phase 1 state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Autopairing Phase 1 state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Autopairing Phase 1 state mode" = 0x03);
        PARAM "Autopairing Phase 1 state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Autopairing Phase 1 state mode" = 0x03);
        PARAM "Autopairing Phase 1 state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Autopairing Phase 1 state mode" = 0x03);
        PARAM "Autopairing Phase 2 state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "Autopairing Phase 2 state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Autopairing Phase 2 state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Autopairing Phase 2 state mode" = 0x03);
        PARAM "Autopairing Phase 2 state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Autopairing Phase 2 state mode" = 0x03);
        PARAM "Autopairing Phase 2 state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Autopairing Phase 2 state mode" = 0x03);
        PARAM "Inquiry state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "Inquiry state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Inquiry state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Inquiry state mode" = 0x03);
        PARAM "Inquiry state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Inquiry state mode" = 0x03);
        PARAM "Inquiry state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Inquiry state mode" = 0x03);
        PARAM "Page state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "Page state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Page state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Page state mode" = 0x03);
        PARAM "Page state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Page state mode" = 0x03);
        PARAM "Page state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second.."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Page state mode" = 0x03);
        PARAM "Radio disabled state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED."
                "The range of Priority is 0 to 15 decimal."
            min = 0x0
            max = 0xF;
        PARAM "Radio disabled state mode"
            uint8{ 3:0 }
            doc "The operating mode"
                "For states other than the Power-up state, the mode may be set to State not used."
                "States that are not used will not control the LED behavior."
            enum
            {
                {0x0, "State not used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Radio disabled state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second.."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Radio disabled state mode" = 0x03);
        PARAM "Radio disabled state blinking period"
            uint8
            doc "The period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Radio disabled state mode" = 0x03);
        PARAM "Radio disabled state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Radio disabled state mode" = 0x03);
        PARAM "Sleep state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED."
                "The range of Priority is 0 to 15 decimal."
            min = 0x0
            max = 0xF;
        PARAM "Sleep state mode"
            uint8{ 3:0 }
            doc "The operating mode"
                "For states other than the Power-up state, the mode may be set to State not used."
                "States that are not used will not control the LED behavior."
            enum
            {
                {0x0, "State not used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"}
            };
        PARAM "Sleep state blinking minimum dwell time"
            uint8
            doc "Unused for sleep state.  Necessary because all states require"
                "same amount of storage in FW."
            enabled_if ("Sleep state mode" = 0x03);
        PARAM "Sleep state blinking period"
            uint8
            doc "Unused for sleep state.  Necessary because all states require"
                "same amount of storage in FW."
            enabled_if ("Sleep state mode" = 0x03);
        PARAM "Sleep state blinking led on time"
            uint8
            doc "Unused for sleep state.  Necessary because all states require"
                "same amount of storage in FW."
            enabled_if ("Sleep state mode" = 0x03);
        PARAM "Page scan state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "Page scan state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Page scan state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Page scan state mode" = 0x03);
        PARAM "Page scan state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Page scan state mode" = 0x03);
        PARAM "Page scan state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Page scan state mode" = 0x03);
        PARAM "Inquiry scan state priority"
            uint8{ 7:4 }
            doc "The highest priority active attribute will control the LED"
            min = 0x0
            max = 0xF;
        PARAM "Inquiry scan state mode"
            uint8{ 3:0 }
            doc "The operating mode"
            enum
            {
                {0x0, "State Not Used"},
                {0x1, "LED is OFF"},
                {0x2, "LED is ON"},
                {0x3, "LED is BLINKING"}
            };
        PARAM "Inquiry scan state blinking minimum dwell time"
            uint8
            doc "The minimum time that the active attribute will control the LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Inquiry scan state mode" = 0x03);
        PARAM "Inquiry scan state blinking period"
            uint8
            doc "The Period for a blinking LED."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Inquiry scan state mode" = 0x03);
        PARAM "Inquiry scan state blinking led on time"
            uint8
            doc "Duration of the ON time for each period."
                "Time is expressed in units of 8 counts per second."
                "For example, 2 seconds is 16 counts."
            enabled_if ("Inquiry scan state mode" = 0x03);
    }


    COMMAND "SDIO HW Feature Enable" 0x6c
    {
        doc "SDIO HW feature enable"
        PARAM "Reserved SDIO HW feature"
            uint8{7:3}
            doc "Reserved SDIO HW feature";
        PARAM "Enable block mode"
            uint8{2:2}
            doc "Enable block mode"
            enum
            {
                {0x00, "Disable"},
                {0x01, "Enable"}
            };
        PARAM "Enable Function 1 self reset"
            uint8{1:1}
            doc "Enable Function 1 self reset"
            enum
            {
                {0x00, "Disable"},
                {0x01, "Enable"}
            };
        PARAM "Enable I/O Card self reset"
            uint8{0:0}
            doc "Enable I/O Card self reset"
            enum
            {
                {0x00, "Disable"},
                {0x01, "Enable"}
            };
    }


    # COMMAND "BTW Security Key" 0x6D - Fixed header only


    COMMAND "UHE Configuration 2" 0x6E
    {
        doc "Parameters for UHE configuration '08."
        PARAM "Autopairing GPIO"
            uint8
            doc "Autopairing GPIO select.  Selects the GPIO used for autopairing button"
            min = 0
            max = 7;
        PARAM "Antenna detect GPIO"
            uint8
            doc "Antenna detect GPIO select.  Selects the GPIO used for the antenna"
                "detection feature."
            # Unfortunately, can't add enabled_if for backward compatability/can't move under UHE 08 Feature map
            # enabled_if ( ("UHE 08 Feature map" & 0x0008)=0x0008)
            min = 0
            max = 7;
        PARAM "UHE 08 Feature map"
            uint16
            doc "UHE configuration '08 feature map."
                "  0001: Support Hybrid HID as a 3rd HID"
                "  0002: Disable ZeroTouch. This will prevent from doing RNR and SDP"
                "  0004: Set default startup mode to BT. The HidCtrl commands may override this."
                "  0008: Enable antenna detection for UBIST tests"
                "  0010: Antenna polarity for UBIST tests"
                "  0020: Use actual HID report descriptors"
                "  0040: Vista Suspend Workaround.  Vista may send HCI reset after turning remote wake on, so we "
                "        need to reenable scans in that case"
                "  0080: "
                "  0100: Disable KB and MS ports in BT mode"
                "  0200: Autoadd all HID devices paired in BT mode as UHE boot devices.  If set, host does not need "
                "        to send HidCtrl commands prior to pairing devices."
                "  0400: Enable KB interrupt-in zero-length packets in bios mode"
                "  0800: Enable MS interrupt-in zero-length packets in bios mode"
            bitmap
            {
                {0x0001, "Support Hybrid HID as a 3rd HID"},
                {0x0002, "Disable ZeroTouch"},
                {0x0004, "Set startup mode to BT"},
                {0x0008, "Antenna enable"},
                {0x0010, "Antenna GPIO polarity"},
                {0x0020, "Actual HID Report Descriptors"},
                {0x0040, "Vista Suspend Workaround"},
                {0x0080, "Unused"},
                {0x0100, "Disable KB and MS ports in BT mode"},
                {0x0200, "Autoadd BT devices for UHE mode"},
                {0x0400, "Enable KB interrupt-in zero-length packets in bios mode"},
                {0x0800, "Enable MS interrupt-in zero-length packets in bios mode"}
            };
        PARAM "Autopairing Inquiry Transmit Power"
            int8
            doc "Autopairing Inquiry Transmit Power.  Sets the inquiry transmit power used"
                "during autopairing via HCI command.  Set to 0 to disable feature."
            min = -70
            max = 20;
        PARAM "Zero Touch Recovery Time"
            uint8
            doc "Timer that controls how long to do automatic recovery. In 5 seconds unit."
                "Set to 0 to disable zero touch feature";

    }


    COMMAND "Coexistence Config" 0x6F
    {
        doc "A structure defines the Bluetooth Coexistence (with WLAN) to be used"
            "and defines the priority associated with each Bluetooth activity"
        PARAM "Type"
            uint8
            doc "Select the Coexistence Type to be used"
            enum
            {
                {0x0, "No collaboration"},
                {0x1, "2 pin 2 pin solution"},
                {0x2, "3 pin 2 pin solution"},
                {0x3, "WCS"},
                {0x4, "WiMax"}
            };
        PARAM "Priorities"
            uint32
            doc "Bluetooth Priorities per activity"
            bitmap
            {
                {0x00000001, "STANDBY"},
                {0x00000002, "LOW_PRI_CONNECTION"},
                {0x00000004, "AFH_RSSISCAN"},
                {0x00000008, "BROADCAST"},
                {0x00000010, "INQUIRY"},
                {0x00000020, "PAGE"},
                {0x00000040, "CONNECTION"},
                {0x00000080, "CONN_WITH_DATA"},
                {0x00000100, "TPOLL"},
                {0x00000200, "INQSCAN"},
                {0x00000400, "PAGESCAN"},
                {0x00000800, "MASTER_SLAVE_SWITCH"},
                {0x00001000, "NEW_CONNECTION"},
                {0x00002000, "SETUP_CONN"},
                {0x00004000, "MODULO"},
                {0x00008000, "HOLD"},
                {0x00010000, "SNIFF"},
                {0x00020000, "PARK"},
                {0x00040000, "SCO"},
                {0x00080000, "ESCO"},
                {0x00100000, "SLAVE_POLL_LMP"},
                {0x01000000, "DEFER_HIGH_PRIORITY_FRAME (3 wires only)"},
		        {0x02000000, "INCREASE_PRIORITY_AFTER_DEFFER_ENABLED"},
		        {0x04000000, "DONT_RESET_LCU (2048 only)"},
		        {0x08000000, "NON_CONNECTION_HW_SUPPORT  (2048 only)"},
		        {0x40000000, "PAGE_SCAN_HW_SUPPORT_BIT_0 (2048 only)"},
		        {0x80000000, "PAGE_SCAN_HW_SUPPORT_BIT_1 (2048 only)"}
            };
        PARAM "TX_BT (2 wires) or RF_ACTIVE (3 wires) routing"
            uint8
            doc "Defines whether the TX_BT (2 wires) or RF_ACTIVE (3 wires) signal is routed to"
                "GPIO3 or GPIO4. With three-wire coexistance, the STATUS signal is routed to GPIO3"
                "or GPIO4, whichever is not selected for RF_ACTIVE. The default selection for TX_BT"
                "or RF_ACTIVE is GPIO4, with STATUS being routed to GPIO3 in 3 wire coexistance"
                "mode."
            enum
            {
                {0, "GPIO4"},
                {1, "GPIO3"}
            };
        PARAM "T1 time 2 wire"
            uint8
            doc "Defines the times TX_BT will be asserted (before the begining of the TX Slot)."
                "Units are in microseconds. The default value is 25."
            enabled_if ( ("Type" = 1) or ("Type" = 0) or ("Type" = 3) )
            default = 25;
        PARAM "T2 time 2 wire"
            uint8
            doc "Defines the times TX_WLAN will be sampled (before the begining of the TX Slot)."
                "Units are in microseconds. The default value is 25."
            enabled_if ( ("Type" = 1) or ("Type" = 0) or ("Type" = 3) )
            default = 25;
        PARAM "T1 time 3 wire"
            uint8
            doc "Defines the times RF_ACTIVE will be asserted (before the begining of the TX Slot)."
                "Units are in microseconds. The default value is 150."
            enabled_if ( ("Type" = 2) or ("Type" = 0) )
            default = 150;
        PARAM "T2 time 3 wire"
            uint8
            doc "Defines the priority assertion time of STATUS line, during this time the priority"
                "is reflected. After this time TX-RX is reflected. Units are in microseconds. The"
                "default value is 20."
            enabled_if ( ("Type" = 2) or ("Type" = 0) )
            default = 20;
        PARAM "T3 time 3 wire"
            uint8
            doc "Defines the time to assert the STATUS line before begining TX as a slave."
                "Units are in microseconds. The default value is 88."
            enabled_if ( ("Type" = 2) or ("Type" = 0) )
            default = 88;
        PARAM "T5 time 3 wire"
            uint8
            doc "Defines the time to sample the TX_CONFX before the begining of the TX slot."
                "Units are in microseconds. The default value is 75."
            enabled_if ( ("Type" = 2) or ("Type" = 0) )
            default = 75;
        PARAM "T7 time 3 wire"
            uint8
            doc "Defines the time between assertion of RF_ACTIVE to assetion of STATUS. Units are"
                "in microseconds. The default value is 0 and the maximum value is 1."
            enabled_if ( ("Type" = 2) or ("Type" = 0) )
            max = 1;
        PARAM "A2DP Priority inverse threshold"
            uint8{ 7:4 }
            doc	"Effective if"
                "INCREASE_PRIORITY_AFTER_DEFFER_ENABLED is enabled. This paramter defines after how"
                "many frames defered by the WLAN, the the priority of that defered frame will be"
                "increased"
            min = 1;
        PARAM "ACL Priority inverse threshold"
            uint8{ 3:0 }
            doc	"Effective if"
                "INCREASE_PRIORITY_AFTER_DEFFER_ENABLED is enabled. This paramter defines after how"
                "many frames defered by the WLAN, the the priority of that defered frame will be"
                "increased"
            min = 1;
        PARAM "Configuration flags 1"
            uint32
            doc "Additional configuration flags."
            bitmap
            {
                {0x00000001, "Coexistence auto selection"},
                {0x00000002, "Coexistence auto pad config"},
                {0x01000000, "5WIRE support"},
                {0x02000000, "A2DP ACL priority inverse"},
                {0x04000000, "A2DP Dual Antenna Mode"},
                {0x08000000, "Nonconnection LCU reset"},
                {0x10000000, "Connection hardware support"},
                {0x80000000, "Hardware coexistence mode"},
                {0x00010000, "BLE COEX Nokia Mode"},
                {0x00008000, "BLE COEX Enable"}
            };
        PARAM "Configuration flags 2"
            uint32
            doc "Additional configuration flags."
            bitmap
            {
                {0x02000000, "BLE Connection high priority"},
                {0x01000000, "BLE INIT high priority"},
                {0x00800000, "BLE SCAN high priority"},
                {0x00400000, "BLE ADV high priority"},
                {0x20000000, "Slave poll priority"},
                {0x40000000, "PS and FHS low priority"},
                {0x80000000, "LMP high priority"}
            };
        PARAM "T9 time 3 wire"
            uint8
            doc "Defines the time between assertion of RF_ACTIVE to assetion of STATUS for Low priority frame."
			"Units are in microseconds."
            enabled_if ( ("Type" = 2) or ("Type" = 0) )
            default = 175;
        PARAM "WCS_NUMBIT"
            uint8
            doc "Defines the time between assertion of RF_ACTIVE to assetion of STATUS for Low priority frame."
			"Units are in microseconds."
            enabled_if ( ("Type" = 3) or ("Type" = 0) )
            default = 7;
        PARAM "WCS_NUMChannel"
            uint8
            doc "Defines the time between assertion of RF_ACTIVE to assetion of STATUS for Low priority frame."
			"Units are in microseconds."
            enabled_if ( ("Type" = 3) or ("Type" = 0) )
            default = 17;
        PARAM "4TH_WIRE"
            uint8
            doc "Defines the GPIO used as 4th wire"
            enabled_if ( ("Configuration flags 1" & 0x01000000)=0x01000000)
            default = 4;
        PARAM "5TH_WIRE"
            uint8
            doc "Defines the GPIO used as 5th wire"
            enabled_if ( ("Configuration flags 1" & 0x01000000)=0x01000000)
            default = 8;
        PARAM "SCOThreshold"
            uint8
            doc "Every one of SCOThreshold number of SCO instance will be sent as low priority in 4th wire"
            enabled_if ( ("Configuration flags 1" & 0x01000000)=0x01000000)
            default = 30;
        PARAM "GPIO_5WIRE_TYPE"
            uint8
            doc "Select the GPIO on which to route the 4th wire signal."
            enum
            {
                {0x0, "GPIO2_5WIRE"},
                {0x1, "GPIOC_5WIRE"},
                {0x2, "GPIOD_5WIRE"},
                {0x3, "GPIO_5WIRE"}
            }
            enabled_if ( ("Configuration flags 1" & 0x01000000)=0x01000000)
            default = 0x0;
        PARAM "T1 time 3 wire for BLE"
            uint8
            doc "Defines the times TX_BT will be asserted (before the begining of the TX Slot)."
                "Units are in microseconds. The default value is 25."
            enabled_if ( ("Configuration flags 1" & 0x00008000)=0x00008000 )
            default = 108;
        PARAM "T2 time 3 wire for BLE"
            uint8
            doc "Defines the priority assertion time of STATUS line, during this time the priority"
                "is reflected. After this time TX-RX is reflected. Units are in microseconds. The"
                "default value is 88."
            enabled_if ( ("Configuration flags 1" & 0x00008000)=0x00008000)
            default = 88;
        PARAM "T5 time 3 wire for BLE"
            uint8
            doc "Defines the time to sample the TX_CONFX before the begining of the TX slot."
                "Units are in microseconds. The default value is 63."
            enabled_if ( ("Configuration flags 1" & 0x00008000)=0x00008000 )
            default = 63;
        PARAM "T7 time 3 wire for BLE"
            uint8
            doc "Defines the time between assertion of RF_ACTIVE to assetion of STATUS. Units are"
                "in microseconds. The default value is 0 and the maximum value is 1."
            enabled_if ( ("Configuration flags 1" & 0x00008000)=0x00008000 )
            default = 107;
    }

    COMMAND "Miscellaneous RF Tuning Control" 0x70
    {
        doc "32-bit bitmapped register to control several RF tuning options"
        PARAM "Flag"
            uint32
            doc " Miscellaneous configuration flags"
            bitmap
            {
                {0x00000001, "Image tune enable"},
                {0x00000002, "GPS avoidance tuning enable"},
                {0x00000004, "PA Gain Sweep mode enable"},
                {0x00000008, "Update TCA table from RFP enable"},
                {0x00000010, "Single bin RFP update disable"}
            };
    }

    #COMMAND "Temperature Correction Algorithm Offset" 0x70
    #{
    #    doc "Offset added to or subtracted from the estimated temperature"
    #    PARAM "Subtract"
    #        bool in uint8{7}
    #        doc "If 0, Absolute offset will be added."
    #            "If 1, Absolute offset will be subtracted.";
    #    PARAM "Absolute offset"
    #        uint8{6:0}
    #        doc "The absolute value to be added or subtracted.";
    #}

    COMMAND "Multi-Slot Sniff Attempts" 0x71
    {
        doc "Enable multi-slot sniff attempts"
        PARAM "Enable"
            bool8
            doc "Enables multi-slot sniff attempts if 1.";
    }


    COMMAND "Sleep Mode Configuration" 0x72
    {
        doc "Configure how to sleep"
        PARAM "Sleep mode"
            uint8
            doc "Sleep mode algorithm selection."
            enum
            {
                {0x00, "No sleep mode"},
                {0x01, "UART"},
                {0x02, "UART with messaging"},
                {0x03, "USB"},
                {0x05, "USB with host wake"},
                {0x06, "SDIO"},
                {0x07, "UART CS-N"},
                {0x08, "SPI"},
                {0x09, "H5"},
                {0x0B, "HIDD"}  #no this item in 20702b0
            };
        PARAM "Idle threshold host"
            uint8
            doc "Host Idle Threshold, applicable To Sleep Modes 1, 2, 5, 7."
                "This is the number of firmware loops executed with no activity"
                "before the Host wake line is deasserted. Activity includes HCI"
                "traffic excluding certain sleep mode commands and the presence"
                "of SCO connections if the \"Allow Host Sleep During SCO\" flag is"
                "not set to 1. Each count of this parameter is roughly equivalent"
                "to 300 ms. For example, when this parameter is set to 16 (0x10),"
                "the Host wake line will be deasserted after approximately 4.8"
                "seconds of inactivity."
            enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 5) or
                         ("Sleep mode" = 7));
        PARAM "Idle threshold HC"
            uint8
            doc "Host Controller Idle Threshold, applicable To Sleep Modes 1, 2, 3, 5,"
                "6, 7, 9. This is the number of firmware loops executed with no activity"
                "before the HC is considered idle. Depending on the mode, HC may"
                "then attempt to sleep. Activity includes HCI traffic excluding"
                "certain sleep mode commands and the presence of ACL/SCO connections."
                "Each count of this parameter is roughly equivalent to 300 ms."
                "For example, when this parameter is set to 16 (0x10), the HC will"
                "be considered idle after approximately 4.8 seconds of inactivity."
            enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 3) or
                        ("Sleep mode" = 5) or ("Sleep mode" = 6) or
                        ("Sleep mode" = 7) or ("Sleep mode" = 9));
        PARAM "Enable break to host"
            uint8{7:7}
            doc "Enable break to host";
        PARAM "Pulsed host wake"
            uint8{6:6}
            doc "Pulsed host wake";
        PARAM "Active connection handling on suspend"
            uint8{5:5}
            doc "Suspend Behavior, applicable To Sleep Modes 3, 5."
                "When set to 0, this flag indicates that upon detecting a USB suspend,"
                "the device should sleep whenever possible. This means that the device"
                "will stay up if necessary to maintain active ACL and/or SCO connections,"
                "and will wake up to perform any scheduled periodic activities if configured to do so."
                "When set to 1, the device will immediate go to sleep upon detecting a USB"
                "SUSPEND and will not wake up until USB RESUME is detected. This will cause"
                "all connections (whether ACL or SCO, parked or not, etc.) to be dropped."
                "All periodic activity will also be suspended. When this flag is set to 1,"
                "all other parameters are ignored."
            enum
            {
                {0x00, "Maintain connections; sleep when timed activity allows"},
                {0x01, "Sleep until resume is detected"}
            }
            enabled_if (("Sleep mode" = 3) or ("Sleep mode" = 5));
        PARAM "Enable tristate control of UART TX line"
            bool in uint8{4}
            doc "Applicable To Sleep Modes 1, 2, 7."
                "When set to 0, the device will not tristate its UART TX line before going to sleep.<br>"
                "When set to 1, the device will tristate its UART TX line before going to sleep."
            enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 7));
        PARAM "Combine sleep mode and LPM"
            bool in uint8{3}
            doc "Applicable To Sleep Modes 1, 2, 3, 5, 7."
                "In Mode 0, always set byte 7 to 0. In all sleep modes, device always"
                "requires permission to sleep between scans / periodic inquiries regardless"
                "of the setting of this byte. In Modes 1 and 2, if byte is set, device must"
                "have \"permission\" to sleep during the low power modes of sniff, hold, and park."
                "If byte is not set, device can sleep without permission during these modes."
                "Permission to sleep in Mode 1 is obtained if the BT_WAKE signal is not asserted."
                "Permission to sleep in Mode 2 occurs after the Sleep Request / Sleep Request ACK exchange."
                "In Mode 3 and 5, if the byte is set to 0, the device will not be able to sleep"
                "during the low power modes. If it is set to 1, the device will be able so sleep"
                "during the low power modes."
            enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 3) or
                        ("Sleep mode" = 5) or ("Sleep mode" = 7));
        PARAM "Allow host sleep during SCO"
            bool in uint8{2}
            doc "Applicable To Sleep Modes 1, 2, 3, 5, 7."
                "When this flag is set to 0, the host is not allowed to sleep while"
                "an SCO is active. In modes 1 and 2, the device will keep the host"
                "wake line asserted while an SCO is active. In mode 3, the device"
                "will immediately issue a USB RESUME if the host issues a SUSPEND."
                "When this flag is set to 1, the host can sleep while an SCO is active."
                "This flag should only be set to 1 if SCO traffic is directed to the PCM interface."
            enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 3) or
                        ("Sleep mode" = 5) or ("Sleep mode" = 7));
        PARAM "GPIO 3 active mode"
            uint8{1:1}
            doc "Applicable To Sleep Modes 1, 2, 5, 7."
                "This flag indicates whether the GPIO 3 line is active low or high."
            enum
            {
                {0x00, "Active Low"},
                {0x01, "Active High"}
            }
            enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 5) or
                        ("Sleep mode" = 7));
        PARAM "GPIO 0 active mode"
            uint8{0:0}
            doc "Applicable To Sleep Modes 1, 2, 7."
                "This flag indicates whether the GPIO 0 line is active low or high."
            enum
            {
                {0x00, "Active Low"},
                {0x01, "Active High"}
            }
            enabled_if (("Sleep mode" = 1) or ("Sleep mode" = 2) or ("Sleep mode" = 7));
        PARAM "Resume timeout"
            uint8
            doc "Applicable To Sleep Modes 3, 5."
                "After the device issues a USB RESUME, it will wait this many seconds for the"
                "Host to resume USB operations before issuing another USB RESUME."
                "If this value is set to 0, the device will never reissue RESUME"
                "and will instead wait forever for the host to act on the initial RESUME."
            enabled_if (("Sleep mode" = 3) or ("Sleep mode" = 5));
        PARAM "Sleep enable"
            bool8
            doc "If 1, the device is allowed to go to sleep.  If 0, the device must remain awake at"
                "all times";
        PARAM "BT Wake Up Gpio Pin"
            uint8
            doc "Configure which gpio pin to wake up BT";
    }


    COMMAND "Sleep Mode UART Send Break Wake Up Signal" 0x73
    {
        doc "This item is used to Enable Send Break Signal to wake up the host"
        PARAM "Mode enable"
            bool8
            doc "Enables sending a UART break signal to wake up the host";
        PARAM "Host sleep threshold"
            uint8
            doc "Sets the threshold time for host inactivity in seconds after which"
                "a break signal is needed to wake up the host";
        PARAM "Break signal duration"
            uint8
            doc "Sets the length of time the break signal will be activated."
                "Units are in 625 microsecond Bluetooth slots.";
        PARAM "Data delay"
            uint8
            doc "Sets the delay between the time the break signal is stopped"
                "to the time when the device can begin sending actual data."
                "Units are in 625 microsecond Bluetooth slots.";
    }


    COMMAND "SPI Transport Config" 0x74
    {
        doc "SPI transport configuration"
        PARAM "SPI handshake config"
            uint8{7:4}
            doc "Handshake configuration. Sets the interrupt line and the CS line to be active"
                "high or low."
            enum
            {
                {0x00, "INT active low; CS active low"},
                {0x01, "INT active low; CS active high"},
                {0x02, "INT active high; CS active low"},
                {0x03, "INT active high; CS active high"}
            };
        PARAM "SPI mode"
            uint8{3:0}
            doc "Sets SPI mode to 0, 1 (default), 2, or 3. The SPI Mode determines whether data"
                "is driven on the rising or falling clock edge"
            enum
            {
                {0x00, "Mode 0"},
                {0x01, "Mode 1"},
                {0x02, "Mode 2"},
                {0x03, "Mode 3"}
            };
        PARAM "SPI delay control"
            uint8
            doc "Sets the number of system clock cycles by which to delay the send_interrupt"
                "assertion when the slave attempts to send again after a race condition."
                "Default: 11000b, 1usec";
    }


    COMMAND "USB Printer Detection" 0x75
    {
        doc "Enable USB Printer Detection"
        PARAM "Enable"
            bool8
            doc "Enables printer detection if true.";
    }


    COMMAND "Enumeration Timer" 0x76
    {
        doc "Set the timeout value for port 2/3 to enumerate"
        PARAM "Value"
            uint16
            doc "The timeout period in milliseconds. For printer and PC, currently use 2000.";
    }


    COMMAND "HID Timer" 0x77
    {
        doc "Set the timeout value for a HID command to be sent (by a PC)"
        PARAM "Value"
            uint8
            doc "The timeout period in milliseconds. For printer and PC, the range 30-130 is"
                "currently working";
    }

    COMMAND "Link Quality Control Configuration" 0x78
    {
        doc "Enables rate control, sets the time history and the update duration"
        PARAM "Allow rate control"
            bool8
            doc "When set to 1 the 2045 will monitor the link quality for each connection";
        PARAM "Time history duration"
            uint8
            doc "The length of time that statistical information is maintained in seconds. The"
                "minimum value is 4 and the maximum is 20."
            enabled_if ("Allow rate control" = 1)
            min = 4
            max = 20;
        PARAM "Update rate duration"
            uint8
            doc "How often the Link Quality is evaluated for each link in seconds. The minimum"
                "value is 2 and the maximum is 10."
            enabled_if ("Allow rate control" = 1)
            min = 2
            max = 10;
    }


    COMMAND "USB Disable Downstream Port Pull Downs" 0x79
    {
        doc "Disables USB Internal downstream port pulldowns."
        PARAM "Disable"
            bool8
            doc "Boolean parameter to disable USB Internal downstream port pulldowns.";
    }


    COMMAND "Scan Interval Threshold" 0x7A
    {
        doc "Page/Inquiry scan interval threshold"
        PARAM "Interval threshold in slots"
            uint16
            doc "Scan interval threshold in slots";
    }


    COMMAND "Low Power Page Scan Configuration" 0x7B
    {
        doc "Configures the parameters for LPPS"
        PARAM "Pause 1 Number of Ticks"
            uint16
            doc "Number of 12MHz clock ticks to configure the HW for pause 1.  This is"
		"the time the HW pauses at the start of the pass and does not take"
		"samples from the cordic.  Default is 78.";
        PARAM "Pause 2 Number of Ticks"
            uint16
            doc "Number of 12MHz clock ticks to configure the HW for pause 2.  This is"
		"the time the HW pauses at the end of the pass and does not take"
		"samples from the cordic.  Default is 78.";
        PARAM "Detect Threshold"
            uint16
            doc "The detection threshold to set in HW to compare to the cordic values."
		"The HW will indicate to the FW if the cordic value is greater or"
		"equal to the threshold.  Default is 26.";
        PARAM "RF Calibration Delay"
            uint16
            doc "The delay in microseconds for the RF calibration delay.  The default"
		"is 50.";
        PARAM "Continuous Scan Count"
            uint8
            doc "The number of cordic outputs to scan in continuous conditional scan."
		"The default is 127.";
        PARAM "Sweep Pass Number"
            uint8
            doc "The number passes of the entire BT frequency band per LPPS."
		"The default is 15.";
        PARAM "Sweep Count Number"
            uint8
            doc "The number counts at a given frequency in LPPS."
		"The default is 2.";
        PARAM "Exceed Threshold Count"
            uint8
            doc "The number times the cordic output exceeds the threshold before the"
		"HW indicates to the FW that there is a detection.  The default is 1.";
        PARAM "Sweep Increment"
            uint8
            doc "The value to increment the cordic value per count.  The default is 1.";
        PARAM "Normal Scan Count Threshold"
            uint8
            doc "The number of regular scans before returning to LPPS when there is a"
		"detection.  The default is 5.";
        PARAM "Number of LPPS Scans Post Detection"
            uint8
            doc "LPPS scan counter if there is a detection.  This is the NumScans"
		"parameter in the system spec.  The default is 2.";
        PARAM "Total Number of LPPS Scans per Interval"
            uint8
            doc "Total number of LPPS scans per LPPS interval.  The default is 4.";
        PARAM "Max LPPS Consecutive Scans"
            uint8
            doc "Max number of consecutive LPPS scans before doing a regular scan."
		"The default is 4.";
        PARAM "VCO Skip Step"
            uint8
            doc "Extra Skip step in the VCO to fix non-monotonic behavior."
		"The default is 3.";
        PARAM "Cal Caps per 1MZHz"
            uint8
            doc "The number of cal cap values that are in 1MHz frequency bandwidth."
		"The default is 3.";
        PARAM "Immediate Regular Scan Flag"
            uint8
            doc "Flag to indicate immediate regular scan in the case of any LPPS detection."
		"The default is 0 (disabled).";
        PARAM "Narrow Band Block Flag"
            uint8
            doc "Flag to enable blocking on narrow band detected signals."
		"The default is 1 (enabled).";
        PARAM "Width in MHz of Wide Signal"
            uint8
            doc "Width in MHz of what is considered to be a wide band signal."
		"The default is 2.";
        PARAM "Merge Threshold Distance"
            uint8
            doc "Threshold in cal cap units of the distance between 2 detected signals"
		"in order to merge into 1 signal.  The default is 3.";
		PARAM "RESERVED"
            uint8{7:3}
            doc "Pad bits included to fill the parameters out to a uint8."
            binary_message_only
            encode_value = 0
            enabled_if (0 = 1);     # Never
        PARAM "Diagnostics enable"
            uint8{2:2}
            doc "Enable for Diagnostics.  The default is 0 (disabled).";
        PARAM "Debug enable"
            uint8{1:1}
            doc "Enable for Debug.  The default is 0 (disabled).";
        PARAM "LPPS enable"
            uint8{0:0}
            doc "Enable for LPSS.  The default is 0 (disabled).";
        PARAM "Use Threshold Table"
            bool8
            doc "Use threshold table";
    }


    COMMAND "Radio Control GPIO" 0x7C
    {
        doc "This config item enables controlling the radio through an external GPIO"
            "signal."
        PARAM "Enable GPIO radio control"
            uint8
            doc "Enables GPIO radio control, automatically set to 1 when the config item is present"
            binary_message_only
            encode_value = 1;
        PARAM "GPIO selection"
            uint8
            doc "Designate a GPIO to control the radio. It takes values from 0 to 7"
                "corresponding to GPIO0 to GPIO7"
            enum
            {
                {0x00, "GPIO 0"},
                {0x01, "GPIO 1"},
                {0x02, "GPIO 2"},
                {0x03, "GPIO 3"},
                {0x04, "GPIO 4"},
                {0x05, "GPIO 5"},
                {0x06, "GPIO 6"},
                {0x07, "GPIO 7"}
            };
        PARAM "Radio off GPIO level"
            uint8
            doc "This value indicates which GPIO level to be considered as the"
                "indication to turn off the radio. Value 0 is to indicate turning off"
                "the radio when GPIO is asserted active low. Value 1 is to indicate"
                "turning off the radio when GPIO is asserted active high."
            enum
            {
                {0, "Disable Radio when GPIO is low"},
                {1, "Disable Radio when GPIO is high"}
            };
        PARAM "Radio off latency for disconnect"
            uint8
            doc "This parameter is in the units of 1.28 seconds. After initiating the"
                "disconnection for active Bluetooth connections it will wait for this"
                "much time before it actually turning off the radio.";
    }

    COMMAND "Disable Dynamic SCO Data Routing Change" 0x7D
    {
        doc "This disables the host to change SCO/eSCO routing between PCM and transport while the"
            "audio connection still active"
        PARAM "Disable"
            uint8
            doc "Boolean parameter to enable or disable dynamic SCO/eSCO data routing change."
                "Support is enabled by default, this parameter need only ever be set to true."
            binary_message_only
            encode_value = 1;
    }


    COMMAND "PMU Config Flags" 0x7E
    {
        doc "This PMU Config map file defines various PMU Configurations as described below"
        PARAM "PMU config flags"
            uint32
            doc "General PMU config bitmap."
            bitmap
            {
                {0x01, "Deassert Host Wake if Bt Wake is deasserted"},
                {0x02, "Enable Pause Mode while not sleeping"},
                {0x04, "Enable Pause Mode and Slow AHB bus"},
                {0x08, "Enable Control Tran Clock"},
                {0x10, "Enable AV Link Auto Detect"},
                {0x20, "Enable Debug Uart Clock"},
                {0x40, "Enable HCI Read Stored Link Key Command"}
            };
    }


    COMMAND "EEPROM Page Size" 0x7F
    {
        doc "Specifies the EEPROM page size for use in ensuring that the volatile"
            "section in EEPROM is protected against loss of items in the event of"
            "power loss during a write."
        PARAM "Page size"
            uint8
            doc "The size of each EEPROM page, specific to the EEPROM component"
                "installed in the target device. The default value is 64.";
    }

    COMMAND "PMU Crystal Warm up Time" 0x80
    {
        doc "This item is to overwrite the PMU Crystal Warm up Time in Micro Seconds."
        PARAM "Crystal warm up time"
            uint16
            doc "In micro seconds."
            default = 5000;
    }


    COMMAND "Revolution Enable" 0x81
    {
        doc "Enables the Revolution Project Code in the ROM firmware"
        PARAM "Enable"
            uint8
            doc "Uint8 parameter to enable or disable the Nintendo code in the core"
                "firmware. When 1, Wii mode is enabled. When 2, Upriver mode is enabled";
    }


    COMMAND "TCA Conversion Values with Page Descriptors" 0x82
    {
        doc "TCA temperature compensation tables. This format supports"
            "up to 25 8-bit and 5 16-bit register assignments and "
            "up to 6 temperature zones. Supports 32-bit addressing"
            "with 16-bit addressing offsets for each page of 5 registers."
            "------------------------------------------------------------------------"
            "                   Temperature switching points."
            " Temperatures are floored, i.e. the temperature listed is the minimum"
            " temperature for the designated zone."
            "------------------------------------------------------------------------"
            "                      8-bit and 16-bit page descriptors."
            " The page descriptors are used  to encapsulate the information common to"
            " a register  for all temperature ranges. This includes the base address,"
            " the address offsets, and the bitmasks."
            " Legend:"
            " Single array index = [Page]"
            " Dual array index = [Page][Reg]"
            "------------------------------------------------------------------------"
            "                       8-bit and 16-bit page data."
            " The page data are the temperature-dependent data for each register"
            " listed in the page descriptors above"
            " Legend: "
            " Triple Array Indices: [TStep][Page][Reg] "
            " Triple Array Indices: [TStep][Page][Reg] "
        PARAM "FAB ID"
            uint8
            doc "8-bit unique code for identifying the actual foundary at which"
                "this device was manufactured. Used to allow variable tuning for"
                "parts from different foundaries in the same products."
            default = 0xff;
        PARAM "Num TSteps"
            uint8
            doc "The number of temperature minimum switching points. The value"
                 "is actually the desired temperature plus a 50 degree Celsius offset"
                 "For example, a switching point of -5C would be input as 45"
                 "NOTE: The accuracy of the temperature sensor is around +/- 8C,"
                 "therefore switching points should be chosen carefully to avoid"
                 "repeated adjustments around a switching point."
            min = 1
            max = 6;
        PARAM "Tmin[0]"
            uint8
            doc "Lowest temperature for region plus 50 degrees celsius offset, for"
                "example a value of 1 specifies a temperature range starting at 51"
                "degrees celsius.";
        PARAM "Tmin[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "Tmin[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "Tmin[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "Tmin[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "Tmin[5]"
            uint8
            present_if("Num TSteps" > 5);

        # TSSI Target Settings - GFSK
        PARAM "Num TssiTargets"
            uint8
            doc "No of Tssi Target values - single or per frequency bin"
                "Set value either 1 or 5."
            min = 1
            max = 5;

        PARAM "TssiTarget[0][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "TssiTarget[0][1]"
            uint16
            present_if("Num TssiTargets" > 1);
        PARAM "TssiTarget[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);
        PARAM "TssiTarget[0][3]"
            uint16
            present_if("Num TssiTargets" > 3);
        PARAM "TssiTarget[0][4]"
            uint16
            present_if("Num TssiTargets" > 4);

        PARAM "TssiTarget[1][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep1 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "TssiTarget[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));

        PARAM "TssiTarget[2][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep2 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "TssiTarget[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));

        PARAM "TssiTarget[3][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep3 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "TssiTarget[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));

        PARAM "TssiTarget[4][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep4 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "TssiTarget[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));

        PARAM "TssiTarget[5][0]"
            uint16
            doc "TSSI target for the GFSK PA gain binary search for"
                "the TStep5 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "TssiTarget[5][1]"
           uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "TssiTarget[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "TssiTarget[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "TssiTarget[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));


        # TSSI ranges - GFSK
        PARAM "TssiRangeLow[0]"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
                "the lowest temperature setting.";
        PARAM "TssiRangeHigh[0]"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
                "the lowest temperture setting.";
        PARAM "TssiRangeLow[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeHigh[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeLow[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeHigh[2]"
            uint8
            present_if("Num TSteps" > 2);
         PARAM "TssiRangeLow[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeHigh[3]"
            uint8
            present_if("Num TSteps" > 3);
         PARAM "TssiRangeLow[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeHigh[4]"
            uint8
            present_if("Num TSteps" > 4);
         PARAM "TssiRangeLow[5]"
            uint8
            present_if("Num TSteps" > 5);
        PARAM "TssiRangeHigh[5]"
            uint8
            present_if("Num TSteps" > 5);


        #TSSI targets - EDR
        PARAM "TssiTargetEDR[0][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep0 temperature setting.";
        PARAM "TssiTargetEDR[0][1]"
            uint16
            present_if("Num TssiTargets" > 1);
        PARAM "TssiTargetEDR[0][2]"
            uint16
            present_if("Num TssiTargets" > 2);
        PARAM "TssiTargetEDR[0][3]"
            uint16
            present_if("Num TssiTargets" > 3);
        PARAM "TssiTargetEDR[0][4]"
            uint16
            present_if("Num TssiTargets" > 4);

        PARAM "TssiTargetEDR[1][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep1 temperature setting."
            present_if("Num TSteps" > 1);
        PARAM "TssiTargetEDR[1][1]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[1][2]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[1][3]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[1][4]"
            uint16
            present_if(("Num TSteps" > 1) and ("Num TssiTargets" > 4));

        PARAM "TssiTargetEDR[2][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep2 temperature setting."
            present_if("Num TSteps" > 2);
        PARAM "TssiTargetEDR[2][1]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[2][2]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[2][3]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[2][4]"
            uint16
            present_if(("Num TSteps" > 2) and ("Num TssiTargets" > 4));

        PARAM "TssiTargetEDR[3][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep3 temperature setting."
            present_if("Num TSteps" > 3);
        PARAM "TssiTargetEDR[3][1]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[3][2]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[3][3]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[3][4]"
            uint16
            present_if(("Num TSteps" > 3) and ("Num TssiTargets" > 4));

        PARAM "TssiTargetEDR[4][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep4 temperature setting."
            present_if("Num TSteps" > 4);
        PARAM "TssiTargetEDR[4][1]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[4][2]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[4][3]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[4][4]"
            uint16
            present_if(("Num TSteps" > 4) and ("Num TssiTargets" > 4));

        PARAM "TssiTargetEDR[5][0]"
            uint16
            doc "TSSI target for the EDR PA gain binary search for"
                "the TStep5 temperature setting."
            present_if("Num TSteps" > 5);
        PARAM "TssiTargetEDR[5][1]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 1));
        PARAM "TssiTargetEDR[5][2]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 2));
        PARAM "TssiTargetEDR[5][3]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 3));
        PARAM "TssiTargetEDR[5][4]"
            uint16
            present_if(("Num TSteps" > 5) and ("Num TssiTargets" > 4));


        ## TSSI ranges - EDR
        ## RFP PA gain binary search endpoints
        PARAM "TssiRangeLowEDR[0]"
            uint8
            doc "Value of the low endpoint for the PA gain binary search for"
                "the lowest temperature setting.";
        PARAM "TssiRangeHighEDR[0]"
            uint8
            doc "Value of the high endpoint for the PA gain binary search for"
                "the lowest temperture setting.";
        PARAM "TssiRangeLowEDR[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeHighEDR[1]"
            uint8
            present_if("Num TSteps" > 1);
        PARAM "TssiRangeLowEDR[2]"
            uint8
            present_if("Num TSteps" > 2);
        PARAM "TssiRangeHighEDR[2]"
            uint8
            present_if("Num TSteps" > 2);
         PARAM "TssiRangeLowEDR[3]"
            uint8
            present_if("Num TSteps" > 3);
        PARAM "TssiRangeHighEDR[3]"
            uint8
            present_if("Num TSteps" > 3);
         PARAM "TssiRangeLowEDR[4]"
            uint8
            present_if("Num TSteps" > 4);
        PARAM "TssiRangeHighEDR[4]"
            uint8
            present_if("Num TSteps" > 4);
         PARAM "TssiRangeLowEDR[5]"
            uint8
            present_if("Num TSteps" > 5);
        PARAM "TssiRangeHighEDR[5]"
            uint8
            present_if("Num TSteps" > 5);

        # Temperature dependent PA gain calibration factors
        PARAM "Num Pages8"
            uint8
            doc "Number of 8-bit data pages."
            min = 1
            max = 8;
        PARAM "Num Pages16"
            uint8
            doc "Number of 16-bit data pages."
            min = 0
            max = 2;
        #######################################################################
        #                              PAGE DESCRIPTORS
        #
        # Legend:
        # Single array index = [Page]
        # Dual array index   = [Page][Reg]
        #######################################################################
        #######################################################################
        #
        # 8 - BIT PAGE DESCRIPTORS
        #
        #######################################################################
        # Page 0 is reserved for the PA Driver gain control
        # Page 0
        PARAM "BaseAddress8[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages8" > 0);
        PARAM "NumRegs8[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages8" > 0);
        PARAM "AdrOffset8[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "Bitmask8[0][0]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 0 ));
        PARAM "AdrOffset8[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "Bitmask8[0][1]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 1 ));
        PARAM "AdrOffset8[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "Bitmask8[0][2]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 2 ));
        PARAM "AdrOffset8[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "Bitmask8[0][3]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 3 ));
        PARAM "AdrOffset8[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
        PARAM "Bitmask8[0][4]"
            uint8
            doc " 8-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages8" > 0) and ("NumRegs8[0]" > 4 ));
        # Page 1
        PARAM "BaseAddress8[1]"
            uint32
            doc " 32-bit base address for Page 1"
            present_if("Num Pages8" > 1);
        PARAM "NumRegs8[1]"
            uint8
            doc " Number of registers in Page 1"
            min = 1
            max = 5
            present_if("Num Pages8" > 1);
        PARAM "AdrOffset8[1][0]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "Bitmask8[1][0]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 0 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 0 ));
        PARAM "AdrOffset8[1][1]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "Bitmask8[1][1]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 1 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 1 ));
        PARAM "AdrOffset8[1][2]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "Bitmask8[1][2]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 2 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 2 ));
        PARAM "AdrOffset8[1][3]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "Bitmask8[1][3]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 3 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 3 ));
        PARAM "AdrOffset8[1][4]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
        PARAM "Bitmask8[1][4]"
            uint8
            doc " 8-bit bit mask for Page 1 Reg 4 "
            present_if(( "Num Pages8" > 1) and ("NumRegs8[1]" > 4 ));
        # Page 2
        PARAM "BaseAddress8[2]"
            uint32
            doc " 32-bit base address for Page 2"
            present_if("Num Pages8" > 2);
        PARAM "NumRegs8[2]"
            uint8
            doc " Number of registers in Page 2"
            min = 1
            max = 5
            present_if("Num Pages8" > 2);
        PARAM "AdrOffset8[2][0]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "Bitmask8[2][0]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 0 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 0 ));
        PARAM "AdrOffset8[2][1]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "Bitmask8[2][1]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 1 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 1 ));
        PARAM "AdrOffset8[2][2]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "Bitmask8[2][2]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 2 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 2 ));
        PARAM "AdrOffset8[2][3]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "Bitmask8[2][3]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 3 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 3 ));
        PARAM "AdrOffset8[2][4]"
            uint16
            doc " 16-bit offset to the base address for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
        PARAM "Bitmask8[2][4]"
            uint8
            doc " 8-bit bit mask for Page 2 Reg 4 "
            present_if(( "Num Pages8" > 2) and ("NumRegs8[2]" > 4 ));
        # Page 3
        PARAM "BaseAddress8[3]"
            uint32
            doc " 32-bit base address for Page 3"
            present_if("Num Pages8" > 3);
        PARAM "NumRegs8[3]"
            uint8
            doc " Number of registers in Page 3"
            min = 1
            max = 5
            present_if("Num Pages8" > 3);
        PARAM "AdrOffset8[3][0]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 0 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 0 ));
        PARAM "Bitmask8[3][0]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 0 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 0 ));
        PARAM "AdrOffset8[3][1]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 1 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 1 ));
        PARAM "Bitmask8[3][1]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 1 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 1 ));
        PARAM "AdrOffset8[3][2]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 2 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 2 ));
        PARAM "Bitmask8[3][2]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 2 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 2 ));
        PARAM "AdrOffset8[3][3]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 3 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 3 ));
        PARAM "Bitmask8[3][3]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 3 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 3 ));
        PARAM "AdrOffset8[3][4]"
            uint16
            doc " 16-bit offset to the base address for Page 3 Reg 4 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 4 ));
        PARAM "Bitmask8[3][4]"
            uint8
            doc " 8-bit bit mask for Page 3 Reg 4 "
            present_if(( "Num Pages8" > 3) and ("NumRegs8[3]" > 4 ));
        # Page 4
        PARAM "BaseAddress8[4]"
            uint32
            doc " 32-bit base address for Page 4"
            present_if("Num Pages8" > 4);
        PARAM "NumRegs8[4]"
            uint8
            doc " Number of registers in Page 4"
            min = 1
            max = 5
            present_if("Num Pages8" > 4);
        PARAM "AdrOffset8[4][0]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 0 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 0 ));
        PARAM "Bitmask8[4][0]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 0 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 0 ));
        PARAM "AdrOffset8[4][1]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 1 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 1 ));
        PARAM "Bitmask8[4][1]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 1 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 1 ));
        PARAM "AdrOffset8[4][2]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 2 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 2 ));
        PARAM "Bitmask8[4][2]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 2 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 2 ));
        PARAM "AdrOffset8[4][3]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 3 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 3 ));
        PARAM "Bitmask8[4][3]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 3 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 3 ));
        PARAM "AdrOffset8[4][4]"
            uint16
            doc " 16-bit offset to the base address for Page 4 Reg 4 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 4 ));
        PARAM "Bitmask8[4][4]"
            uint8
            doc " 8-bit bit mask for Page 4 Reg 4 "
            present_if(( "Num Pages8" > 4) and ("NumRegs8[4]" > 4 ));
        # Page 5
        PARAM "BaseAddress8[5]"
            uint32
            doc " 32-bit base address for Page 5"
            present_if("Num Pages8" > 5);
        PARAM "NumRegs8[5]"
            uint8
            doc " Number of registers in Page 5"
            min = 1
            max = 5
            present_if("Num Pages8" > 5);
        PARAM "AdrOffset8[5][0]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 0 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 0 ));
        PARAM "Bitmask8[5][0]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 0 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 0 ));
        PARAM "AdrOffset8[5][1]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 1 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 1 ));
        PARAM "Bitmask8[5][1]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 1 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 1 ));
        PARAM "AdrOffset8[5][2]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 2 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 2 ));
        PARAM "Bitmask8[5][2]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 2 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 2 ));
        PARAM "AdrOffset8[5][3]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 3 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 3 ));
        PARAM "Bitmask8[5][3]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 3 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 3 ));
        PARAM "AdrOffset8[5][4]"
            uint16
            doc " 16-bit offset to the base address for Page 5 Reg 4 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 4 ));
        PARAM "Bitmask8[5][4]"
            uint8
            doc " 8-bit bit mask for Page 5 Reg 4 "
            present_if(( "Num Pages8" > 5) and ("NumRegs8[5]" > 4 ));
        # Page 6
        PARAM "BaseAddress8[6]"
            uint32
            doc " 32-bit base address for Page 6"
            present_if("Num Pages8" > 6);
        PARAM "NumRegs8[6]"
            uint8
            doc " Number of registers in Page 6"
            min = 1
            max = 5
            present_if("Num Pages8" > 6);
        PARAM "AdrOffset8[6][0]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 0 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 0 ));
        PARAM "Bitmask8[6][0]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 0 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 0 ));
        PARAM "AdrOffset8[6][1]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 1 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 1 ));
        PARAM "Bitmask8[6][1]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 1 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 1 ));
        PARAM "AdrOffset8[6][2]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 2 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 2 ));
        PARAM "Bitmask8[6][2]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 2 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 2 ));
        PARAM "AdrOffset8[6][3]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 3 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 3 ));
        PARAM "Bitmask8[6][3]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 3 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 3 ));
        PARAM "AdrOffset8[6][4]"
            uint16
            doc " 16-bit offset to the base address for Page 6 Reg 4 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 4 ));
        PARAM "Bitmask8[6][4]"
            uint8
            doc " 8-bit bit mask for Page 6 Reg 4 "
            present_if(( "Num Pages8" > 6) and ("NumRegs8[6]" > 4 ));
        # Page 7
        PARAM "BaseAddress8[7]"
            uint32
            doc " 32-bit base address for Page 7"
            present_if("Num Pages8" > 7);
        PARAM "NumRegs8[7]"
            uint8
            doc " Number of registers in Page 7"
            min = 1
            max = 5
            present_if("Num Pages8" > 7);
        PARAM "AdrOffset8[7][0]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 0 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 0 ));
        PARAM "Bitmask8[7][0]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 0 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 0 ));
        PARAM "AdrOffset8[7][1]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 1 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 1 ));
        PARAM "Bitmask8[7][1]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 1 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 1 ));
        PARAM "AdrOffset8[7][2]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 2 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 2 ));
        PARAM "Bitmask8[7][2]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 2 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 2 ));
        PARAM "AdrOffset8[7][3]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 3 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 3 ));
        PARAM "Bitmask8[7][3]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 3 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 3 ));
        PARAM "AdrOffset8[7][4]"
            uint16
            doc " 16-bit offset to the base address for Page 7 Reg 4 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 4 ));
        PARAM "Bitmask8[7][4]"
            uint8
            doc " 8-bit bit mask for Page 7 Reg 4 "
            present_if(( "Num Pages8" > 7) and ("NumRegs8[7]" > 4 ));
        #######################################################################
        #
        # 16-BIT PAGE DESCRIPTORS
        #
        #######################################################################
        # Page 0
        PARAM "BaseAddress16[0]"
            uint32
            doc " 32-bit base address for Page 0"
            present_if("Num Pages16" > 0);
        PARAM "NumRegs16[0]"
            uint8
            doc " Number of registers in Page 0"
            min = 1
            max = 5
            present_if("Num Pages16" > 0);
        PARAM "AdrOffset16[0][0]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "Bitmask16[0][0]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 0 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 0 ));
        PARAM "AdrOffset16[0][1]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "Bitmask16[0][1]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 1 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 1 ));
        PARAM "AdrOffset16[0][2]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "Bitmask16[0][2]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 2 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 2 ));
        PARAM "AdrOffset16[0][3]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "Bitmask16[0][3]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 3 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 3 ));
        PARAM "AdrOffset16[0][4]"
            uint16
            doc " 16-bit offset to the base address for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));
        PARAM "Bitmask16[0][4]"
            uint16
            doc " 16-bit bit mask for Page 0 Reg 4 "
            present_if(( "Num Pages16" > 0) and ("NumRegs16[0]" > 4 ));
        # Page 1
        PARAM "BaseAddress16[1]"
            uint32
            doc " 32-bit base address for Page 1"
            present_if("Num Pages16" > 1);
        PARAM "NumRegs16[1]"
            uint8
            doc " Number of registers in Page 1"
            min = 1
            max = 5
            present_if("Num Pages16" > 1);
        PARAM "AdrOffset16[1][0]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 0 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 0 ));
        PARAM "Bitmask16[1][0]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 0 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 0 ));
        PARAM "AdrOffset16[1][1]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 1 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 1 ));
        PARAM "Bitmask16[1][1]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 1 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 1 ));
        PARAM "AdrOffset16[1][2]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 2 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 2 ));
        PARAM "Bitmask16[1][2]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 2 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 2 ));
        PARAM "AdrOffset16[1][3]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 3 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 3 ));
        PARAM "Bitmask16[1][3]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 3 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 3 ));
        PARAM "AdrOffset16[1][4]"
            uint16
            doc " 16-bit offset to the base address for Page 1 Reg 4 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 4 ));
        PARAM "Bitmask16[1][4]"
            uint16
            doc " 16-bit bit mask for Page 1 Reg 4 "
            present_if(( "Num Pages16" > 1) and ("NumRegs16[1]" > 4 ));
        #######################################################################
        # PAGE DATA
        #
        # Legend:
        # Triple Array Indices: [TStep][Page][Reg]
        #######################################################################
        #######################################################################
        #
        # 8-BIT PAGE DATA
        #
        #######################################################################
        # TStep 0
        # Page 0
        PARAM "Data8[0][0][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[0][0][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[0][0][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[0][0][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[0][0][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[0][1][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[0][1][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[0][1][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[0][1][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[0][1][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[0][2][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[0][2][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[0][2][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[0][2][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[0][2][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[0][3][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[0][3][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[0][3][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[0][3][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[0][3][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[0][4][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[0][4][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[0][4][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[0][4][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[0][4][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[0][5][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[0][5][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[0][5][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[0][5][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[0][5][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[0][6][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[0][6][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[0][6][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[0][6][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[0][6][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[0][7][0]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[0][7][1]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[0][7][2]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[0][7][3]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[0][7][4]"
            uint8
            doc " 8-bit data for TStep 0 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 0) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # TStep 1
        # Page 0
        PARAM "Data8[1][0][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[1][0][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[1][0][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[1][0][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[1][0][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[1][1][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[1][1][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[1][1][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[1][1][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[1][1][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[1][2][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[1][2][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[1][2][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[1][2][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[1][2][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[1][3][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[1][3][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[1][3][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[1][3][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[1][3][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[1][4][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[1][4][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[1][4][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[1][4][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[1][4][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[1][5][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[1][5][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[1][5][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[1][5][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[1][5][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[1][6][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[1][6][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[1][6][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[1][6][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[1][6][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[1][7][0]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[1][7][1]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[1][7][2]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[1][7][3]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[1][7][4]"
            uint8
            doc " 8-bit data for TStep 1 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 1) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # TStep 2
        # Page 0
        PARAM "Data8[2][0][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[2][0][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[2][0][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[2][0][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[2][0][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[2][1][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[2][1][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[2][1][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[2][1][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[2][1][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[2][2][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[2][2][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[2][2][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[2][2][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[2][2][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[2][3][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[2][3][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[2][3][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[2][3][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[2][3][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[2][4][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[2][4][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[2][4][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[2][4][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[2][4][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[2][5][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[2][5][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[2][5][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[2][5][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[2][5][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[2][6][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[2][6][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[2][6][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[2][6][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[2][6][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[2][7][0]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[2][7][1]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[2][7][2]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[2][7][3]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[2][7][4]"
            uint8
            doc " 8-bit data for TStep 2 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 2) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # TStep 3
        # Page 0
        PARAM "Data8[3][0][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[3][0][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[3][0][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[3][0][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[3][0][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[3][1][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[3][1][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[3][1][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[3][1][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[3][1][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[3][2][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[3][2][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[3][2][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[3][2][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[3][2][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[3][3][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[3][3][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[3][3][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[3][3][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[3][3][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[3][4][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[3][4][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[3][4][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[3][4][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[3][4][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[3][5][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[3][5][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[3][5][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[3][5][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[3][5][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[3][6][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[3][6][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[3][6][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[3][6][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[3][6][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[3][7][0]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[3][7][1]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[3][7][2]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[3][7][3]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[3][7][4]"
            uint8
            doc " 8-bit data for TStep 3 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 3) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # TStep 4
        # Page 0
        PARAM "Data8[4][0][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[4][0][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[4][0][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[4][0][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[4][0][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[4][1][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[4][1][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[4][1][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[4][1][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[4][1][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[4][2][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[4][2][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[4][2][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[4][2][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[4][2][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[4][3][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[4][3][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[4][3][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[4][3][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[4][3][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[4][4][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[4][4][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[4][4][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[4][4][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[4][4][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[4][5][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[4][5][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[4][5][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[4][5][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[4][5][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[4][6][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[4][6][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[4][6][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[4][6][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[4][6][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[4][7][0]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[4][7][1]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[4][7][2]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[4][7][3]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[4][7][4]"
            uint8
            doc " 8-bit data for TStep 4 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 4) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        # TStep 5
        # Page 0
        PARAM "Data8[5][0][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 0) );
        PARAM "Data8[5][0][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 1) );
        PARAM "Data8[5][0][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 2) );
        PARAM "Data8[5][0][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 3) );
        PARAM "Data8[5][0][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 0 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 0) and ("NumRegs8[0]" > 4) );
        # Page 1
        PARAM "Data8[5][1][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 0) );
        PARAM "Data8[5][1][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 1) );
        PARAM "Data8[5][1][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 2) );
        PARAM "Data8[5][1][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 3) );
        PARAM "Data8[5][1][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 1 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 1) and ("NumRegs8[1]" > 4) );
        # Page 2
        PARAM "Data8[5][2][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 0) );
        PARAM "Data8[5][2][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 1) );
        PARAM "Data8[5][2][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 2) );
        PARAM "Data8[5][2][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 3) );
        PARAM "Data8[5][2][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 2 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 2) and ("NumRegs8[2]" > 4) );
        # Page 3
        PARAM "Data8[5][3][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 0) );
        PARAM "Data8[5][3][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 1) );
        PARAM "Data8[5][3][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 2) );
        PARAM "Data8[5][3][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 3) );
        PARAM "Data8[5][3][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 3 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 3) and ("NumRegs8[3]" > 4) );
        # Page 4
        PARAM "Data8[5][4][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 0) );
        PARAM "Data8[5][4][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 1) );
        PARAM "Data8[5][4][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 2) );
        PARAM "Data8[5][4][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 3) );
        PARAM "Data8[5][4][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 4 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 4) and ("NumRegs8[4]" > 4) );
        # Page 5
        PARAM "Data8[5][5][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 0) );
        PARAM "Data8[5][5][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 1) );
        PARAM "Data8[5][5][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 2) );
        PARAM "Data8[5][5][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 3) );
        PARAM "Data8[5][5][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 5 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 5) and ("NumRegs8[5]" > 4) );
        # Page 6
        PARAM "Data8[5][6][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 0) );
        PARAM "Data8[5][6][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 1) );
        PARAM "Data8[5][6][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 2) );
        PARAM "Data8[5][6][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 3) );
        PARAM "Data8[5][6][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 6 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 6) and ("NumRegs8[6]" > 4) );
        # Page 7
        PARAM "Data8[5][7][0]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 0"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 0) );
        PARAM "Data8[5][7][1]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 1"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 1) );
        PARAM "Data8[5][7][2]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 2"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 2) );
        PARAM "Data8[5][7][3]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 3"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 3) );
        PARAM "Data8[5][7][4]"
            uint8
            doc " 8-bit data for TStep 5 Page 7 Reg 4"
            present_if( ( "Num TSteps" > 5) and ("Num Pages8" > 7) and ("NumRegs8[7]" > 4) );
        #######################################################################
        #
        # 16-BIT PAGE DATA
        #######################################################################
        # TStep 0
        # Page 0
        PARAM "Data16[0][0][0]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 0"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[0][0][1]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 1"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[0][0][2]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 2"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[0][0][3]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 3"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[0][0][4]"
            uint16
            doc " 16-bit data for TStep 0 Page 0 Reg 4"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[0][1][0]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 0"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[0][1][1]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 1"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[0][1][2]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 2"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[0][1][3]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 3"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[0][1][4]"
            uint16
            doc " 16-bit data for TStep 0 Page 1 Reg 4"
            present_if( ("Num TSteps" > 0) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 1
        # Page 0
        PARAM "Data16[1][0][0]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 0"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[1][0][1]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 1"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[1][0][2]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 2"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[1][0][3]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 3"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[1][0][4]"
            uint16
            doc " 16-bit data for TStep 1 Page 0 Reg 4"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[1][1][0]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 0"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[1][1][1]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 1"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[1][1][2]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 2"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[1][1][3]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 3"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[1][1][4]"
            uint16
            doc " 16-bit data for TStep 1 Page 1 Reg 4"
            present_if( ("Num TSteps" > 1) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 2
        # Page 0
        PARAM "Data16[2][0][0]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 0"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[2][0][1]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 1"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[2][0][2]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 2"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[2][0][3]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 3"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[2][0][4]"
            uint16
            doc " 16-bit data for TStep 2 Page 0 Reg 4"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[2][1][0]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 0"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[2][1][1]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 1"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[2][1][2]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 2"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[2][1][3]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 3"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[2][1][4]"
            uint16
            doc " 16-bit data for TStep 2 Page 1 Reg 4"
            present_if( ("Num TSteps" > 2) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 3
        # Page 0
        PARAM "Data16[3][0][0]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 0"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[3][0][1]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 1"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[3][0][2]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 2"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[3][0][3]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 3"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[3][0][4]"
            uint16
            doc " 16-bit data for TStep 3 Page 0 Reg 4"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[3][1][0]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 0"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[3][1][1]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 1"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[3][1][2]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 2"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[3][1][3]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 3"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[3][1][4]"
            uint16
            doc " 16-bit data for TStep 3 Page 1 Reg 4"
            present_if( ("Num TSteps" > 3) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 4
        # Page 0
        PARAM "Data16[4][0][0]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 0"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[4][0][1]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 1"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[4][0][2]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 2"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[4][0][3]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 3"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[4][0][4]"
            uint16
            doc " 16-bit data for TStep 4 Page 0 Reg 4"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[4][1][0]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 0"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[4][1][1]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 1"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[4][1][2]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 2"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[4][1][3]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 3"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[4][1][4]"
            uint16
            doc " 16-bit data for TStep 4 Page 1 Reg 4"
            present_if( ("Num TSteps" > 4) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
        # TStep 5
        # Page 0
        PARAM "Data16[5][0][0]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 0"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 0) );
        PARAM "Data16[5][0][1]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 1"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 1) );
        PARAM "Data16[5][0][2]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 2"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 2) );
        PARAM "Data16[5][0][3]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 3"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 3) );
        PARAM "Data16[5][0][4]"
            uint16
            doc " 16-bit data for TStep 5 Page 0 Reg 4"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 0) and ("NumRegs16[0]" > 4) );
        # Page 1
        PARAM "Data16[5][1][0]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 0"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 0) );
        PARAM "Data16[5][1][1]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 1"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 1) );
        PARAM "Data16[5][1][2]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 2"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 2) );
        PARAM "Data16[5][1][3]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 3"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 3) );
        PARAM "Data16[5][1][4]"
            uint16
            doc " 16-bit data for TStep 5 Page 1 Reg 4"
            present_if( ("Num TSteps" > 5) and ("Num Pages16" > 1) and ("NumRegs16[1]" > 4) );
    }

    COMMAND "SDIO Card Detection Signal" 0x83
    {
        doc "A structure defines the SDIO card detection signal"
        PARAM "Reserved card detection"
            uint8{7:2}
            doc "Reserved SDIO HW feature";

        PARAM "SDIO card detection signals"
            uint8{1:0}
            doc "Select the signals to be used"
            enum
            {
                {0x00, "No card detection"},
                {0x01, "SDIO_D3"},
                {0x02, "GPIO_7"},
                {0x03, "SDIO_D3 and GPIO_7"}
            };
    }

    COMMAND "Sleep Clock Accuracy" 0x84
    {
        doc "LPO clock accuracy in PPM"
        PARAM "PPM"
            uint8
            doc "LPO clock accuracy in PPM, define the accuracy of the LPO clock. It used to calculate"
                "the expected clock drift while using LPO clock.  The default value is 250 PPM.";
    }

    COMMAND "SubR0 Scanning Enable" 0x85
    {
        doc "Enables the SubR0 scanning mode in the firmware"
        PARAM "Enable"
            bool8
            doc "Boolean parameter to enable or disable the subR0 scanning in the core"
                "firmware.  This is set to 0 in the firmware as a default";
    }


    # Config ID overloaded onto the TSSI Configuration
    # from 4350 hdf
    COMMAND "RFP Tuning Configuration" 0x86
    {
        doc "This item contains the configurable values for the"
            "Radio Frequency Performance tuning function to control"
            "for process variation"
        PARAM "RFP_enable"
            uint8
            doc "Enable control"
            bitmap
            {
                { 0x01, "LO Tuning enable" },
                { 0x02, "IQ Tuning enable" },
                { 0x04, "PA Gain tuning enable"}
            };
        PARAM "BCS Periodic enable"
            bool8
            doc "Set to TRUE to enable periodic BCS task";
        PARAM "RSSI Settling time"
            uint8
            doc "Time to allow the RSSI circuit to settle (usec)"
            default = 20;
        PARAM "Boot sample count"
            uint8
            doc "Number of samples in the averaging for RSSI measurements in bootup mode";
        PARAM "Periodic sample count"
            uint8
            doc "Number of samples in the averaging for RSSI measurements in periodic mode";
        # LO Calibration specific
        PARAM "LO calibration search tolerance"
            uint8
            doc "Acceptable final search range for LO";
        PARAM "LO calibration max iterations"
            uint8
            doc "Maximum number of iterations allowed for the calibration";
        PARAM "LO calibration RSSI threshold"
            uint16
            doc "Max RSSI for acceptable calibration";
        PARAM "LO calibration RSSI invalid"
            uint16
            doc "Max RSSI before calibration is rejected";
        PARAM "LO calibration dynamic range adjust"
            int16
            doc "optional factor to increase dynamic range";
        # LO I calibration values
        PARAM "LO calibration for I max iterations"
            uint8
            doc "Max number of iterations for the LO I side";
        PARAM "LO calibration for I initial LOW"
            int16
            doc "Initial LOW endpoint for the LO I binary search";
        PARAM "LO calibration for I initial HIGH"
            int16
            doc "Initial HIGH endpoint for the LO I binary search";
        # LO Q calibration values
        PARAM "LO calibration for Q max iterations"
            uint8
            doc "Max number of iterations for the LO Q side";
        PARAM "LO calibration for Q initial LOW"
            int16
            doc "Initial LOW endpoint for the LO Q binary search";
        PARAM "LO calibration for Q initial HIGH"
            int16
            doc "Initial HIGH endpoint for the LO Q binary search";
        # I/Q Cal specific
        PARAM "IQ calibration RSSI threshold"
            uint16
            doc "Max RSSI for acceptable calibration";
        PARAM "IQ calibration RSSI invalid"
            uint16
            doc "Max RSSI before calibration is rejected";
        PARAM "IQ calibration max iterations"
            uint8
            doc "Maximum number of iterations allowed for the calibration";
        # I/Q Kappa values
        PARAM "IQ calibration for Kappa search tolerance"
            uint8
            doc "Acceptable final search range for IQ Kappa";
        PARAM "IQ calibration for Kappa max iterations"
            uint8
            doc "Maximum number of iterations for IQ Kappa side";
        PARAM "IQ calibration for Kappa initial LOW"
            int8
            doc "Initial LOW endpoint for the IQ Kappa binary search";
        PARAM "IQ calibration for Kappa initial HIGH"
            int8
            doc "Initial HIGH endpoint for the IQ Kappa binary search";
        # I/Q Theta values
        PARAM "IQ calibration for Theta search tolerance"
            uint8
            doc "Acceptable final search range for IQ Theta";
        PARAM "IQ calibration for Theta max iterations"
            uint8
            doc "Maximum number of iterations for IQ Theta side";
        PARAM "IQ calibration for Theta initial LOW"
            int8
            doc "Initial LOW endpoint for the IQ Theta binary search";
        PARAM "IQ calibration for Theta initial HIGH"
            int8
            doc "Initial HIGH endpoint for the IQ Theta binary search";
        # PA Gain calibration specific
        PARAM "PA Gain calibration search tolerance"
            uint8
            doc "Acceptable final search range for PA gain";
        PARAM "PA Gain max iterations"
            uint8
            doc "Maximum number of iterations allowed for the calibration";
        PARAM "PA Gain TSSI output adjust GFSK"
            uint32
            doc "External factor for GFSK TSSI for final optimization after power cal is done (Q22.10)";
        PARAM "PA Gain correction factor GFSK"
            uint32
            doc "Correction factor to compensate for PA variation for GFSK gain calibration (Q22.10)";
        PARAM "PA Gain TSSI output adjust EDR"
            uint32
            doc "External factor for GFSK TSSI for final optimization after power cal is done (Q22.10)";
        PARAM "PA Gain correction factor EDR"
            uint32
            doc "Correction factor to compensate for PA variation for EDR gain calibration (Q22.10)";
        # Operational WRSSI DC Offset values
        PARAM "Operational WRSSI initial offset"
            uint16
            doc "Value to add the WRSSI to force the data into the positive V domain";
        PARAM "Operational WRSSI final offset"
            int16
            doc "Desired final DC offset";
        PARAM "Operational WRSSI offset buffer"
            uint16
            doc "Buffer for margin on computed offset";
        # Sweep mode parameters
        PARAM "PA Gain sweep starting point"
            uint8
            doc "starting point for the sweep";
        PARAM "PA Gain sweep ending point"
            uint8
            doc "ending point for the sweep";
        PARAM "PA gain sweep increment"
            uint8
            doc "PA gain sweep increment";
    }


    COMMAND "AFH Channel Classification Configuration" 0x87
    {
		doc	"Configures various aspect of AFH channel classification behavior"
			"1. How often channel classification algorithm should run"
			"2. How often active RSSI scan should run"

		PARAM "afhccInterval"
			uint8
			doc "Interval between channel classification runs (* 125ms)"
			default = 32;
		PARAM "scanType"
			uint8
            doc "RSSI scan types"
			enum
			{
				{0x00, "Pipelined RSSI Scan"},
				{0x01, "BCI RSSI Scan"}
			}
            default = 0x1;
		PARAM "activeScanInterval"
			uint16
			doc	"Interval in between 2 sequential RSSI scans (* 12.5ms)"
            default = 320;

		PARAM "reclaimCnt"
			uint8
			doc "Number of active scans before a channel can be reclaimed"
			default = 20;
		PARAM "reclaimSnr"
			int8
			doc "The strength of noise has to be reclaimSnr dB lower than receive power for reclaim"
			default = 20;
		PARAM "targetPerGoodSig"
			uint8
			doc "Packet Error Rate (PER) threshold per BT channel under good receive power (/ 255)"
			default = 26;
		PARAM "targetPerWeakSig"
			uint8
			doc "Packet Error Rate (PER) threshold per BT channel under weak receive power (/ 255)"
			default = 102;

		PARAM "wifiThreshold_bg"
			uint8
			doc "Number of 1 MHz channels to declaim the presence of 11bg"
			default = 10;
		PARAM "wifiThreshold_n"
			uint8
			doc "Number of 1 MHz channels to declaim the presence of 11n"
			default = 21;
		PARAM "Threshold_reserved_1"
			uint8
			doc "Number of 1 MHz channels to declaim the presence of ..."
			default = 0;
		PARAM "Threshold_reserved_2"
			uint8
			doc "Number of 1 MHz channels to declaim the presence of ..."
			default = 0;
	}


    COMMAND "SDIO Routing Selection" 0x88
    {
        doc "SDIO Routing Selection"
        PARAM "SDIO Routing"
            uint8
            doc "SDIO Routing Selection to be downloaded from NVRAM only"
            enum
            {
                {0x00, "Default Routing"},
                {0x01, "Alternate GPIO Routing"},
                {0x02, "PCM Routing"}
            };
    }


    COMMAND "UHE Bluetooth Port Secure Product ID" 0x8A
    {
        doc "Bluetooth Port Secure Product ID"
        PARAM "Secure PID"
            uint16
            doc "After the host issues the secure product ID HID control command"
                "(sometime after software install) this PID will be used forever"
                "more.";
    }


    COMMAND "Baseband Crystal Request Enable" 0x8B
    {
        doc "Configures baseband crystal request.  For further information, see"
            "BLUETOOTH + FM COMBO CHIP Programmers Model and Technical Reference,"
            "section 16.19 (cr_wake_int_en_adr)."
        PARAM "GPIO pin number"
            uint32
            doc "Specifies the GPIO pin number for baseband crystal request input (0-7)."
            max = 7;
        PARAM "Wakeup source 1"
            uint32
            doc "Wakeup interrupt source which is enabled in the state where the GPIO"
                "indicates to sleep (see cr_wake_int_en_adr).";
        PARAM "Wakeup source 2"
            uint32
            doc "Wakeup interrupt source which is enabled in the state where the GPIO"
                "indicates to wake up (see cr_wake_int_en_adr).";
        PARAM "Baseband sleep polarity"
            bool8
            doc "Baseband sleep polarity.  If this parameter is 0 (the default value),"
                "then the GPIO input being low indicates to sleep.  If this parameter"
                "is 1, then the GPIO input being high indicates to sleep.";
        PARAM "Enable"
            bool8
            doc "Baseband crystal request enable";
    }


    COMMAND "PLC Configuration" 0x8F
    {
        doc "Configures the PLC audio block parameters"
        PARAM "Logging Control - Connection 0"
            uint8{7}
            doc "Debug Logging control for Connection 0.  Default is 0 - no logging";
        PARAM "Fast Clock Control - Connection 0"
            uint8{6}
            doc "Fast Clock control for Connection 0.  Default is 0 - default clock";
        PARAM "Volume Control - Connection 0"
            uint8{5}
            doc "Volume control for Connection 0.  Default is 0 - no volume";
        PARAM "Equalizer Control for Connection 0"
            uint8{4}
            doc "Equalizer available for Connection 0.  Default is 0 - no eq";
        PARAM "CVSD Hardware Update - Connection 0"
            uint8{3}
            doc "If the HW CVSD is available on Connection 0.  Default is 0 - no update";
        PARAM "PLC Type - Connection 0"
            uint8{2:1}
            doc "The PLC type - None, Full, Low Cost, and BEC on Connection 0.  Default is 1 (full version).";
        PARAM "PLC Enable - Connection 0"
            uint8{0}
            doc "The switch to turn on the PLC on Connection 0.  Default is 0 which is disabled.";
        PARAM "Logging Control - Connection 1"
            uint8{7}
            doc "Debug Logging control for Connection 1.  Default is 0 - no logging";
        PARAM "Fast Clock Control - Connection 1"
            uint8{6}
            doc "Fast Clock control for Connection 1.  Default is 0 - default clock";
        PARAM "Volume Control - Connection 1"
            uint8{5}
            doc "Volume control for Connection 1.  Default is 0 - no volume";
        PARAM "Equalizer Control for Connection 1"
            uint8{4}
            doc "Equalizer available for Connection 1.  Default is 0 - no eq";
        PARAM "CVSD Hardware Update - Connection 1"
            uint8{3}
            doc "If the HW CVSD is available on Connection 1.  Default is 0 - no update";
        PARAM "PLC Type - Connection 1"
            uint8{2:1}
            doc "The PLC type - None, Full, Low Cost, and BEC on Connection 1.  Default is 1 (full version).";
        PARAM "PLC Enable - Connection 1"
            uint8{0}
            doc "The switch to turn on the PLC on Connection 1.  Default is 0 which is disabled.";
        PARAM "Logging Control - Connection 2"
            uint8{7}
            doc "Debug Logging control for Connection 2.  Default is 0 - no logging";
        PARAM "Fast Clock Control - Connection 2"
            uint8{6}
            doc "Fast Clock control for Connection 2.  Default is 0 - default clock";
        PARAM "Volume Control - Connection 2"
            uint8{5}
            doc "Volume control for Connection 2.  Default is 0 - no volume";
        PARAM "Equalizer Control for Connection 2"
            uint8{4}
            doc "Equalizer available for Connection 2.  Default is 0 - no eq";
        PARAM "CVSD Hardware Update - Connection 2"
            uint8{3}
            doc "If the HW CVSD is available on Connection 2.  Default is 0 - no update";
        PARAM "PLC Type - Connection 2"
            uint8{2:1}
            doc "The PLC type - None, Full, Low Cost, and BEC on Connection 2.  Default is 1 (full version).";
        PARAM "PLC Enable - Connection 2"
            uint8{0}
            doc "The switch to turn on the PLC on Connection 2.  Default is 0 which is disabled.";
    }


    COMMAND "HCI LM LC Specific Requests" 0x90
    {
        doc "This item is to enable/disable some customer specific features"
            "that fall in HCI, LM or LC category."
        PARAM "CS config flags"
            uint32
            doc "General customer specific config bitmap."
            bitmap
            {
                {0x00000001, "Disable sending authentication failure event to host"},
                {0x00000002, "Send three sco complete events when enter local loopback mode"},
                {0x00000004, "Enable extra paramters for hci read clock command"},
                {0x00000008, "Enable BQB Support"},
                {0x00000010, "Enable small SCO buffers"},
                {0x00000020, "Enable Return Missing if PIN Request Negative"},
                {0x00000040, "Enable AFH Block WLAN Channels only"}
            };
    }


    COMMAND "MTBS Configuration" 0x91
    {
        doc "Selects a particular input pin for Mobile Tagged Bluetooth Scan (MTBS)"
        PARAM "Enable MTBS"
            uint8
            doc "MTBS Enable / Disable"
            enum
            {
                 {0x0, "MTBS Disable"},
                 {0x1, "MTBS Enable"}
            };
        PARAM "MTBS Input Pin"
            uint8
            doc "MTBS input pin selection"
            enum
            {
                 {0x0, "MTBS_PIN_GPIO_0"},
                 {0x1, "MTBS_PIN_GPIO_1"},
                 {0x2, "MTBS_PIN_GPIO_2"},
                 {0x3, "MTBS_PIN_GPIO_6"}
            };
        PARAM "Reserved MTBS"
            uint8{7:3}
            doc "Reserved MTBS";
        PARAM "MTBS input pin active state"
            uint8{2:2}
            doc "MTBS input pin active state"
            enum
            {
                 {0x0, "MTBS_PIN_ACTIVE_LOW"},
                 {0x1, "MTBS_PIN_ACTIVE_HIGH"}
            };

        PARAM "MTBS mode"
            uint8{1:0}
            doc "MTBS mode"
            enum
            {
                {0x0, "DONT_PERFORM_SCHEDULED_SCANS"},
                {0x1, "PERFORM_SCHEDULED_SCANS"},
                {0x2, "PERFORM_SCHEDULED_SCANS_WITH_MTBS_EST1"},
                {0x3, "PERFORM_SCHEDULED_SCANS_WITH_MTBS_EST2"}
            };
    }


    COMMAND "BFC Configuration" 0x92
    {
        doc "Broadcom Fast Connect (BFC) configuration"
        PARAM "Reserved"
            uint16{15:10}
            doc "Reserved BFC configuration";

        PARAM "Storage Type"
            uint16{9:7}
            doc "storage type"
            enum
            {
                {0x00, "none"},
                {0x01, "VSE"},
                {0x02, "NVRAM"}
            };
        PARAM "Fast Connect Method"
            uint16{6:4}
            doc "fast connect method"
            enum
            {
                {0x00, "none"},
                {0x01, "LE"},
                {0x02, "TBFC"}
            };
        PARAM "Enc After Reconnect"
            uint16{3:3}
            doc "Restart Encryption After Reconnect"
            enum
            {
                {0x00, "No"},
                {0x01, "Yes"}
            };
        PARAM "Auth After Reconnect"
            uint16{2:2}
            doc "Restart Authentication After Reconnect"
            enum
            {
                {0x00, "No"},
                {0x01, "Yes"}
            };
        PARAM "Rapid Reconnect Support"
            uint16{1:1}
            doc "Rapid Reconnect Support"
            enum
            {
                {0x00, "No"},
                {0x01, "Yes"}
            };
        PARAM "BFC Enable"
            uint16{0:0}
            doc "BFC supported"
	        enum
	        {
	            {0x00, "No"},
		        {0x01, "Yes"}
	        };
        PARAM "Reconnect Timeout"
            uint16
            doc "Reconnect Timeout";
        PARAM "Scan Window"
            uint8
            doc "Scan Window";
        PARAM "Scan Interval"
            uint8
            doc "Scan Interval";
    }


    COMMAND "PC Workarounds" 0x93
    {
        doc "This item is to enable/disable a variety of features and workarounds"
            "for the PC programs."
        PARAM "PC Workaround flags"
            uint16
            doc "PC workaround enable flags"
                "  0001: Send extra HCI event credit on enumeration.  Vista race condition between usb and BT drivers"
                "         will sometimes halt usb endpoint before BT stack is over and we lose a command complete"
                "  0002: Avoid back to back 5 slot packets after sniff rx.  (see below)"
                "  0004: Don't set AFH instant to less than 1.5 seconds.  2042 KB only responds every 500 ms in "
                "        fake sniff subrating mode, so we need to make sure it gets the set_afh before the instant."
                "  0008: Don't send lmp detach with a pending AFH instant.  Pause the LMP until AFH instant passes."
                "        2040 HIDs have AFH failures when detaching with pending AFH instant."
                "  0010: Delay entering sleep (see below)"
                "  0020: Insert silence for transparent encoded SCO"
                "  0040: Custom scheduling LRM adaptation for multislot HIDs.  Allocate additional frames between"
                "        sniff connections if HID supports multislot packets.  Also, schedule multislot HIDs after single"
                "        slot HIDs."
                "  0080: Return slotOffset=1249 whenever slotOfffset=0 during MSS to workaround 2042 HIDs issue."
                "  0100: Unsniffs Sniffed Master connections when a sniffed connection becomes active or "
                "        When a sco is added or removed to re-pack the sniff connections."
                "  0200: Disables the support for USB MSFT OS descriptors to avoid loading MSFT driver"
                "  0400: Enables the USB resume duration to be set from the configuration"
                "  0800: Auto-unsniff Enhancements"
                "  1000: Unused"
                "  2000: Enable dynamic LNA RSSI setting"
            bitmap
            {
                {0x0001, "Send extra HCI event credit on enumeration"},
                {0x0002, "Enable long AFH instant"},
                {0x0004, "Avoid detach with pending AFH instant"},
                {0x0008, "Avoid 5 slot packets in sniff"},
                {0x0010, "Enable delay entering sleep"},
                {0x0020, "Enable transparent encoded SCO silence"},
                {0x0040, "Multislot HID Scheduling"},
                {0x0080, "MSS SlotOffset 0 Issue"},
                {0x0100, "Enable auto unsniff feature"},
                {0x0200, "Disable USB MSFT OS descriptor support"},
                {0x0400, "Enable USB Resume Duration"},
                {0x0800, "Auto-Unsniff Enhancements"},
                {0x1000, "Unused"},
                {0x2000, "Enable Dynamic LNA RSSI Setting"}
            }
            default = 0x0001;
        PARAM "Avoid 5 slot packets"
            uint8
            doc "DEPRECATED! Do not send back to back 5 slot packets immediately after hearing from a sniff link."
                "The value is the number of slots to wait after a sniff response before allowing 5 slot packets "
                "again.  2042 KB will disconnect when its master link transmits two 5 slot packets to anyone "
                "right after responding on a fake sniff subrating 500ms interval.  80 is currently used."
            enabled_if ( ("PC Workaround flags" & 0x0008)=0x0008);
        PARAM "Delay entering sleep"
            uint8
            doc "Delay entering USB sleep.  Value is amount to insert into pmu_slpModeIdleThresholdFactor table."
                "Current workaround uses 24 which delays sleep by a couple seconds.  2042 KB clock doesn't allow"
                "clock drift during transition to HID sleep stage, so we can't immediately switch to LPO."
            enabled_if ( ("PC Workaround flags" & 0x0010)=0x0010);
        PARAM "Enable USB Resume Duration"
            uint8
            doc "Enable the USB resume duration to be set by the configuration."
            enabled_if ( ("PC Workaround flags" & 0x0400)=0x0400);

        PARAM "Reserved8"
            uint8
            doc "Reserved for future purpose";

        PARAM "Reserved16"
            uint16
            doc "Reserved for future purpose";

        PARAM "PC Workaround extended flags"
            uint32
            doc "PC workaround extended enable flags"
                "  00000002: Send Gone Event to the host for all the tracked sensors upon LE scan disable"
            bitmap
            {
                {0x00000002, "Send Gone even on LE scan disable"}
            }
        default = 0x00000000;

    }


    COMMAND "WiMAX Configuration" 0x94
    {
        doc "A structure defines coexistant WiMAX to be used"
        PARAM "Type"
		uint8
              doc "Select WiMAX Type to be used"
              enum
              {
		{0x00, "No WiMAX"},
                {0x01, "WiMAX relaxed mode"},
                {0x02, "WiMAX maximum mode"}
              };
    }


    COMMAND "BLE ACL Pool Configuration" 0x97
    {
        doc "This item is to configure Bluetooth Low Energy (BLE) ACL data link down and up buffer"
                   "management. Used together with Bluetooth's ACL Pool Configuration to sepearte the"
                   "ACL down buffer between Bluetooth and BLE ACL links."
        PARAM "BLE Host claim ACL down payload size"
            uint16
            doc "The ACL buffer size (payload only) claimed to the host in response to"
                "LE_Read_Buffer_Size. The default value is 27.";
        PARAM "BLE ACL down buffer size"
            uint16
            doc "The actual size of ACL down buffers (host to device direction), including header."
                "The default value is 32.";
        PARAM "BLE ACL up buffer size"
            uint16
            doc "The actual size of ACL up buffers (device to host direction), including header and"
                "internal transport prefix structures. The default value is 40.";
        PARAM "BLE Host claim ACL down payload count"
            uint8
            doc "The ACL buffer count claimed to the host in response to Read_Buffer_Size. The"
                "default value is 15.";
        PARAM "BLE ACL down buffer count"
            uint8
            doc "The actual number of ACL down buffers (host to device direction). The default"
                "value is 15.";
        PARAM "BLE ACL up buffer count"
            uint8
            doc "The actual number of ACL up buffers (device to host direction). The default value"
                "is 15.";
    }


    COMMAND "Config-Download-to-RAM Flags" 0x98
    {
        doc "The flags related to Config-Download-to-RAM feature"
        PARAM "Config-Download-to-RAM Flags"
            uint8
            doc "Config-Download-to-RAM Flags"
                "  01: Do not Re-enumerate USB transport after config download to RAM"
                "  02: Send a VSE after config download to RAM. The controller will"
                "      be ready to receive commands after sending this VSE."
                "  04: Unused"
                "  08: Unused"
                "  10: Unused"
                "  20: Unused"
                "  40: Unused"
                "  80: Unused"
            bitmap
            {
                {0x01, "Do not Re-enumerate after config download to RAM"},
                {0x02, "Send a VSE after config download to RAM"},
                {0x04, "Unused"},
                {0x08, "Unused"},
                {0x10, "Unused"},
                {0x20, "Unused"},
                {0x40, "Unused"},
                {0x80, "Unused"}
            };
    }


    COMMAND "CPU Clock" 0x99
    {
        doc "CPU Clock."
        PARAM "Clock"
            uint8
            doc "CPU Clock"
            enum
            {
                {0x0, "48 MHz"},
                {0x1, "32 MHz"},
                {0x2, "24 MHz"},
                {0x3, "16 MHz"},
                {0x4, "12 MHz"},
                {0x5, "6 MHz"},
                {0x6, "4 MHz"},
                {0x7, "1 MHz"}
            };
    }


    COMMAND "External Memory Read Wait State" 0x9A
    {
        doc "External Memory Read Wait State."
        PARAM "Wait State"
            uint8
            doc "External Memory Read Wait State"
            max = 3;
    }


    COMMAND "TV APPLICATION" 0x9B
    {
        doc "This item is used to enable/disable TV application features."
        PARAM "BRR features"
            uint32
            doc "BRR features"
            bitmap
            {
                {0x00000001, "Enable BRR feature"},
                {0x00000002, "BRR feature duplicate connection"},
                {0x00000004, "BRR feature link supervision TO"},
                {0x00000008, "BRR feature Tpoll"},
                {0x00000010, "BRR feature connection priority"},
                {0x00000020, "BRR feature scan backoff"},
                {0x00000040, "BRR feature scan align"},
                {0x00000080, "BRR feature tighten interlaced scans"},
                {0x00000100, "BRR feature a2dp scheduled immediately"},
                {0x00000200, "BRR feature change scan frequency"}
            };
        PARAM "TV host standby status"
            uint8
            doc "TV host standby status";
    }


    COMMAND "Application Selection" 0x9C
    {
        doc "Application Selection."
        PARAM "Application in Use"
            uint8
            doc "Application in Use."
            enum
            {
                {0x00, "UHE"},
                {0x01, "Nintendo"},
                {0x10, "ThreeD TV Application"},
                {0x11, "ThreeD PC Application"}
            };
    }


    COMMAND "3D Parameters" 0x9D
    {
        doc "3D Parameters."
        PARAM "Duty Cycle"
            uint32
            doc "Duty cycle to be used";
        PARAM "Shutter Delay Clk"
            uint32
            doc "Shutter Delay Clk";
        PARAM "Shutter Delay PClk"
            uint32
            doc "Shutter Delay PClk";
        PARAM "Mode in Use"
            uint8
            doc "Mode in Use."
            enum
            {
                {0x00, "debugging mode"},
                {0x01, "full control mode"},
                {0x10, "hostless mode"}
            };
    }


    COMMAND "DBFW Init" 0x9E
    {
        doc "DBFW Init"
        PARAM "Module Mask"
            uint32
            doc "Module Mask, default = 0x7FFFFFFF";
        PARAM "Push Time Out"
            uint16
            doc "unit = ms, default = 100";
        PARAM "Trace Wartermark"
            uint16
            doc "default = 8";
         PARAM "Trace Format Version"
            uint8
            doc "default = 1 - don't change it";
         PARAM "Coredump Format Version"
            uint8
            doc "default = 1 - don't change it";
         PARAM "Trace Level"
            uint8
            doc "0 - debug, 1 - info, 2 - warning, 3 - critical, default = 3";
        PARAM "Trace Mode"
            uint8
            doc "0x00 - STOP, 0x10 - POLL, 0x20 - PUSH, default = 0x00";
        PARAM "Trace Flow"
            uint8
            doc "0 - STOP when queue is full, 1 - Overwrite when queue is full, default = 1";
        PARAM "Tracedump Output Channel"
            uint8
            doc "0 - HCI, 1 - DBUART in Binary, 2 - DBUART in ASCII, 3 - GPS NPE, default = 0";
        PARAM "Stackdump Output Channel"
            uint8
            doc "0 - HCI, 1 - DBUART in Binary, 2 - DBUART in ASCII, 3 - GPS NPE, default = 0";
        PARAM "Coredump Output Channel"
            uint8
            doc "0 - HCI, 1 - DBUART in Binary, 2 - DBUART in ASCII, 3 - GPS NPE, default = 0";
    }

    COMMAND "Init BB Register Bit Fields" 0xC0
    {
        doc "This item is used to overwrite the selected bit fields of the "
            "BB register default values during firmware initialization."
        PARAM "Num entries"
            uint8
            doc "An abstract parameter used only for encoding purposes, not present in the"
                "actual configuration item. When encoding the configuration item, determines"
                "the number of address/mask/value entries to include."
            not_in_binary_message
            decode_value = 0                                    # Can only decode, not encode
            max = 128;
        PARAM "Register address[0]"
            uint32
            doc "Address of the baseband register"
            present_if ("Num entries" > 0);
        PARAM "Bit field mask[0]"
            uint32
            doc "Bit field mask. If a bit is 1 that bit value will be changed to the new value"
                "specified"
            present_if ("Num entries" > 0);
        PARAM "Value[0]"
            uint32
            doc "Data to be written to the baseband register"
            present_if ("Num entries" > 0);
        PARAM "Register address[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Bit field mask[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Value[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Register address[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Bit field mask[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Value[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Register address[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Bit field mask[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Value[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Register address[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Bit field mask[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Value[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Register address[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Bit field mask[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Value[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Register address[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Bit field mask[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Value[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Register address[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Bit field mask[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Value[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Register address[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Bit field mask[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Value[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Register address[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Bit field mask[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Value[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Register address[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Bit field mask[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Value[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Register address[11]"
            uint32
            present_if ("Num entries" > 11);
        PARAM "Bit field mask[11]"
            uint32
            present_if ("Num entries" > 11);
        PARAM "Value[11]"
            uint32
            present_if ("Num entries" > 11);
        PARAM "Register address[12]"
            uint32
            present_if ("Num entries" > 12);
        PARAM "Bit field mask[12]"
            uint32
            present_if ("Num entries" > 12);
        PARAM "Value[12]"
            uint32
            present_if ("Num entries" > 12);
        PARAM "Register address[13]"
            uint32
            present_if ("Num entries" > 13);
        PARAM "Bit field mask[13]"
            uint32
            present_if ("Num entries" > 13);
        PARAM "Value[13]"
            uint32
            present_if ("Num entries" > 13);
        PARAM "Register address[14]"
            uint32
            present_if ("Num entries" > 14);
        PARAM "Bit field mask[14]"
            uint32
            present_if ("Num entries" > 14);
        PARAM "Value[14]"
            uint32
            present_if ("Num entries" > 14);
        PARAM "Register address[15]"
            uint32
            present_if ("Num entries" > 15);
        PARAM "Bit field mask[15]"
            uint32
            present_if ("Num entries" > 15);
        PARAM "Value[15]"
            uint32
            present_if ("Num entries" > 15);
        PARAM "Register address[16]"
            uint32
            present_if ("Num entries" > 16);
        PARAM "Bit field mask[16]"
            uint32
            present_if ("Num entries" > 16);
        PARAM "Value[16]"
            uint32
            present_if ("Num entries" > 16);
        PARAM "Register address[17]"
            uint32
            present_if ("Num entries" > 17);
        PARAM "Bit field mask[17]"
            uint32
            present_if ("Num entries" > 17);
        PARAM "Value[17]"
            uint32
            present_if ("Num entries" > 17);
        PARAM "Register address[18]"
            uint32
            present_if ("Num entries" > 18);
        PARAM "Bit field mask[18]"
            uint32
            present_if ("Num entries" > 18);
        PARAM "Value[18]"
            uint32
            present_if ("Num entries" > 18);
        PARAM "Register address[19]"
            uint32
            present_if ("Num entries" > 19);
        PARAM "Bit field mask[19]"
            uint32
            present_if ("Num entries" > 19);
        PARAM "Value[19]"
            uint32
            present_if ("Num entries" > 19);
        PARAM "Register address[20]"
            uint32
            present_if ("Num entries" > 20);
        PARAM "Bit field mask[20]"
            uint32
            present_if ("Num entries" > 20);
        PARAM "Value[20]"
            uint32
            present_if ("Num entries" > 20);
        PARAM "Register address[21]"
            uint32
            present_if ("Num entries" > 21);
        PARAM "Bit field mask[21]"
            uint32
            present_if ("Num entries" > 21);
        PARAM "Value[21]"
            uint32
            present_if ("Num entries" > 21);
        PARAM "Register address[22]"
            uint32
            present_if ("Num entries" > 22);
        PARAM "Bit field mask[22]"
            uint32
            present_if ("Num entries" > 22);
        PARAM "Value[22]"
            uint32
            present_if ("Num entries" > 22);
        PARAM "Register address[23]"
            uint32
            present_if ("Num entries" > 23);
        PARAM "Bit field mask[23]"
            uint32
            present_if ("Num entries" > 23);
        PARAM "Value[23]"
            uint32
            present_if ("Num entries" > 23);
        PARAM "Register address[24]"
            uint32
            present_if ("Num entries" > 24);
        PARAM "Bit field mask[24]"
            uint32
            present_if ("Num entries" > 24);
        PARAM "Value[24]"
            uint32
            present_if ("Num entries" > 24);
        PARAM "Register address[25]"
            uint32
            present_if ("Num entries" > 25);
        PARAM "Bit field mask[25]"
            uint32
            present_if ("Num entries" > 25);
        PARAM "Value[25]"
            uint32
            present_if ("Num entries" > 25);
        PARAM "Register address[26]"
            uint32
            present_if ("Num entries" > 26);
        PARAM "Bit field mask[26]"
            uint32
            present_if ("Num entries" > 26);
        PARAM "Value[26]"
            uint32
            present_if ("Num entries" > 26);
        PARAM "Register address[27]"
            uint32
            present_if ("Num entries" > 27);
        PARAM "Bit field mask[27]"
            uint32
            present_if ("Num entries" > 27);
        PARAM "Value[27]"
            uint32
            present_if ("Num entries" > 27);
        PARAM "Register address[28]"
            uint32
            present_if ("Num entries" > 28);
        PARAM "Bit field mask[28]"
            uint32
            present_if ("Num entries" > 28);
        PARAM "Value[28]"
            uint32
            present_if ("Num entries" > 28);
        PARAM "Register address[29]"
            uint32
            present_if ("Num entries" > 29);
        PARAM "Bit field mask[29]"
            uint32
            present_if ("Num entries" > 29);
        PARAM "Value[29]"
            uint32
            present_if ("Num entries" > 29);
        PARAM "Register address[30]"
            uint32
            present_if ("Num entries" > 30);
        PARAM "Bit field mask[30]"
            uint32
            present_if ("Num entries" > 30);
        PARAM "Value[30]"
            uint32
            present_if ("Num entries" > 30);
        PARAM "Register address[31]"
            uint32
            present_if ("Num entries" > 31);
        PARAM "Bit field mask[31]"
            uint32
            present_if ("Num entries" > 31);
        PARAM "Value[31]"
            uint32
            present_if ("Num entries" > 31);
        PARAM "Register address[32]"
            uint32
            present_if ("Num entries" > 32);
        PARAM "Bit field mask[32]"
            uint32
            present_if ("Num entries" > 32);
        PARAM "Value[32]"
            uint32
            present_if ("Num entries" > 32);
        PARAM "Register address[33]"
            uint32
            present_if ("Num entries" > 33);
        PARAM "Bit field mask[33]"
            uint32
            present_if ("Num entries" > 33);
        PARAM "Value[33]"
            uint32
            present_if ("Num entries" > 33);
        PARAM "Register address[34]"
            uint32
            present_if ("Num entries" > 34);
        PARAM "Bit field mask[34]"
            uint32
            present_if ("Num entries" > 34);
        PARAM "Value[34]"
            uint32
            present_if ("Num entries" > 34);
        PARAM "Register address[35]"
            uint32
            present_if ("Num entries" > 35);
        PARAM "Bit field mask[35]"
            uint32
            present_if ("Num entries" > 35);
        PARAM "Value[35]"
            uint32
            present_if ("Num entries" > 35);
        PARAM "Register address[36]"
            uint32
            present_if ("Num entries" > 36);
        PARAM "Bit field mask[36]"
            uint32
            present_if ("Num entries" > 36);
        PARAM "Value[36]"
            uint32
            present_if ("Num entries" > 36);
        PARAM "Register address[37]"
            uint32
            present_if ("Num entries" > 37);
        PARAM "Bit field mask[37]"
            uint32
            present_if ("Num entries" > 37);
        PARAM "Value[37]"
            uint32
            present_if ("Num entries" > 37);
        PARAM "Register address[38]"
            uint32
            present_if ("Num entries" > 38);
        PARAM "Bit field mask[38]"
            uint32
            present_if ("Num entries" > 38);
        PARAM "Value[38]"
            uint32
            present_if ("Num entries" > 38);
        PARAM "Register address[39]"
            uint32
            present_if ("Num entries" > 39);
        PARAM "Bit field mask[39]"
            uint32
            present_if ("Num entries" > 39);
        PARAM "Value[39]"
            uint32
            present_if ("Num entries" > 39);
        PARAM "Register address[40]"
            uint32
            present_if ("Num entries" > 40);
        PARAM "Bit field mask[40]"
            uint32
            present_if ("Num entries" > 40);
        PARAM "Value[40]"
            uint32
            present_if ("Num entries" > 40);
        PARAM "Register address[41]"
            uint32
            present_if ("Num entries" > 41);
        PARAM "Bit field mask[41]"
            uint32
            present_if ("Num entries" > 41);
        PARAM "Value[41]"
            uint32
            present_if ("Num entries" > 41);
        PARAM "Register address[42]"
            uint32
            present_if ("Num entries" > 42);
        PARAM "Bit field mask[42]"
            uint32
            present_if ("Num entries" > 42);
        PARAM "Value[42]"
            uint32
            present_if ("Num entries" > 42);
        PARAM "Register address[43]"
            uint32
            present_if ("Num entries" > 43);
        PARAM "Bit field mask[43]"
            uint32
            present_if ("Num entries" > 43);
        PARAM "Value[43]"
            uint32
            present_if ("Num entries" > 43);
        PARAM "Register address[44]"
            uint32
            present_if ("Num entries" > 44);
        PARAM "Bit field mask[44]"
            uint32
            present_if ("Num entries" > 44);
        PARAM "Value[44]"
            uint32
            present_if ("Num entries" > 44);
        PARAM "Register address[45]"
            uint32
            present_if ("Num entries" > 45);
        PARAM "Bit field mask[45]"
            uint32
            present_if ("Num entries" > 45);
        PARAM "Value[45]"
            uint32
            present_if ("Num entries" > 45);
        PARAM "Register address[46]"
            uint32
            present_if ("Num entries" > 46);
        PARAM "Bit field mask[46]"
            uint32
            present_if ("Num entries" > 46);
        PARAM "Value[46]"
            uint32
            present_if ("Num entries" > 46);
        PARAM "Register address[47]"
            uint32
            present_if ("Num entries" > 47);
        PARAM "Bit field mask[47]"
            uint32
            present_if ("Num entries" > 47);
        PARAM "Value[47]"
            uint32
            present_if ("Num entries" > 47);
        PARAM "Register address[48]"
            uint32
            present_if ("Num entries" > 48);
        PARAM "Bit field mask[48]"
            uint32
            present_if ("Num entries" > 48);
        PARAM "Value[48]"
            uint32
            present_if ("Num entries" > 48);
        PARAM "Register address[49]"
            uint32
            present_if ("Num entries" > 49);
        PARAM "Bit field mask[49]"
            uint32
            present_if ("Num entries" > 49);
        PARAM "Value[49]"
            uint32
            present_if ("Num entries" > 49);
        PARAM "Register address[50]"
            uint32
            present_if ("Num entries" > 50);
        PARAM "Bit field mask[50]"
            uint32
            present_if ("Num entries" > 50);
        PARAM "Value[50]"
            uint32
            present_if ("Num entries" > 50);
        PARAM "Register address[51]"
            uint32
            present_if ("Num entries" > 51);
        PARAM "Bit field mask[51]"
            uint32
            present_if ("Num entries" > 51);
        PARAM "Value[51]"
            uint32
            present_if ("Num entries" > 51);
        PARAM "Register address[52]"
            uint32
            present_if ("Num entries" > 52);
        PARAM "Bit field mask[52]"
            uint32
            present_if ("Num entries" > 52);
        PARAM "Value[52]"
            uint32
            present_if ("Num entries" > 52);
        PARAM "Register address[53]"
            uint32
            present_if ("Num entries" > 53);
        PARAM "Bit field mask[53]"
            uint32
            present_if ("Num entries" > 53);
        PARAM "Value[53]"
            uint32
            present_if ("Num entries" > 53);
        PARAM "Register address[54]"
            uint32
            present_if ("Num entries" > 54);
        PARAM "Bit field mask[54]"
            uint32
            present_if ("Num entries" > 54);
        PARAM "Value[54]"
            uint32
            present_if ("Num entries" > 54);
        PARAM "Register address[55]"
            uint32
            present_if ("Num entries" > 55);
        PARAM "Bit field mask[55]"
            uint32
            present_if ("Num entries" > 55);
        PARAM "Value[55]"
            uint32
            present_if ("Num entries" > 55);
        PARAM "Register address[56]"
            uint32
            present_if ("Num entries" > 56);
        PARAM "Bit field mask[56]"
            uint32
            present_if ("Num entries" > 56);
        PARAM "Value[56]"
            uint32
            present_if ("Num entries" > 56);
        PARAM "Register address[57]"
            uint32
            present_if ("Num entries" > 57);
        PARAM "Bit field mask[57]"
            uint32
            present_if ("Num entries" > 57);
        PARAM "Value[57]"
            uint32
            present_if ("Num entries" > 57);
        PARAM "Register address[58]"
            uint32
            present_if ("Num entries" > 58);
        PARAM "Bit field mask[58]"
            uint32
            present_if ("Num entries" > 58);
        PARAM "Value[58]"
            uint32
            present_if ("Num entries" > 58);
        PARAM "Register address[59]"
            uint32
            present_if ("Num entries" > 59);
        PARAM "Bit field mask[59]"
            uint32
            present_if ("Num entries" > 59);
        PARAM "Value[59]"
            uint32
            present_if ("Num entries" > 59);
        PARAM "Register address[60]"
            uint32
            present_if ("Num entries" > 60);
        PARAM "Bit field mask[60]"
            uint32
            present_if ("Num entries" > 60);
        PARAM "Value[60]"
            uint32
            present_if ("Num entries" > 60);
        PARAM "Register address[61]"
            uint32
            present_if ("Num entries" > 61);
        PARAM "Bit field mask[61]"
            uint32
            present_if ("Num entries" > 61);
        PARAM "Value[61]"
            uint32
            present_if ("Num entries" > 61);
        PARAM "Register address[62]"
            uint32
            present_if ("Num entries" > 62);
        PARAM "Bit field mask[62]"
            uint32
            present_if ("Num entries" > 62);
        PARAM "Value[62]"
            uint32
            present_if ("Num entries" > 62);
        PARAM "Register address[63]"
            uint32
            present_if ("Num entries" > 63);
        PARAM "Bit field mask[63]"
            uint32
            present_if ("Num entries" > 63);
        PARAM "Value[63]"
            uint32
            present_if ("Num entries" > 63);
        PARAM "Register address[64]"
            uint32
            present_if ("Num entries" > 64);
        PARAM "Bit field mask[64]"
            uint32
            present_if ("Num entries" > 64);
        PARAM "Value[64]"
            uint32
            present_if ("Num entries" > 64);
        PARAM "Register address[65]"
            uint32
            present_if ("Num entries" > 65);
        PARAM "Bit field mask[65]"
            uint32
            present_if ("Num entries" > 65);
        PARAM "Value[65]"
            uint32
            present_if ("Num entries" > 65);
        PARAM "Register address[66]"
            uint32
            present_if ("Num entries" > 66);
        PARAM "Bit field mask[66]"
            uint32
            present_if ("Num entries" > 66);
        PARAM "Value[66]"
            uint32
            present_if ("Num entries" > 66);
        PARAM "Register address[67]"
            uint32
            present_if ("Num entries" > 67);
        PARAM "Bit field mask[67]"
            uint32
            present_if ("Num entries" > 67);
        PARAM "Value[67]"
            uint32
            present_if ("Num entries" > 67);
        PARAM "Register address[68]"
            uint32
            present_if ("Num entries" > 68);
        PARAM "Bit field mask[68]"
            uint32
            present_if ("Num entries" > 68);
        PARAM "Value[68]"
            uint32
            present_if ("Num entries" > 68);
        PARAM "Register address[69]"
            uint32
            present_if ("Num entries" > 69);
        PARAM "Bit field mask[69]"
            uint32
            present_if ("Num entries" > 69);
        PARAM "Value[69]"
            uint32
            present_if ("Num entries" > 69);
        PARAM "Register address[70]"
            uint32
            present_if ("Num entries" > 70);
        PARAM "Bit field mask[70]"
            uint32
            present_if ("Num entries" > 70);
        PARAM "Value[70]"
            uint32
            present_if ("Num entries" > 70);
        PARAM "Register address[71]"
            uint32
            present_if ("Num entries" > 71);
        PARAM "Bit field mask[71]"
            uint32
            present_if ("Num entries" > 71);
        PARAM "Value[71]"
            uint32
            present_if ("Num entries" > 71);
        PARAM "Register address[72]"
            uint32
            present_if ("Num entries" > 72);
        PARAM "Bit field mask[72]"
            uint32
            present_if ("Num entries" > 72);
        PARAM "Value[72]"
            uint32
            present_if ("Num entries" > 72);
        PARAM "Register address[73]"
            uint32
            present_if ("Num entries" > 73);
        PARAM "Bit field mask[73]"
            uint32
            present_if ("Num entries" > 73);
        PARAM "Value[73]"
            uint32
            present_if ("Num entries" > 73);
        PARAM "Register address[74]"
            uint32
            present_if ("Num entries" > 74);
        PARAM "Bit field mask[74]"
            uint32
            present_if ("Num entries" > 74);
        PARAM "Value[74]"
            uint32
            present_if ("Num entries" > 74);
        PARAM "Register address[75]"
            uint32
            present_if ("Num entries" > 75);
        PARAM "Bit field mask[75]"
            uint32
            present_if ("Num entries" > 75);
        PARAM "Value[75]"
            uint32
            present_if ("Num entries" > 75);
        PARAM "Register address[76]"
            uint32
            present_if ("Num entries" > 76);
        PARAM "Bit field mask[76]"
            uint32
            present_if ("Num entries" > 76);
        PARAM "Value[76]"
            uint32
            present_if ("Num entries" > 76);
        PARAM "Register address[77]"
            uint32
            present_if ("Num entries" > 77);
        PARAM "Bit field mask[77]"
            uint32
            present_if ("Num entries" > 77);
        PARAM "Value[77]"
            uint32
            present_if ("Num entries" > 77);
        PARAM "Register address[78]"
            uint32
            present_if ("Num entries" > 78);
        PARAM "Bit field mask[78]"
            uint32
            present_if ("Num entries" > 78);
        PARAM "Value[78]"
            uint32
            present_if ("Num entries" > 78);
        PARAM "Register address[79]"
            uint32
            present_if ("Num entries" > 79);
        PARAM "Bit field mask[79]"
            uint32
            present_if ("Num entries" > 79);
        PARAM "Value[79]"
            uint32
            present_if ("Num entries" > 79);
        PARAM "Register address[80]"
            uint32
            present_if ("Num entries" > 80);
        PARAM "Bit field mask[80]"
            uint32
            present_if ("Num entries" > 80);
        PARAM "Value[80]"
            uint32
            present_if ("Num entries" > 80);
        PARAM "Register address[81]"
            uint32
            present_if ("Num entries" > 81);
        PARAM "Bit field mask[81]"
            uint32
            present_if ("Num entries" > 81);
        PARAM "Value[81]"
            uint32
            present_if ("Num entries" > 81);
        PARAM "Register address[82]"
            uint32
            present_if ("Num entries" > 82);
        PARAM "Bit field mask[82]"
            uint32
            present_if ("Num entries" > 82);
        PARAM "Value[82]"
            uint32
            present_if ("Num entries" > 82);
        PARAM "Register address[83]"
            uint32
            present_if ("Num entries" > 83);
        PARAM "Bit field mask[83]"
            uint32
            present_if ("Num entries" > 83);
        PARAM "Value[83]"
            uint32
            present_if ("Num entries" > 83);
        PARAM "Register address[84]"
            uint32
            present_if ("Num entries" > 84);
        PARAM "Bit field mask[84]"
            uint32
            present_if ("Num entries" > 84);
        PARAM "Value[84]"
            uint32
            present_if ("Num entries" > 84);
        PARAM "Register address[85]"
            uint32
            present_if ("Num entries" > 85);
        PARAM "Bit field mask[85]"
            uint32
            present_if ("Num entries" > 85);
        PARAM "Value[85]"
            uint32
            present_if ("Num entries" > 85);
        PARAM "Register address[86]"
            uint32
            present_if ("Num entries" > 86);
        PARAM "Bit field mask[86]"
            uint32
            present_if ("Num entries" > 86);
        PARAM "Value[86]"
            uint32
            present_if ("Num entries" > 86);
        PARAM "Register address[87]"
            uint32
            present_if ("Num entries" > 87);
        PARAM "Bit field mask[87]"
            uint32
            present_if ("Num entries" > 87);
        PARAM "Value[87]"
            uint32
            present_if ("Num entries" > 87);
        PARAM "Register address[88]"
            uint32
            present_if ("Num entries" > 88);
        PARAM "Bit field mask[88]"
            uint32
            present_if ("Num entries" > 88);
        PARAM "Value[88]"
            uint32
            present_if ("Num entries" > 88);
        PARAM "Register address[89]"
            uint32
            present_if ("Num entries" > 89);
        PARAM "Bit field mask[89]"
            uint32
            present_if ("Num entries" > 89);
        PARAM "Value[89]"
            uint32
            present_if ("Num entries" > 89);
        PARAM "Register address[90]"
            uint32
            present_if ("Num entries" > 90);
        PARAM "Bit field mask[90]"
            uint32
            present_if ("Num entries" > 90);
        PARAM "Value[90]"
            uint32
            present_if ("Num entries" > 90);
        PARAM "Register address[91]"
            uint32
            present_if ("Num entries" > 91);
        PARAM "Bit field mask[91]"
            uint32
            present_if ("Num entries" > 91);
        PARAM "Value[91]"
            uint32
            present_if ("Num entries" > 91);
        PARAM "Register address[92]"
            uint32
            present_if ("Num entries" > 92);
        PARAM "Bit field mask[92]"
            uint32
            present_if ("Num entries" > 92);
        PARAM "Value[92]"
            uint32
            present_if ("Num entries" > 92);
        PARAM "Register address[93]"
            uint32
            present_if ("Num entries" > 93);
        PARAM "Bit field mask[93]"
            uint32
            present_if ("Num entries" > 93);
        PARAM "Value[93]"
            uint32
            present_if ("Num entries" > 93);
        PARAM "Register address[94]"
            uint32
            present_if ("Num entries" > 94);
        PARAM "Bit field mask[94]"
            uint32
            present_if ("Num entries" > 94);
        PARAM "Value[94]"
            uint32
            present_if ("Num entries" > 94);
        PARAM "Register address[95]"
            uint32
            present_if ("Num entries" > 95);
        PARAM "Bit field mask[95]"
            uint32
            present_if ("Num entries" > 95);
        PARAM "Value[95]"
            uint32
            present_if ("Num entries" > 95);
        PARAM "Register address[96]"
            uint32
            present_if ("Num entries" > 96);
        PARAM "Bit field mask[96]"
            uint32
            present_if ("Num entries" > 96);
        PARAM "Value[96]"
            uint32
            present_if ("Num entries" > 96);
        PARAM "Register address[97]"
            uint32
            present_if ("Num entries" > 97);
        PARAM "Bit field mask[97]"
            uint32
            present_if ("Num entries" > 97);
        PARAM "Value[97]"
            uint32
            present_if ("Num entries" > 97);
        PARAM "Register address[98]"
            uint32
            present_if ("Num entries" > 98);
        PARAM "Bit field mask[98]"
            uint32
            present_if ("Num entries" > 98);
        PARAM "Value[98]"
            uint32
            present_if ("Num entries" > 98);
        PARAM "Register address[99]"
            uint32
            present_if ("Num entries" > 99);
        PARAM "Bit field mask[99]"
            uint32
            present_if ("Num entries" > 99);
        PARAM "Value[99]"
            uint32
            present_if ("Num entries" > 99);
        PARAM "Register address[100]"
            uint32
            present_if ("Num entries" > 100);
        PARAM "Bit field mask[100]"
            uint32
            present_if ("Num entries" > 100);
        PARAM "Value[100]"
            uint32
            present_if ("Num entries" > 100);
        PARAM "Register address[101]"
            uint32
            present_if ("Num entries" > 101);
        PARAM "Bit field mask[101]"
            uint32
            present_if ("Num entries" > 101);
        PARAM "Value[101]"
            uint32
            present_if ("Num entries" > 101);
        PARAM "Register address[102]"
            uint32
            present_if ("Num entries" > 102);
        PARAM "Bit field mask[102]"
            uint32
            present_if ("Num entries" > 102);
        PARAM "Value[102]"
            uint32
            present_if ("Num entries" > 102);
        PARAM "Register address[103]"
            uint32
            present_if ("Num entries" > 103);
        PARAM "Bit field mask[103]"
            uint32
            present_if ("Num entries" > 103);
        PARAM "Value[103]"
            uint32
            present_if ("Num entries" > 103);
        PARAM "Register address[104]"
            uint32
            present_if ("Num entries" > 104);
        PARAM "Bit field mask[104]"
            uint32
            present_if ("Num entries" > 104);
        PARAM "Value[104]"
            uint32
            present_if ("Num entries" > 104);
        PARAM "Register address[105]"
            uint32
            present_if ("Num entries" > 105);
        PARAM "Bit field mask[105]"
            uint32
            present_if ("Num entries" > 105);
        PARAM "Value[105]"
            uint32
            present_if ("Num entries" > 105);
        PARAM "Register address[106]"
            uint32
            present_if ("Num entries" > 106);
        PARAM "Bit field mask[106]"
            uint32
            present_if ("Num entries" > 106);
        PARAM "Value[106]"
            uint32
            present_if ("Num entries" > 106);
        PARAM "Register address[107]"
            uint32
            present_if ("Num entries" > 107);
        PARAM "Bit field mask[107]"
            uint32
            present_if ("Num entries" > 107);
        PARAM "Value[107]"
            uint32
            present_if ("Num entries" > 107);
        PARAM "Register address[108]"
            uint32
            present_if ("Num entries" > 108);
        PARAM "Bit field mask[108]"
            uint32
            present_if ("Num entries" > 108);
        PARAM "Value[108]"
            uint32
            present_if ("Num entries" > 108);
        PARAM "Register address[109]"
            uint32
            present_if ("Num entries" > 109);
        PARAM "Bit field mask[109]"
            uint32
            present_if ("Num entries" > 109);
        PARAM "Value[109]"
            uint32
            present_if ("Num entries" > 109);
        PARAM "Register address[110]"
            uint32
            present_if ("Num entries" > 110);
        PARAM "Bit field mask[110]"
            uint32
            present_if ("Num entries" > 110);
        PARAM "Value[110]"
            uint32
            present_if ("Num entries" > 110);
        PARAM "Register address[111]"
            uint32
            present_if ("Num entries" > 111);
        PARAM "Bit field mask[111]"
            uint32
            present_if ("Num entries" > 111);
        PARAM "Value[111]"
            uint32
            present_if ("Num entries" > 111);
        PARAM "Register address[112]"
            uint32
            present_if ("Num entries" > 112);
        PARAM "Bit field mask[112]"
            uint32
            present_if ("Num entries" > 112);
        PARAM "Value[112]"
            uint32
            present_if ("Num entries" > 112);
        PARAM "Register address[113]"
            uint32
            present_if ("Num entries" > 113);
        PARAM "Bit field mask[113]"
            uint32
            present_if ("Num entries" > 113);
        PARAM "Value[113]"
            uint32
            present_if ("Num entries" > 113);
        PARAM "Register address[114]"
            uint32
            present_if ("Num entries" > 114);
        PARAM "Bit field mask[114]"
            uint32
            present_if ("Num entries" > 114);
        PARAM "Value[114]"
            uint32
            present_if ("Num entries" > 114);
        PARAM "Register address[115]"
            uint32
            present_if ("Num entries" > 115);
        PARAM "Bit field mask[115]"
            uint32
            present_if ("Num entries" > 115);
        PARAM "Value[115]"
            uint32
            present_if ("Num entries" > 115);
        PARAM "Register address[116]"
            uint32
            present_if ("Num entries" > 116);
        PARAM "Bit field mask[116]"
            uint32
            present_if ("Num entries" > 116);
        PARAM "Value[116]"
            uint32
            present_if ("Num entries" > 116);
        PARAM "Register address[117]"
            uint32
            present_if ("Num entries" > 117);
        PARAM "Bit field mask[117]"
            uint32
            present_if ("Num entries" > 117);
        PARAM "Value[117]"
            uint32
            present_if ("Num entries" > 117);
        PARAM "Register address[118]"
            uint32
            present_if ("Num entries" > 118);
        PARAM "Bit field mask[118]"
            uint32
            present_if ("Num entries" > 118);
        PARAM "Value[118]"
            uint32
            present_if ("Num entries" > 118);
        PARAM "Register address[119]"
            uint32
            present_if ("Num entries" > 119);
        PARAM "Bit field mask[119]"
            uint32
            present_if ("Num entries" > 119);
        PARAM "Value[119]"
            uint32
            present_if ("Num entries" > 119);
        PARAM "Register address[120]"
            uint32
            present_if ("Num entries" > 120);
        PARAM "Bit field mask[120]"
            uint32
            present_if ("Num entries" > 120);
        PARAM "Value[120]"
            uint32
            present_if ("Num entries" > 120);
        PARAM "Register address[121]"
            uint32
            present_if ("Num entries" > 121);
        PARAM "Bit field mask[121]"
            uint32
            present_if ("Num entries" > 121);
        PARAM "Value[121]"
            uint32
            present_if ("Num entries" > 121);
        PARAM "Register address[122]"
            uint32
            present_if ("Num entries" > 122);
        PARAM "Bit field mask[122]"
            uint32
            present_if ("Num entries" > 122);
        PARAM "Value[122]"
            uint32
            present_if ("Num entries" > 122);
        PARAM "Register address[123]"
            uint32
            present_if ("Num entries" > 123);
        PARAM "Bit field mask[123]"
            uint32
            present_if ("Num entries" > 123);
        PARAM "Value[123]"
            uint32
            present_if ("Num entries" > 123);
        PARAM "Register address[124]"
            uint32
            present_if ("Num entries" > 124);
        PARAM "Bit field mask[124]"
            uint32
            present_if ("Num entries" > 124);
        PARAM "Value[124]"
            uint32
            present_if ("Num entries" > 124);
        PARAM "Register address[125]"
            uint32
            present_if ("Num entries" > 125);
        PARAM "Bit field mask[125]"
            uint32
            present_if ("Num entries" > 125);
        PARAM "Value[125]"
            uint32
            present_if ("Num entries" > 125);
        PARAM "Register address[126]"
            uint32
            present_if ("Num entries" > 126);
        PARAM "Bit field mask[126]"
            uint32
            present_if ("Num entries" > 126);
        PARAM "Value[126]"
            uint32
            present_if ("Num entries" > 126);
        PARAM "Register address[127]"
            uint32
            present_if ("Num entries" > 127);
        PARAM "Bit field mask[127]"
            uint32
            present_if ("Num entries" > 127);
        PARAM "Value[127]"
            uint32
            present_if ("Num entries" > 127);
    }

    COMMAND "RF PLL" 0xC1
    {
        doc "Provides RF_PLL programming information, which must match the"
            "frequency of the crystal which the device is running from."
        PARAM "Reg49_rf_pll_tx_base_adr0"
            uint8
            doc "BlueRF register 0x49.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg4a_rf_pll_tx_base_adr1"
            uint8
            doc "BlueRF register 0x4a.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg4b_rf_pll_tx_base_adr2"
            uint8
            doc "BlueRF register 0x4b.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg4c_rf_pll_tx_delta_adr0"
            uint8
            doc "BlueRF register 0x4c.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg4d_rf_pll_tx_delta_adr1"
            uint8
            doc "BlueRF register 0x4d.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg4e_rf_pll_rx_base_adr0"
            uint8
            doc "BlueRF register 0x4e.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg4f_rf_pll_rx_base_adr1"
            uint8
            doc "BlueRF register 0x4f.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg50_rf_pll_rx_base_adr2"
            uint8
            doc "BlueRF register 0x50.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg51_rf_pll_rx_delta_adr0"
            uint8
            doc "BlueRF register 0x51.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg52_rf_pll_rx_delta_adr1"
            uint8
            doc "BlueRF register 0x52.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg23_vco_cal_ref_timeout"
            uint8
            doc "BlueRF register 0x23.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";

        PARAM "vco_lut_data_in_adr1[0]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[0]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[1]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[1]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[2]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[2]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[3]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[3]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[4]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[4]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[5]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[5]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[6]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[6]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[7]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[7]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[8]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[8]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[9]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[9]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";

        PARAM "vco_lut_data_in_adr1[10]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[10]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[11]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[11]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[12]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[12]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[13]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[13]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[14]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[14]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[15]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[15]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[16]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[16]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[17]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[17]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[18]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[18]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[19]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[19]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";

        PARAM "vco_lut_data_in_adr1[20]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[20]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[21]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[21]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[22]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[22]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[23]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[23]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[24]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[24]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[25]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[25]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[26]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[26]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[27]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[27]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[28]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[28]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[29]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[29]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";

        PARAM "vco_lut_data_in_adr1[30]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[30]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[31]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[31]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[32]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[32]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[33]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[33]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[34]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[34]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[35]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[35]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[36]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[36]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[37]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[37]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[38]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[38]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[39]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[39]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[40]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[40]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr1[41]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "vco_lut_data_in_adr0[41]"
            uint8
            doc "Meaningful to RF engineers, from whom"
                "this value should be obtained.";

        PARAM "Reg14_I_txif"
            uint8
            doc "BlueRF register 0x14.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg11_I_Cp_tun"
            uint8
            doc "BlueRF register 0x11.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
        PARAM "Reg5c_tr_ctrl_adr"
            uint8
            doc "BlueRF register 0x5c.  Meaningful to RF engineers, from whom"
                "this value should be obtained.";
    }

    COMMAND "RF Run Time Data Patch" 0xC2
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Num entries"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            not_in_binary_message
            decode_value = 0                    # Can only decode, not encode
            max = 10;

        # - Entry[0] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[0]"
            uint32
            doc "($$$ NEEDS EXPLANATION)"
            present_if ("Num entries" > 0);
        PARAM "Length[0]"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            binary_message_only
            encode_value = ByteArrayValidLength("Data[0]")
            present_if ("Num entries" > 0);
        PARAM "Data[0]"
            uint8[255] omit_pad_bytes
            doc "($$$ NEEDS EXPLANATION)"
            present_if ("Num entries" > 0)
            valid_length = "Length[0]"
                min = 1;                                # Minimum array length in an array context

        # - Entry[1] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Length[1]"
            uint8
            binary_message_only
            encode_value = ByteArrayValidLength("Data[1]")
            present_if ("Num entries" > 1);
        PARAM "Data[1]"
            uint8[255] omit_pad_bytes
            present_if ("Num entries" > 1)
            valid_length = "Length[1]"
                min = 1;                                # Minimum array length in an array context

        # - Entry[2] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Length[2]"
            uint8
            binary_message_only
            encode_value = ByteArrayValidLength("Data[2]")
            present_if ("Num entries" > 2);
        PARAM "Data[2]"
            uint8[255] omit_pad_bytes
            present_if ("Num entries" > 2)
            valid_length = "Length[2]"
                min = 1;                                # Minimum array length in an array context

        # - Entry[3] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Length[3]"
            uint8
            binary_message_only
            encode_value = ByteArrayValidLength("Data[3]")
            present_if ("Num entries" > 3);
        PARAM "Data[3]"
            uint8[255] omit_pad_bytes
            present_if ("Num entries" > 3)
            valid_length = "Length[3]"
                min = 1;                                # Minimum array length in an array context

        # - Entry[4] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Length[4]"
            uint8
            binary_message_only
            encode_value = ByteArrayValidLength("Data[4]")
            present_if ("Num entries" > 4);
        PARAM "Data[4]"
            uint8[255] omit_pad_bytes
            present_if ("Num entries" > 4)
            valid_length = "Length[4]"
                min = 1;                                # Minimum array length in an array context

        # - Entry[5] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Length[5]"
            uint8
            binary_message_only
            encode_value = ByteArrayValidLength("Data[5]")
            present_if ("Num entries" > 5);
        PARAM "Data[5]"
            uint8[255] omit_pad_bytes
            present_if ("Num entries" > 5)
            valid_length = "Length[5]"
                min = 1;                                # Minimum array length in an array context

        # - Entry[6] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Length[6]"
            uint8
            binary_message_only
            encode_value = ByteArrayValidLength("Data[6]")
            present_if ("Num entries" > 6);
        PARAM "Data[6]"
            uint8[255] omit_pad_bytes
            present_if ("Num entries" > 6)
            valid_length = "Length[6]"
                min = 1;                                # Minimum array length in an array context

        # - Entry[7] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Length[7]"
            uint8
            binary_message_only
            encode_value = ByteArrayValidLength("Data[7]")
            present_if ("Num entries" > 7);
        PARAM "Data[7]"
            uint8[255] omit_pad_bytes
            present_if ("Num entries" > 7)
            valid_length = "Length[7]"
                min = 1;                                # Minimum array length in an array context

        # - Entry[8] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Length[8]"
            uint8
            binary_message_only
            encode_value = ByteArrayValidLength("Data[8]")
            present_if ("Num entries" > 8);
        PARAM "Data[8]"
            uint8[255] omit_pad_bytes
            present_if ("Num entries" > 8)
            valid_length = "Length[8]"
                min = 1;                                # Minimum array length in an array context

        # - Entry[9] - - - - - - - - - - - - - - - - - - -
        PARAM "Address[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Length[9]"
            uint8
            binary_message_only
            encode_value = ByteArrayValidLength("Data[9]")
            present_if ("Num entries" > 9);
        PARAM "Data[9]"
            uint8[255] omit_pad_bytes
            present_if ("Num entries" > 9)
            valid_length = "Length[9]"
                min = 1;                                # Minimum array length in an array context
    }


    COMMAND "Init RF Registers" 0xC3
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "Num entries"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            not_in_binary_message
            decode_value = 0                    # Can only decode, not encode
            max = 23;
        PARAM "Register offset[0]"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            present_if ("Num entries" > 0);
        PARAM "Value[0]"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            present_if ("Num entries" > 0);
        PARAM "Register offset[1]"
            uint8
            present_if ("Num entries" > 1);
        PARAM "Value[1]"
            uint8
            present_if ("Num entries" > 1);
        PARAM "Register offset[2]"
            uint8
            present_if ("Num entries" > 2);
        PARAM "Value[2]"
            uint8
            present_if ("Num entries" > 2);
        PARAM "Register offset[3]"
            uint8
            present_if ("Num entries" > 3);
        PARAM "Value[3]"
            uint8
            present_if ("Num entries" > 3);
        PARAM "Register offset[4]"
            uint8
            present_if ("Num entries" > 4);
        PARAM "Value[4]"
            uint8
            present_if ("Num entries" > 4);
        PARAM "Register offset[5]"
            uint8
            present_if ("Num entries" > 5);
        PARAM "Value[5]"
            uint8
            present_if ("Num entries" > 5);
        PARAM "Register offset[6]"
            uint8
            present_if ("Num entries" > 6);
        PARAM "Value[6]"
            uint8
            present_if ("Num entries" > 6);
        PARAM "Register offset[7]"
            uint8
            present_if ("Num entries" > 7);
        PARAM "Value[7]"
            uint8
            present_if ("Num entries" > 7);
        PARAM "Register offset[8]"
            uint8
            present_if ("Num entries" > 8);
        PARAM "Value[8]"
            uint8
            present_if ("Num entries" > 8);
        PARAM "Register offset[9]"
            uint8
            present_if ("Num entries" > 9);
        PARAM "Value[9]"
            uint8
            present_if ("Num entries" > 9);
        PARAM "Register offset[10]"
            uint8
            present_if ("Num entries" > 10);
        PARAM "Value[10]"
            uint8
            present_if ("Num entries" > 10);
        PARAM "Register offset[11]"
            uint8
            present_if ("Num entries" > 11);
        PARAM "Value[11]"
            uint8
            present_if ("Num entries" > 11);
        PARAM "Register offset[12]"
            uint8
            present_if ("Num entries" > 12);
        PARAM "Value[12]"
            uint8
            present_if ("Num entries" > 12);
        PARAM "Register offset[13]"
            uint8
            present_if ("Num entries" > 13);
        PARAM "Value[13]"
            uint8
            present_if ("Num entries" > 13);
        PARAM "Register offset[14]"
            uint8
            present_if ("Num entries" > 14);
        PARAM "Value[14]"
            uint8
            present_if ("Num entries" > 14);
        PARAM "Register offset[15]"
            uint8
            present_if ("Num entries" > 15);
        PARAM "Value[15]"
            uint8
            present_if ("Num entries" > 15);
        PARAM "Register offset[16]"
            uint8
            present_if ("Num entries" > 16);
        PARAM "Value[16]"
            uint8
            present_if ("Num entries" > 16);
        PARAM "Register offset[17]"
            uint8
            present_if ("Num entries" > 17);
        PARAM "Value[17]"
            uint8
            present_if ("Num entries" > 17);
        PARAM "Register offset[18]"
            uint8
            present_if ("Num entries" > 18);
        PARAM "Value[18]"
            uint8
            present_if ("Num entries" > 18);
        PARAM "Register offset[19]"
            uint8
            present_if ("Num entries" > 19);
        PARAM "Value[19]"
            uint8
            present_if ("Num entries" > 19);
        PARAM "Register offset[20]"
            uint8
            present_if ("Num entries" > 20);
        PARAM "Value[20]"
            uint8
            present_if ("Num entries" > 20);
        PARAM "Register offset[21]"
            uint8
            present_if ("Num entries" > 21);
        PARAM "Value[21]"
            uint8
            present_if ("Num entries" > 21);
        PARAM "Register offset[22]"
            uint8
            present_if ("Num entries" > 22);
        PARAM "Value[22]"
            uint8
            present_if ("Num entries" > 22);
    }


    COMMAND "Init BB Registers" 0xC4
    {
        doc "DEPRECATED - PRESERVED FOR CONFIG FILE COMPATIBILITY.  USE Init BB Register Bit Fields"
            "INSTEAD!!!."
        PARAM "Num entries"
            uint8
            doc "DEPRECATED"
            not_in_binary_message
            decode_value = 0                    # Can only decode, not encode
            max = 60;
        PARAM "Register address[0]"
            uint32
            doc "DEPRECATED"
            present_if ("Num entries" > 0);
        PARAM "Value[0]"
            uint32
            doc "DEPRECATED"
            present_if ("Num entries" > 0);
        PARAM "Register address[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Value[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Register address[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Value[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Register address[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Value[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Register address[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Value[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Register address[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Value[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Register address[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Value[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Register address[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Value[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Register address[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Value[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Register address[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Value[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Register address[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Value[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Register address[11]"
            uint32
            present_if ("Num entries" > 11);
        PARAM "Value[11]"
            uint32
            present_if ("Num entries" > 11);
        PARAM "Register address[12]"
            uint32
            present_if ("Num entries" > 12);
        PARAM "Value[12]"
            uint32
            present_if ("Num entries" > 12);
        PARAM "Register address[13]"
            uint32
            present_if ("Num entries" > 13);
        PARAM "Value[13]"
            uint32
            present_if ("Num entries" > 13);
        PARAM "Register address[14]"
            uint32
            present_if ("Num entries" > 14);
        PARAM "Value[14]"
            uint32
            present_if ("Num entries" > 14);
        PARAM "Register address[15]"
            uint32
            present_if ("Num entries" > 15);
        PARAM "Value[15]"
            uint32
            present_if ("Num entries" > 15);
        PARAM "Register address[16]"
            uint32
            present_if ("Num entries" > 16);
        PARAM "Value[16]"
            uint32
            present_if ("Num entries" > 16);
        PARAM "Register address[17]"
            uint32
            present_if ("Num entries" > 17);
        PARAM "Value[17]"
            uint32
            present_if ("Num entries" > 17);
        PARAM "Register address[18]"
            uint32
            present_if ("Num entries" > 18);
        PARAM "Value[18]"
            uint32
            present_if ("Num entries" > 18);
        PARAM "Register address[19]"
            uint32
            present_if ("Num entries" > 19);
        PARAM "Value[19]"
            uint32
            present_if ("Num entries" > 19);
        PARAM "Register address[20]"
            uint32
            present_if ("Num entries" > 20);
        PARAM "Value[20]"
            uint32
            present_if ("Num entries" > 20);
        PARAM "Register address[21]"
            uint32
            present_if ("Num entries" > 21);
        PARAM "Value[21]"
            uint32
            present_if ("Num entries" > 21);
        PARAM "Register address[22]"
            uint32
            present_if ("Num entries" > 22);
        PARAM "Value[22]"
            uint32
            present_if ("Num entries" > 22);
        PARAM "Register address[23]"
            uint32
            present_if ("Num entries" > 23);
        PARAM "Value[23]"
            uint32
            present_if ("Num entries" > 23);
        PARAM "Register address[24]"
            uint32
            present_if ("Num entries" > 24);
        PARAM "Value[24]"
            uint32
            present_if ("Num entries" > 24);
        PARAM "Register address[25]"
            uint32
            present_if ("Num entries" > 25);
        PARAM "Value[25]"
            uint32
            present_if ("Num entries" > 25);
        PARAM "Register address[26]"
            uint32
            present_if ("Num entries" > 26);
        PARAM "Value[26]"
            uint32
            present_if ("Num entries" > 26);
        PARAM "Register address[27]"
            uint32
            present_if ("Num entries" > 27);
        PARAM "Value[27]"
            uint32
            present_if ("Num entries" > 27);
        PARAM "Register address[28]"
            uint32
            present_if ("Num entries" > 28);
        PARAM "Value[28]"
            uint32
            present_if ("Num entries" > 28);
        PARAM "Register address[29]"
            uint32
            present_if ("Num entries" > 29);
        PARAM "Value[29]"
            uint32
            present_if ("Num entries" > 29);
        PARAM "Register address[30]"
            uint32
            present_if ("Num entries" > 30);
        PARAM "Value[30]"
            uint32
            present_if ("Num entries" > 30);
        PARAM "Register address[31]"
            uint32
            present_if ("Num entries" > 31);
        PARAM "Value[31]"
            uint32
            present_if ("Num entries" > 31);
        PARAM "Register address[32]"
            uint32
            present_if ("Num entries" > 32);
        PARAM "Value[32]"
            uint32
            present_if ("Num entries" > 32);
        PARAM "Register address[33]"
            uint32
            present_if ("Num entries" > 33);
        PARAM "Value[33]"
            uint32
            present_if ("Num entries" > 33);
        PARAM "Register address[34]"
            uint32
            present_if ("Num entries" > 34);
        PARAM "Value[34]"
            uint32
            present_if ("Num entries" > 34);
        PARAM "Register address[35]"
            uint32
            present_if ("Num entries" > 35);
        PARAM "Value[35]"
            uint32
            present_if ("Num entries" > 35);
        PARAM "Register address[36]"
            uint32
            present_if ("Num entries" > 36);
        PARAM "Value[36]"
            uint32
            present_if ("Num entries" > 36);
        PARAM "Register address[37]"
            uint32
            present_if ("Num entries" > 37);
        PARAM "Value[37]"
            uint32
            present_if ("Num entries" > 37);
        PARAM "Register address[38]"
            uint32
            present_if ("Num entries" > 38);
        PARAM "Value[38]"
            uint32
            present_if ("Num entries" > 38);
        PARAM "Register address[39]"
            uint32
            present_if ("Num entries" > 39);
        PARAM "Value[39]"
            uint32
            present_if ("Num entries" > 39);
        PARAM "Register address[40]"
            uint32
            present_if ("Num entries" > 40);
        PARAM "Value[40]"
            uint32
            present_if ("Num entries" > 40);
        PARAM "Register address[41]"
            uint32
            present_if ("Num entries" > 41);
        PARAM "Value[41]"
            uint32
            present_if ("Num entries" > 41);
        PARAM "Register address[42]"
            uint32
            present_if ("Num entries" > 42);
        PARAM "Value[42]"
            uint32
            present_if ("Num entries" > 42);
        PARAM "Register address[43]"
            uint32
            present_if ("Num entries" > 43);
        PARAM "Value[43]"
            uint32
            present_if ("Num entries" > 43);
        PARAM "Register address[44]"
            uint32
            present_if ("Num entries" > 44);
        PARAM "Value[44]"
            uint32
            present_if ("Num entries" > 44);
        PARAM "Register address[45]"
            uint32
            present_if ("Num entries" > 45);
        PARAM "Value[45]"
            uint32
            present_if ("Num entries" > 45);
        PARAM "Register address[46]"
            uint32
            present_if ("Num entries" > 46);
        PARAM "Value[46]"
            uint32
            present_if ("Num entries" > 46);
        PARAM "Register address[47]"
            uint32
            present_if ("Num entries" > 47);
        PARAM "Value[47]"
            uint32
            present_if ("Num entries" > 47);
        PARAM "Register address[48]"
            uint32
            present_if ("Num entries" > 48);
        PARAM "Value[48]"
            uint32
            present_if ("Num entries" > 48);
        PARAM "Register address[49]"
            uint32
            present_if ("Num entries" > 49);
        PARAM "Value[49]"
            uint32
            present_if ("Num entries" > 49);

        PARAM "Register address[50]"
            uint32
            present_if ("Num entries" > 50);
        PARAM "Value[50]"
            uint32
            present_if ("Num entries" > 50);

        PARAM "Register address[51]"
            uint32
            present_if ("Num entries" > 51);
        PARAM "Value[51]"
            uint32
            present_if ("Num entries" > 51);

        PARAM "Register address[52]"
            uint32
            present_if ("Num entries" > 52);
        PARAM "Value[52]"
            uint32
            present_if ("Num entries" > 52);

        PARAM "Register address[53]"
            uint32
            present_if ("Num entries" > 53);
        PARAM "Value[53]"
            uint32
            present_if ("Num entries" > 53);

        PARAM "Register address[54]"
            uint32
            present_if ("Num entries" > 54);
        PARAM "Value[54]"
            uint32
            present_if ("Num entries" > 54);

        PARAM "Register address[55]"
            uint32
            present_if ("Num entries" > 55);
        PARAM "Value[55]"
            uint32
            present_if ("Num entries" > 55);

        PARAM "Register address[56]"
            uint32
            present_if ("Num entries" > 56);
        PARAM "Value[56]"
            uint32
            present_if ("Num entries" > 56);

        PARAM "Register address[57]"
            uint32
            present_if ("Num entries" > 57);
        PARAM "Value[57]"
            uint32
            present_if ("Num entries" > 57);

        PARAM "Register address[58]"
            uint32
            present_if ("Num entries" > 58);
        PARAM "Value[58]"
            uint32
            present_if ("Num entries" > 58);

        PARAM "Register address[59]"
            uint32
            present_if ("Num entries" > 59);
        PARAM "Value[59]"
            uint32
            present_if ("Num entries" > 59);

    }

    COMMAND "RC Calibration" 0xC6
    {
        doc "Configuration item for Bluetooth Resistivity/Capacitance(RC) calibration"
            "RC calibration is a binary search algorithm, with a"
            "best value optimization. RC calibration is performed in the"
            "Firmware initialization code space, after the BOOT code has"
            "switched the processor clock to use the internal PLL. This is"
            "required because full knowledge of the reference clock in the LPO"
            "counting module is required."
            "For reference please read [Calibration procedures for BCM2045]."

        PARAM "RC target"
            uint32
            doc "Bluetooth RC calibration target resistor for Rtune.  The default"
                "value is 948.";

        PARAM "RC override value"
            uint32
            doc "Bluetooth RC calibration override value";

        PARAM "X_0 override value"
            uint32
            doc "Bluetooth RC calibration X_0";

        PARAM "RC override flag"
            bool8
            doc "If override flag is true, device will use RC override value to override the"
                "target register and skip the calibration process."
                "If override flag is false, device will use RC target and X_0 to run the"
                "calibration process. The default value is 0.";

        PARAM "X_0 override flag"
            bool8
            doc "If X_0 override flag is true, device will use X_0 override value, otherwise"
                "It will use default X_0 value. The default value is 0.";
    }

    COMMAND "Agilent 7050 Driver Configuration" 0xA9
    {
        doc "Configures Agilent 7050 optical sensor interface"
        PARAM "7050 CS Connected to Port"
            uint8
            doc "Defines the GPIO port of 20730 which 7050 CS pin connects to"
                "Default is 1( port 1)"
            max = 2;
        PARAM "7050 CS Connected to Port Pin"
            uint8
            doc "Defines the pin of the above defined port which 7050 CS pin connects to"
                "Default is 0( pin 0)"
            max = 15
            note "0=LSB, 15=MSB";
        PARAM "7050 Motion Connected to Port"
            uint8
            doc "Defines the GPIO port of 20730 which 7050 motion pin connects to"
                "Default is 1( port 1)"
            max = 2;
        PARAM "7050 Motion Connected to Port Pin"
            uint8
            doc "Defines the pin of the above defined port which 7050 motion pin connects to"
                "Default is 1( pin 1)"
            max = 15
            note "0=LSB, 15=MSB";
        PARAM "7050 Motion Line Pull Config"
            uint16
            doc "Set the input Pull-up, pull-down,float cpnfiguration"
            enum
            {
                {0x0400, "Pull-Up"},
                {0x0200, "Pull-Down"},
                {0x0000, "Floating"}
            };

        PARAM "7050 Initial Config Register Value"
            uint8
            doc "Defines the initial value of the 7050 sensor configuration register"
                "Default is 0x80( 800 dpi)";
        PARAM "SPI speed"
            uint32
            doc "Set to desired speed in KHz"
                "Default is 500000 (500,000 KHz)";
        PARAM "Delay between SPI write complete to NCS inactive"
            uint8
            doc "Delay in microseconds after the SPI write is complete before NCS is deasserted."
	        "This delay is required by the 7050"
		"Default is 20 us based on the 7050 spec";
        PARAM "7050 reset delay"
            uint16
            doc "Delay in microseconds after the reset command is issued to the 7050"
	        "Default is 1000 us"
		"Note that this value is not specified in the 7050 spec"
            min = 1;
        PARAM "7050 Initial Laser Ctrl0 Register Value"
            uint8
            doc "Defines the initial value of the 7050 sensor Laser Ctrl0 register"
                "Default is 0x0A";
        PARAM "7050 Initial Lsrpwr Cfg0 Register Value"
            uint8
            doc "Defines the initial value of the 7050 sensor Laser Cfg0 register"
                "Default is 0xFF";
        PARAM "7050 Initial Lsrpwr Cfg1 Register Value"
            uint8
            doc "Defines the initial value of the 7050 sensor Laser Cfg1 register"
                "Default is 0x00";
        PARAM "7050 Initial Laser Ctrl1 Register Value"
            uint8
            doc "Defines the initial value of the 7050 sensor Laser Ctrl1 register"
                "Default is 0xA0";
        PARAM "Delay for Spi read in us"
            uint8
            doc "delay for spi-read in us"
                "Default is 4";
        PARAM "Bust Read Length"
            uint8
            doc "bust read length"
                "Default is 3";
    }

    COMMAND "Quadrature Driver Configuration" 0xAA
    {
        doc "Configuration values for the quadrature driver"
        PARAM "Scan Period"
            uint16
            doc "Defines the initial count value for the QOC scanp counter."
	        "The counter counts at 128KHz rate, reloading the initial"
		"count when max count of 0xFFFF is reached"
		"Default is 0xFF00";
        PARAM "QOC LED 0 toggle count"
            uint16
            doc "Defines the instant when QOC LED 0 is toggled to 1"
	        "until the end of scanp counter terminal count of 0xFFFF,"
		"at which point it toggles back to 0 and the initial"
		"scanp counter value is reloaded."
		"Default is 0xFFF0";
        PARAM "QOC LED 1 toggle count"
            uint16
            doc "Defines the instant when QOC LED 1 is toggled to 1"
	        "until the end of scanp counter terminal count of 0xFFFF,"
		"at which point it toggles back to 0 and the initial"
		"scanp counter value is reloaded."
		"Default is 0xFFF0";
        PARAM "QOC LED 2 toggle count"
            uint16
            doc "Defines the instant when QOC LED 2 is toggled to 1"
	        "until the end of scanp counter terminal count of 0xFFFF,"
		"at which point it toggles back to 0 and the initial"
		"scanp counter value is reloaded."
		"Default is 0xFFF0";
        PARAM "QOC LED 3 toggle count"
            uint16
            doc "Defines the instant when the QOC LED 3 is toggled to 1"
	        "until the end of scanp counter terminal count of 0xFFFF,"
		"at which point it toggles back to 0 and the initial"
		"scanp counter value is reloaded."
		"Default is 0";
        PARAM "X axis sample instant"
            uint16
            doc "Defines the instant in the scan cycle when the X axis is sampled"
		"Default is 0xFFF8";
        PARAM "Y axis sample instant"
            uint16
            doc "Defines the instant in the scan cycle when the Y axis is sampled"
		"Default is 0xFFF8";
        PARAM "Z axis sample instant"
            uint16
            doc "Defines the instant in the scan cycle when the Z axis is sampled"
		"Default is 0xFFF8";
	    PARAM "Reserved_1"
            uint16 {15:8}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
        PARAM "QOC LED 3 output polarity"
            uint16 {7:6}
            doc "Controls the active and idle states of the QOC LED 3 signal"
	        "Default is 1 when on, tristate when off(open source)"
            enum
            {
                {0, "1 when on, tristate when off(open source)"},
                {1, "1 when on, 0 when off"},
                {2, "tristate when on, 0 when off(open drain)"},
                {3, "0 when on, 1 when off"}
            };
        PARAM "QOC LED 2 output polarity"
            uint16 {5:4}
            doc "Controls the active and idle states of the QOC LED 2 signal"
	        "Default is 1 when on, tristate when off(open source)"
            enum
            {
                {0, "1 when on, tristate when off(open source)"},
                {1, "1 when on, 0 when off"},
                {2, "tristate when on, 0 when off(open drain)"},
                {3, "0 when on, 1 when off"}
            };
        PARAM "QOC LED 1 output polarity"
            uint16 {3:2}
            doc "Controls the active and idle states of the QOC LED 1 signal"
	        "Default is 1 when on, tristate when off(open source)"
            enum
            {
                {0, "1 when on, tristate when off(open source)"},
                {1, "1 when on, 0 when off"},
                {2, "tristate when on, 0 when off(open drain)"},
                {3, "0 when on, 1 when off"}
            };
        PARAM "QOC LED 0 output polarity"
            uint16 {1:0}
            doc "Controls the active and idle states of the QOC LED 0 signal"
	        "Default is 1 when on, 0 when off"
            enum
            {
                {0, "1 when on, tristate when off(open source)"},
                {1, "1 when on, 0 when off"},
                {2, "tristate when on, 0 when off(open drain)"},
                {3, "0 when on, 1 when off"}
            };
        PARAM "Reserved_2"
            uint8
            doc "Reserved";
        PARAM "Reserved_3"
            uint8
            doc "Reserved";
        PARAM "Reserved_4"
            uint8
            doc "Reserved";
        PARAM "GPIO Config"
            uint16
            doc "Configuration value used for each GPIO pin used for quadrature"
	        "Default is input enable and pullup (0x400)";
        PARAM "Port 0 pins used as the quad input port"
	    uint8
            doc "If TRUE, Port 0 selected as quadrature input port (P2,P3,P4,P5,P6,P7)"
                "If FALSE, Port 2 selected as quadrature input port (P32,P33,P34,P35,P36,P37)"
	        "Default is TRUE"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
       PARAM "Reserved_5"
            uint8 {7:4}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
       PARAM "Configure P29 as Q0C LED 3"
            uint8 {3}
            doc "Indicates whether P29 should be configured as Q0C LED 0"
	        "If configured, the GPIO configuration for P29"
                "is changed to the configured value for each line."
		"If not configured as Q0C LED 3, P29 config is not modified."
	        "Default is FALSE"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "Configure P28 as Q0C LED 2"
            uint8 {2}
            doc "Indicates whether P28 should be configured as Q0C LED 2"
	        "If configured, the GPIO configuration for P28"
                "is changed to the configured value for each line."
		"If not configured as Q0C LED 2, P28 config is not modified."
	        "Default is FALSE"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "Configure P27 as Q0C LED 1"
            uint8 {1}
            doc "Indicates whether P27 should be configured as Q0C LED 1"
	        "If configured, the GPIO configuration for P27"
                "is changed to the configured value for each line."
		"If not configured as Q0C LED 1, P27 config is not modified"
	        "Default is FALSE"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "Configure P26 as Q0C LED 0"
            uint8 {0}
            doc "Indicates whether P26 should be configured as Q0C LED 0"
	        "If configured, the GPIO configuration for P26"
                "is changed to the configured value for each line."
		"If not configured as Q0C LED 0, P26 config is not modified"
	        "Default is TRUE"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "Z interface control"
            uint8 {7}
            doc "Enables/disables Z interface."
	        "Default is Enable"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Z interface Sampling rate"
            uint8 {6:4}
            doc "Controls Z interface sampling rate"
	        "Default is to sample the Z interface once per scan cycle"
            enum
            {
                {0, "Once per scan cycle"},
                {1, "Once per 2 scan cycles"},
                {2, "Once per 4 scan cycles"},
                {3, "Once per 8 scan cycles"},
                {4, "Once per 16 scan cycles"},
                {5, "Once per 32 scan cycles"},
                {6, "Once per 64 scan cycles"},
                {7, "Once per 128 scan cycles"}
            };
        PARAM "XY interface control"
            uint8 {3}
            doc "Enables/disables XY interface"
	        "Note that XY interfaces must be enabled/disabled together"
	        "Default is Disable"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "XY interface Sampling select fixed rate"
            uint8 {2}
            doc "Select XY interface Sampling fixed rate"
	        "Default is TRUE"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };
        PARAM "XY interface Sampling fixed rate"
            uint8 {1:0}
            doc "Controls XY interface sampling rate"
	        "Default is 128 KHz"
            enum
            {
                {0, "128 KHz"},
                {1, "64 KHz"},
                {2, "32 KHz"},
                {3, "16 KHz"}
            };
        PARAM "Reserved_6"
            uint8 {7:4}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
        PARAM "Scroll with no detent"
            uint8 {3}
            doc "When enabled, allows quadrature decoding for a scroll wheel that uses no detent"
	        "Default is disabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Reserved_7"
            uint8 {2}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
        PARAM "Quadrature interrupt/wakeup control"
            uint8 {1}
            doc "When enabled, allows quadrature interface to interrupt/wakeup the chip when it detects activity"
	        "Default is enabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Quadrature control"
            uint8 {0}
            doc "Master control for the quadrature interface. Must be enabled for X/Y/Z interfaces to work"
	        "Default is enabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "X Axis Data Polling"
            uint8
            doc "Whether the driver should collect X axis data when the HW is polled"
	        "Default is disabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Y Axis Data Polling"
            uint8
            doc "Whether the driver should collect Y axis data when the HW is polled"
	        "Default is disabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Z Axis Data Polling"
            uint8
            doc "Whether the driver should collect Z axis data when the HW is polled"
	        "Default is enabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
    }


    COMMAND "Keyscan Driver Configuration" 0xBB
    {
        doc "Configuration for the keyscan driver"
        PARAM "Row GPIO Config"
            uint16
            doc "Configuration field for all GPIOs used as rows in the keyscan matrix"
	        "Default is input enable and pullup (0x400)";
        PARAM "Col GPIO Config"
            uint16
            doc "Configuration field for all GPIOs used as columns in the keyscan matrix"
	        "Default is keyscan output enable (0x0010)";
        PARAM "Reserved_6"
            uint32 {31:18}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
        PARAM "Extend key cycle control"
            uint32 {17}
            doc "Enable/disable delay in-between keyscans"
	        "Default is disabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Extend key cycle count"
            uint32 {16:10}
            doc "Inter-keyscan cycle delay in units of 4 MIA clocks"
	        "Default is 0" ;
        PARAM "Micro debounce count"
            uint32 {9:8}
            doc "The keyscan HW detects each key multiple times in every scan. This reduces"
	        "spurious key detection because of noise. This parameters configures the number"
		"of times the keyscan HW checks each key. Set it to the desired value minus 1,"
		" e.g. a value of 3 causes the HW to check for the key 4 times."
                "Default is 3, i.e. each key must be detected 4 times"
            min = 0
            max = 3;
        PARAM "Macro up debounce count"
            uint32 {7:4}
            doc "Use this field to configure the number of full scan cycles in which a key must"
	        "be detected as up before it is reported as up. Set this field to one less than"
		"the desired value, e.g. set it to 2 if a key should only be reported as up if"
		"it is detected up for 3 full key scan cycles. Note that this differs from micro"
		"debounce in that micro debounce checks the same key multiple times within the"
		"same scan whereas macro debounce works across multiple scans."
		"Default for this field is 3, i.e. 4 scans"
            min = 0
            max = 15;
        PARAM "Macro down debounce count"
            uint32 {3:0}
            doc "Use this field to configure the number of full scan cycles in which a key must"
	        "be detected as down before it is reported as down. Set this field to one less than"
		"the desired value, e.g. set it to 2 if a key should only be reported as down if"
		"it is detected down for 3 full key scan cycles. Note that this differs from micro"
		"debounce in that micro debounce checks the same key multiple times within the"
		"same scan whereas macro debounce works across multiple scans."
		"Default for this field is 3, i.e. 4 scans"
            min = 0
            max = 15;
        PARAM "Reserved_5 of Keyscan"
            uint32 {31:19}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
        PARAM "Keyscan clock behavior when idle"
            uint32 {18}
            doc "Defines keyscan clock behavior in idle state"
	        "Default is that the clock is always on, even when there is no user activity"
            enum
            {
                {0, "Gated off by MIA"},
                {1, "Always on"}
            };
        PARAM "Keyscan active rows drive"
            uint32 {17}
            doc "Enables/disables active drive on row input in between scans"
	        "This reduces the row pull-up time"
	        "Default is enabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Keyscan active col pull-up"
            uint32 {16}
            doc "Enables/disables pull-up on col output in between scans"
	        "This alleviates slow rise time on large matrices"
                "Default is disabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Number of cols"
            uint32 {15:11}
            doc "Number of columns in the keyscan matrix"
	        "Programmed value must be one less than the actual value"
                "For example, set this field to 3 when the keyscan matrix has 4 columns"
	        "Default value is 3 for MOUSE_APP, otherwise 19"
            min = 0
            max = 19;
        PARAM "Number of rows"
            uint32 {10:8}
            doc "Number of rows in the keyscan matrix"
	        "Programmed value must be one less than the actual value"
                "For example, set this field to 3 when the keyscan matrix has 4 rows"
	        "Default value is 0 for MOUSE_APP, otherwise 7"
            min = 0
            max = 7;
        PARAM "Keyscan RC ext"
            uint32 {7:6}
            doc "Programmable duration between column scans"
	        "Alleviates slow RC delay on large keyboards"
                "Default is 3 i.e. maximum delay of 3 clocks"
            min = 1
            max = 3;
        PARAM "Reserved_4 of Keyscan"
            uint32 {5}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
        PARAM "Reserved_3 of Keyscan"
            uint32 {4}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
        PARAM "Reserved_2 of Keyscan"
            uint32 {3}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
        PARAM "Keyscan ghost detection"
            uint32 {2}
            doc "Enable keyscan HW ghost detection"
	        "Default is enabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Reserved_1 of Keyscan"
            uint32 {1}
            doc "Reserved"
            binary_message_only
            encode_value = 0;
        PARAM "Keyscan HW control"
            uint32 {0}
            doc "Enables/disables keyscan HW"
	        "Default is enabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
    }


    COMMAND "MIA Driver" 0xBD
    {
        doc "Configuration item for the MIA Driver object"

        PARAM "Microseconds to Delay After Entering HID-OFF"
            uint32
            doc "The HW takes a little time to enter HID-OFF,"
                "so this is the time the FW will spin after enabling it."
            default = 10000;
        PARAM "Microseconds to Delay After Enabling Keyscan Block"
            uint16
            doc "number of microseconds to wait for keyscan block to get"
                "synchronized before go to HID-OFF."
            default = 600;
        PARAM "timedWakeIntPortPin"
            uint8
            doc "Port and Pin to be used for timed wake interrupt/async wake to PMU"
                "timedWakeIntPortPin[7:5] = port, timedWakeIntPortPin[4:0] = pin. Default is Port 2, pin 7."
            default = 0x47;
        PARAM "lpoActiveFreq"
            uint8
            doc "lpoActiveFreq"
            enum
            {
                { 0x0,      "HW_LPO_FREQ_128KHZ" },
                { 0x1,      "HW_LPO_FREQ_32KHZ" },
                { 0x3,      "HW_LPO_FREQ_16KHZ" }
            }
            default = 0;
        PARAM "lpoHidoffFreq"
            uint8
            doc "lpoHidoffFreq"
            enum
            {
                { 0x0,      "HW_LPO_FREQ_128KHZ" },
                { 0x1,      "HW_LPO_FREQ_32KHZ" },
                { 0x3,      "HW_LPO_FREQ_16KHZ" }
            }
            default = 0;
        PARAM "keyscan128kFreqAutoSwitchEnable"
            uint8
            doc "keyscan128kFreqAutoSwitchEnable"
            default = 0;
    }


    COMMAND "RTC Configuration" 0xA8
    {
        doc "Configure RTC Driver"

        PARAM "Oscillator Frequency in kHz"
            uint8
            doc "Oscillator Frequence for RTC. Default = 128 kHz"
            default = 128;
        PARAM "Rtc reference clock"
            uint8
            doc "The reference clock to use for RTC - the 32K or 128 Mia LPO"
                "seem not used now"
            default = 0;
    }


    COMMAND "LDO Configuration" 0xA3
    {
        doc "Configure LDO Driver"

        PARAM "RESERVED_0"
            uint32 {31:5}
            doc "Reserved (Pin)"
            binary_message_only
            encode_value = 0;

        PARAM "LDO Sleep Output Level"
            uint32 {4:2}
            doc "Enable powe down of the bandgap in HIDDOFF mode automatically."
            enum
            {
                { 0x4,      "LDO_VOUT_0P88V" },
                { 0x5,      "LDO_VOUT_0P96V" },
                { 0x6,      "LDO_VOUT_1P04V" },
                { 0x7,      "LDO_VOUT_1P12V" },
                { 0x0,      "LDO_VOUT_1P20V" },
                { 0x1,      "LDO_VOUT_1P24V" },
                { 0x2,      "LDO_VOUT_1P28V" },
                { 0x3,      "LDO_VOUT_1P32V" }

            }
            default = 0;

        PARAM "HIDOFF Powerdown Bandgap Enable"
            uint32 {1}
            doc "Enable powe down of the bandgap in HIDDOFF mode automatically."
            enum
            {
                {1, "Enable"},
                {0, "Disable"}
            }
            default = 0;

        PARAM "LDO Control Enable"
            uint32 {0}
            doc "Enable LDO control"
            enum
            {
                {1, "Enable"},
                {0, "Disable"}
            }
            default = 0;

        PARAM "RESERVED_1"
            uint32 {31:26}
            doc "Reserved (Pin)"
            binary_message_only
            encode_value = 0;

        PARAM "LDO Current Feedback for ESR Zero"
            uint32 {25:24}
            doc "LDO Current Feedback Adjustment."
            max     = 15
            default = 0;

        PARAM "LDO Current Limit Adjustment"
            uint32 {23}
            doc "LDO Current Limit Adjustment"
            default = 0;

        PARAM "LDO Current Limit Mode"
            uint32 {22}
            doc "The current limit mode if LDO Current limit enable"
              "Default Constant"
            enum
            {
                {0, "Constant"},
                {1, "Feedback"}
            }
            default = 0;

        PARAM "LDO Current Limit Enable"
            uint32 {21}
            doc "LDO Current limit enable"
              "Default Disable"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            }
            default = 0;

        PARAM "LDO VDS Matching Amp Enable"
            uint32 {20}
            doc "Enable VDS matching amplifier for LDO operation"
                "Default Disable"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            }
            default = 0;

        PARAM "LDO Output Adjustment"
            uint32 {19:17}
            doc "Enable powe down of the bandgap in HIDDOFF mode automatically."
            enum
            {
                { 0x4,      "LDO_VOUT_0P88V" },
                { 0x5,      "LDO_VOUT_0P96V" },
                { 0x6,      "LDO_VOUT_1P04V" },
                { 0x7,      "LDO_VOUT_1P12V" },
                { 0x0,      "LDO_VOUT_1P20V" },
                { 0x1,      "LDO_VOUT_1P24V" },
                { 0x2,      "LDO_VOUT_1P28V" },
                { 0x3,      "LDO_VOUT_1P32V" }
            }

            default = 0;

        PARAM "LDO Power Mode"
            uint32 {16}
            doc "LDO power mode."
                "Default Power Up"
            enum
            {
                {0, "Power Up"},
                {1, "Power Down"}
            }
            default = 0;

        PARAM "RESERVED_2"
            uint32 {15}
            doc "Reserved (Pin)"
            binary_message_only
            encode_value = 0;

        PARAM "Bandgap Reference Voltage Adjustment"
            uint32 {14:12}
            doc "Bandgap reference voltage adjustment."
                "Default 0."
            max     = 7
            default = 0;

        PARAM "Bandgap CTAT Current Adjustment"
            uint32 {11:8}
            doc "Bandgap CTAT current adjustment"
                "Default 0."
            max     = 15
            default = 0;

        PARAM "Bandgap PTAT Current Adjustment"
            uint32 {7:4}
            doc "Bandgap PTAT current adjustment."
                "Default 0."
            max     = 15
            default = 0;

        PARAM "Bandgap Power Mode"
            uint32 {3}
            doc "Bandgap low power mode."
                "Default Power Up"
            enum
            {
                {0, "Power Up"},
                {1, "Power Down"}
            }
            default = 0;

        PARAM "LPF Filter Off Bandgap Noise"
            uint32 {2:1}
            doc "LPF enable/adjust to filter off BG noise."
                "Default disabled for fast startup."
            max     = 7
            default = 0;


        PARAM "Bandgap Low Powermode Enable"
            uint32 {0}
            doc "Bandgap low power mode."
                "Default enable."
            enum
            {
                {0, "Enable"},
                {1, "Disable"}
            }
            default = 0;
    }


    COMMAND "GPIO Configuration" 0xA7
    {
         doc "Configures GPIO. 20703 has 3 GPIO ports (port0 - port2)."
             "Port 0 has 16 pins  (GPIO_0 to GPIO_15)"
             "Port 1 has 16 pins (GPIO_16 to GPIO_31)"
             "Port 2 has 8 pins (GPIO_32 to GPIO_39)"
             "The total is 40 pins. "

         PARAM "GPIO Count"
            uint8
            doc "This defines the number of GPIO pin that will be configurated in the below configuration. If GPIO pin is not"
                "defined here, the pin will be configured as the default."
            min = 0
            max = 40;

         PARAM "Maximum Port Count"
            uint8
            doc "Defines the maximum number of ports that is used for the pins. 20703 has 3 GPIO ports"
            not_in_binary_message
            decode_value = 0
            min = 0
            max = 3;

         PARAM "GPIO Port[0] Output Value"
            uint16
            doc "This variable indicates whether the output values of the pins of GPIO port0 are high when output is enabled."
            present_if ("Maximum Port Count" > 0);
         PARAM "GPIO Port[1] Output Value"
            uint16
            doc "This variable indicates whether the output values of the pins of GPIO port1 are high when output is enabled."
            present_if ("Maximum Port Count" > 1);
         PARAM "GPIO Port[2] Output Value"
            uint16
            doc "This variable indicates whether the output values of the pins of GPIO port2 are high when output is enabled."
            present_if ("Maximum Port Count" > 2);
         PARAM "GPIO Port[3] Output Value"
            uint16
            doc "This variable indicates whether the output values of the pins of GPIO port3 are high when output is enabled."
            present_if ("Maximum Port Count" > 3);

         PARAM "Port[0]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_0.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 0);
         PARAM "Pin[0]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_0 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 0);
         PARAM "RESERVED_1[0]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 0);
         PARAM "Output mux[0]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_0."
               "The default value is 0"
               present_if ("GPIO Count" > 0);
         PARAM "Hysteresis[0]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 0);
         PARAM "RESERVED_2[0]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 0);
         PARAM "Drive[0]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 0);
         PARAM "Pullup Pulldown[0]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 0);
         PARAM "RESERVED_3[0]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 0);
         PARAM "RESERVED_4[0]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 0);
         PARAM "Global input[0]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 0);
         PARAM "Output control[0]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_0 output."
               "The default value is 0"
               present_if ("GPIO Count" > 0);
         PARAM "Interrupt enable[0]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_0 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 0);
         PARAM "Dual edge trigger[0]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_0 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 0);
         PARAM "Negative edge trigger[0]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_0 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 0);
         PARAM "Edge trigger[0]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_0 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 0);






         PARAM "Port[1]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_1.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 1);
         PARAM "Pin[1]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_1 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 1);
         PARAM "RESERVED_1[1]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 1);
         PARAM "Output mux[1]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_1."
               "The default value is 0"
               present_if ("GPIO Count" > 1);
         PARAM "Hysteresis[1]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 1);
         PARAM "RESERVED_2[1]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 1);
         PARAM "Drive[1]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 1);
         PARAM "Pullup Pulldown[1]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 1);
         PARAM "RESERVED_3[1]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 1);
         PARAM "RESERVED_4[1]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 1);
         PARAM "Global input[1]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 1);
         PARAM "Output control[1]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_1 output."
               "The default value is 0"
               present_if ("GPIO Count" > 1);
         PARAM "Interrupt enable[1]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_1 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 1);
         PARAM "Dual edge trigger[1]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_1 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 1);
         PARAM "Negative edge trigger[1]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_1 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 1);
         PARAM "Edge trigger[1]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_1 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 1);






         PARAM "Port[2]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_2.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 2);
         PARAM "Pin[2]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_2 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 2);
         PARAM "RESERVED_1[2]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 2);
         PARAM "Output mux[2]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_2."
               "The default value is 0"
               present_if ("GPIO Count" > 2);
         PARAM "Hysteresis[2]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 2);
         PARAM "RESERVED_2[2]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 2);
         PARAM "Drive[2]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 2);
         PARAM "Pullup Pulldown[2]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 2);
         PARAM "RESERVED_3[2]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 2);
         PARAM "RESERVED_4[2]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 2);
         PARAM "Global input[2]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 2);
         PARAM "Output control[2]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_2 output."
               "The default value is 0"
               present_if ("GPIO Count" > 2);
         PARAM "Interrupt enable[2]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_2 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 2);
         PARAM "Dual edge trigger[2]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_2 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 2);
         PARAM "Negative edge trigger[2]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_2 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 2);
         PARAM "Edge trigger[2]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_2 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 2);






         PARAM "Port[3]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_3.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 3);
         PARAM "Pin[3]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_3 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 3);
         PARAM "RESERVED_1[3]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 3);
         PARAM "Output mux[3]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_3."
               "The default value is 0"
               present_if ("GPIO Count" > 3);
         PARAM "Hysteresis[3]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 3);
         PARAM "RESERVED_2[3]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 3);
         PARAM "Drive[3]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 3);
         PARAM "Pullup Pulldown[3]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 3);
         PARAM "RESERVED_3[3]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 3);
         PARAM "RESERVED_4[3]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 3);
         PARAM "Global input[3]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 3);
         PARAM "Output control[3]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_3 output."
               "The default value is 0"
               present_if ("GPIO Count" > 3);
         PARAM "Interrupt enable[3]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_3 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 3);
         PARAM "Dual edge trigger[3]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_3 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 3);
         PARAM "Negative edge trigger[3]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_3 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 3);
         PARAM "Edge trigger[3]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_3 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 3);






         PARAM "Port[4]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_4.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 4);
         PARAM "Pin[4]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_4 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 4);
         PARAM "RESERVED_1[4]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 4);
         PARAM "Output mux[4]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_4."
               "The default value is 0"
               present_if ("GPIO Count" > 4);
         PARAM "Hysteresis[4]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 4);
         PARAM "RESERVED_2[4]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 4);
         PARAM "Drive[4]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 4);
         PARAM "Pullup Pulldown[4]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 4);
         PARAM "RESERVED_3[4]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 4);
         PARAM "RESERVED_4[4]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 4);
         PARAM "Global input[4]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 4);
         PARAM "Output control[4]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_4 output."
               "The default value is 0"
               present_if ("GPIO Count" > 4);
         PARAM "Interrupt enable[4]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_4 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 4);
         PARAM "Dual edge trigger[4]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_4 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 4);
         PARAM "Negative edge trigger[4]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_4 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 4);
         PARAM "Edge trigger[4]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_4 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 4);






         PARAM "Port[5]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_5.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 5);
         PARAM "Pin[5]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_5 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 5);
         PARAM "RESERVED_1[5]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 5);
         PARAM "Output mux[5]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_5."
               "The default value is 0"
               present_if ("GPIO Count" > 5);
         PARAM "Hysteresis[5]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 5);
         PARAM "RESERVED_2[5]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 5);
         PARAM "Drive[5]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 5);
         PARAM "Pullup Pulldown[5]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 5);
         PARAM "RESERVED_3[5]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 5);
         PARAM "RESERVED_4[5]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 5);
         PARAM "Global input[5]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 5);
         PARAM "Output control[5]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_5 output."
               "The default value is 0"
               present_if ("GPIO Count" > 5);
         PARAM "Interrupt enable[5]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_5 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 5);
         PARAM "Dual edge trigger[5]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_5 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 5);
         PARAM "Negative edge trigger[5]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_5 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 5);
         PARAM "Edge trigger[5]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_5 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 5);






         PARAM "Port[6]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_6.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 6);
         PARAM "Pin[6]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_6 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 6);
         PARAM "RESERVED_1[6]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 6);
         PARAM "Output mux[6]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_6."
               "The default value is 0"
               present_if ("GPIO Count" > 6);
         PARAM "Hysteresis[6]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 6);
         PARAM "RESERVED_2[6]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 6);
         PARAM "Drive[6]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 6);
         PARAM "Pullup Pulldown[6]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 6);
         PARAM "RESERVED_3[6]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 6);
         PARAM "RESERVED_4[6]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 6);
         PARAM "Global input[6]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 6);
         PARAM "Output control[6]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_6 output."
               "The default value is 0"
               present_if ("GPIO Count" > 6);
         PARAM "Interrupt enable[6]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_6 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 6);
         PARAM "Dual edge trigger[6]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_6 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 6);
         PARAM "Negative edge trigger[6]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_6 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 6);
         PARAM "Edge trigger[6]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_6 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 6);






         PARAM "Port[7]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_7.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 7);
         PARAM "Pin[7]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_7 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 7);
         PARAM "RESERVED_1[7]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 7);
         PARAM "Output mux[7]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_7."
               "The default value is 0"
               present_if ("GPIO Count" > 7);
         PARAM "Hysteresis[7]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 7);
         PARAM "RESERVED_2[7]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 7);
         PARAM "Drive[7]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 7);
         PARAM "Pullup Pulldown[7]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 7);
         PARAM "RESERVED_3[7]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 7);
         PARAM "RESERVED_4[7]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 7);
         PARAM "Global input[7]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 7);
         PARAM "Output control[7]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_7 output."
               "The default value is 0"
               present_if ("GPIO Count" > 7);
         PARAM "Interrupt enable[7]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_7 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 7);
         PARAM "Dual edge trigger[7]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_7 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 7);
         PARAM "Negative edge trigger[7]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_7 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 7);
         PARAM "Edge trigger[7]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_7 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 7);






         PARAM "Port[8]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_8.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 8);
         PARAM "Pin[8]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_8 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 8);
         PARAM "RESERVED_1[8]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 8);
         PARAM "Output mux[8]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_8."
               "The default value is 0"
               present_if ("GPIO Count" > 8);
         PARAM "Hysteresis[8]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 8);
         PARAM "RESERVED_2[8]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 8);
         PARAM "Drive[8]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 8);
         PARAM "Pullup Pulldown[8]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 8);
         PARAM "RESERVED_3[8]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 8);
         PARAM "RESERVED_4[8]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 8);
         PARAM "Global input[8]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 8);
         PARAM "Output control[8]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_8 output."
               "The default value is 0"
               present_if ("GPIO Count" > 8);
         PARAM "Interrupt enable[8]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_8 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 8);
         PARAM "Dual edge trigger[8]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_8 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 8);
         PARAM "Negative edge trigger[8]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_8 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 8);
         PARAM "Edge trigger[8]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_8 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 8);






         PARAM "Port[9]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_9.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 9);
         PARAM "Pin[9]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_9 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 9);
         PARAM "RESERVED_1[9]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 9);
         PARAM "Output mux[9]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_9."
               "The default value is 0"
               present_if ("GPIO Count" > 9);
         PARAM "Hysteresis[9]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 9);
         PARAM "RESERVED_2[9]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 9);
         PARAM "Drive[9]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 9);
         PARAM "Pullup Pulldown[9]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 9);
         PARAM "RESERVED_3[9]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 9);
         PARAM "RESERVED_4[9]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 9);
         PARAM "Global input[9]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 9);
         PARAM "Output control[9]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_9 output."
               "The default value is 0"
               present_if ("GPIO Count" > 9);
         PARAM "Interrupt enable[9]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_9 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 9);
         PARAM "Dual edge trigger[9]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_9 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 9);
         PARAM "Negative edge trigger[9]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_9 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 9);
         PARAM "Edge trigger[9]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_9 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 9);






         PARAM "Port[10]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_10.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 10);
         PARAM "Pin[10]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_10 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 10);
         PARAM "RESERVED_1[10]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 10);
         PARAM "Output mux[10]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_10."
               "The default value is 0"
               present_if ("GPIO Count" > 10);
         PARAM "Hysteresis[10]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 10);
         PARAM "RESERVED_2[10]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 10);
         PARAM "Drive[10]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 10);
         PARAM "Pullup Pulldown[10]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 10);
         PARAM "RESERVED_3[10]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 10);
         PARAM "RESERVED_4[10]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 10);
         PARAM "Global input[10]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 10);
         PARAM "Output control[10]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_10 output."
               "The default value is 0"
               present_if ("GPIO Count" > 10);
         PARAM "Interrupt enable[10]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_10 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 10);
         PARAM "Dual edge trigger[10]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_10 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 10);
         PARAM "Negative edge trigger[10]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_10 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 10);
         PARAM "Edge trigger[10]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_10 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 10);






         PARAM "Port[11]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_11.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 11);
         PARAM "Pin[11]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_11 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 11);
         PARAM "RESERVED_1[11]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 11);
         PARAM "Output mux[11]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_11."
               "The default value is 0"
               present_if ("GPIO Count" > 11);
         PARAM "Hysteresis[11]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 11);
         PARAM "RESERVED_2[11]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 11);
         PARAM "Drive[11]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 11);
         PARAM "Pullup Pulldown[11]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 11);
         PARAM "RESERVED_3[11]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 11);
         PARAM "RESERVED_4[11]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 11);
         PARAM "Global input[11]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 11);
         PARAM "Output control[11]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_11 output."
               "The default value is 0"
               present_if ("GPIO Count" > 11);
         PARAM "Interrupt enable[11]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_11 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 11);
         PARAM "Dual edge trigger[11]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_11 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 11);
         PARAM "Negative edge trigger[11]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_11 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 11);
         PARAM "Edge trigger[11]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_11 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 11);






         PARAM "Port[12]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_12.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 12);
         PARAM "Pin[12]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_12 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 12);
         PARAM "RESERVED_1[12]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 12);
         PARAM "Output mux[12]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_12."
               "The default value is 0"
               present_if ("GPIO Count" > 12);
         PARAM "Hysteresis[12]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 12);
         PARAM "RESERVED_2[12]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 12);
         PARAM "Drive[12]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 12);
         PARAM "Pullup Pulldown[12]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 12);
         PARAM "RESERVED_3[12]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 12);
         PARAM "RESERVED_4[12]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 12);
         PARAM "Global input[12]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 12);
         PARAM "Output control[12]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_12 output."
               "The default value is 0"
               present_if ("GPIO Count" > 12);
         PARAM "Interrupt enable[12]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_12 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 12);
         PARAM "Dual edge trigger[12]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_12 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 12);
         PARAM "Negative edge trigger[12]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_12 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 12);
         PARAM "Edge trigger[12]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_12 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 12);






         PARAM "Port[13]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_13.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 13);
         PARAM "Pin[13]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_13 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 13);
         PARAM "RESERVED_1[13]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 13);
         PARAM "Output mux[13]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_13."
               "The default value is 0"
               present_if ("GPIO Count" > 13);
         PARAM "Hysteresis[13]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 13);
         PARAM "RESERVED_2[13]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 13);
         PARAM "Drive[13]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 13);
         PARAM "Pullup Pulldown[13]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 13);
         PARAM "RESERVED_3[13]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 13);
         PARAM "RESERVED_4[13]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 13);
         PARAM "Global input[13]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 13);
         PARAM "Output control[13]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_13 output."
               "The default value is 0"
               present_if ("GPIO Count" > 13);
         PARAM "Interrupt enable[13]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_13 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 13);
         PARAM "Dual edge trigger[13]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_13 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 13);
         PARAM "Negative edge trigger[13]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_13 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 13);
         PARAM "Edge trigger[13]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_13 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 13);






         PARAM "Port[14]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_14.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 14);
         PARAM "Pin[14]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_14 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 14);
         PARAM "RESERVED_1[14]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 14);
         PARAM "Output mux[14]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_14."
               "The default value is 0"
               present_if ("GPIO Count" > 14);
         PARAM "Hysteresis[14]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 14);
         PARAM "RESERVED_2[14]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 14);
         PARAM "Drive[14]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 14);
         PARAM "Pullup Pulldown[14]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 14);
         PARAM "RESERVED_3[14]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 14);
         PARAM "RESERVED_4[14]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 14);
         PARAM "Global input[14]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 14);
         PARAM "Output control[14]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_14 output."
               "The default value is 0"
               present_if ("GPIO Count" > 14);
         PARAM "Interrupt enable[14]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_14 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 14);
         PARAM "Dual edge trigger[14]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_14 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 14);
         PARAM "Negative edge trigger[14]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_14 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 14);
         PARAM "Edge trigger[14]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_14 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 14);






         PARAM "Port[15]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_15.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 15);
         PARAM "Pin[15]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_15 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 15);
         PARAM "RESERVED_1[15]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 15);
         PARAM "Output mux[15]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_15."
               "The default value is 0"
               present_if ("GPIO Count" > 15);
         PARAM "Hysteresis[15]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 15);
         PARAM "RESERVED_2[15]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 15);
         PARAM "Drive[15]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 15);
         PARAM "Pullup Pulldown[15]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 15);
         PARAM "RESERVED_3[15]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 15);
         PARAM "RESERVED_4[15]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 15);
         PARAM "Global input[15]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 15);
         PARAM "Output control[15]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_15 output."
               "The default value is 0"
               present_if ("GPIO Count" > 15);
         PARAM "Interrupt enable[15]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_15 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 15);
         PARAM "Dual edge trigger[15]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_15 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 15);
         PARAM "Negative edge trigger[15]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_15 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 15);
         PARAM "Edge trigger[15]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_15 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 15);






         PARAM "Port[16]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_16.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 16);
         PARAM "Pin[16]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_16 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 16);
         PARAM "RESERVED_1[16]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 16);
         PARAM "Output mux[16]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_16."
               "The default value is 0"
               present_if ("GPIO Count" > 16);
         PARAM "Hysteresis[16]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 16);
         PARAM "RESERVED_2[16]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 16);
         PARAM "Drive[16]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 16);
         PARAM "Pullup Pulldown[16]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 16);
         PARAM "RESERVED_3[16]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 16);
         PARAM "RESERVED_4[16]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 16);
         PARAM "Global input[16]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 16);
         PARAM "Output control[16]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_16 output."
               "The default value is 0"
               present_if ("GPIO Count" > 16);
         PARAM "Interrupt enable[16]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_16 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 16);
         PARAM "Dual edge trigger[16]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_16 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 16);
         PARAM "Negative edge trigger[16]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_16 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 16);
         PARAM "Edge trigger[16]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_16 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 16);






         PARAM "Port[17]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_17.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 17);
         PARAM "Pin[17]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_17 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 17);
         PARAM "RESERVED_1[17]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 17);
         PARAM "Output mux[17]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_17."
               "The default value is 0"
               present_if ("GPIO Count" > 17);
         PARAM "Hysteresis[17]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 17);
         PARAM "RESERVED_2[17]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 17);
         PARAM "Drive[17]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 17);
         PARAM "Pullup Pulldown[17]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 17);
         PARAM "RESERVED_3[17]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 17);
         PARAM "RESERVED_4[17]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 17);
         PARAM "Global input[17]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 17);
         PARAM "Output control[17]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_17 output."
               "The default value is 0"
               present_if ("GPIO Count" > 17);
         PARAM "Interrupt enable[17]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_17 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 17);
         PARAM "Dual edge trigger[17]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_17 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 17);
         PARAM "Negative edge trigger[17]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_17 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 17);
         PARAM "Edge trigger[17]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_17 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 17);






         PARAM "Port[18]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_18.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 18);
         PARAM "Pin[18]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_18 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 18);
         PARAM "RESERVED_1[18]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 18);
         PARAM "Output mux[18]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_18."
               "The default value is 0"
               present_if ("GPIO Count" > 18);
         PARAM "Hysteresis[18]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 18);
         PARAM "RESERVED_2[18]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 18);
         PARAM "Drive[18]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 18);
         PARAM "Pullup Pulldown[18]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 18);
         PARAM "RESERVED_3[18]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 18);
         PARAM "RESERVED_4[18]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 18);
         PARAM "Global input[18]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 18);
         PARAM "Output control[18]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_18 output."
               "The default value is 0"
               present_if ("GPIO Count" > 18);
         PARAM "Interrupt enable[18]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_18 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 18);
         PARAM "Dual edge trigger[18]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_18 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 18);
         PARAM "Negative edge trigger[18]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_18 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 18);
         PARAM "Edge trigger[18]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_18 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 18);






         PARAM "Port[19]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_19.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 19);
         PARAM "Pin[19]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_19 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 19);
         PARAM "RESERVED_1[19]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 19);
         PARAM "Output mux[19]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_19."
               "The default value is 0"
               present_if ("GPIO Count" > 19);
         PARAM "Hysteresis[19]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 19);
         PARAM "RESERVED_2[19]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 19);
         PARAM "Drive[19]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 19);
         PARAM "Pullup Pulldown[19]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 19);
         PARAM "RESERVED_3[19]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 19);
         PARAM "RESERVED_4[19]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 19);
         PARAM "Global input[19]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 19);
         PARAM "Output control[19]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_19 output."
               "The default value is 0"
               present_if ("GPIO Count" > 19);
         PARAM "Interrupt enable[19]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_19 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 19);
         PARAM "Dual edge trigger[19]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_19 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 19);
         PARAM "Negative edge trigger[19]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_19 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 19);
         PARAM "Edge trigger[19]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_19 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 19);






         PARAM "Port[20]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_20.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 20);
         PARAM "Pin[20]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_20 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 20);
         PARAM "RESERVED_1[20]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 20);
         PARAM "Output mux[20]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_20."
               "The default value is 0"
               present_if ("GPIO Count" > 20);
         PARAM "Hysteresis[20]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 20);
         PARAM "RESERVED_2[20]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 20);
         PARAM "Drive[20]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 20);
         PARAM "Pullup Pulldown[20]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 20);
         PARAM "RESERVED_3[20]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 20);
         PARAM "RESERVED_4[20]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 20);
         PARAM "Global input[20]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 20);
         PARAM "Output control[20]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_20 output."
               "The default value is 0"
               present_if ("GPIO Count" > 20);
         PARAM "Interrupt enable[20]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_20 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 20);
         PARAM "Dual edge trigger[20]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_20 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 20);
         PARAM "Negative edge trigger[20]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_20 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 20);
         PARAM "Edge trigger[20]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_20 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 20);






         PARAM "Port[21]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_21.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 21);
         PARAM "Pin[21]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_21 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 21);
         PARAM "RESERVED_1[21]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 21);
         PARAM "Output mux[21]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_21."
               "The default value is 0"
               present_if ("GPIO Count" > 21);
         PARAM "Hysteresis[21]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 21);
         PARAM "RESERVED_2[21]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 21);
         PARAM "Drive[21]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 21);
         PARAM "Pullup Pulldown[21]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 21);
         PARAM "RESERVED_3[21]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 21);
         PARAM "RESERVED_4[21]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 21);
         PARAM "Global input[21]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 21);
         PARAM "Output control[21]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_21 output."
               "The default value is 0"
               present_if ("GPIO Count" > 21);
         PARAM "Interrupt enable[21]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_21 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 21);
         PARAM "Dual edge trigger[21]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_21 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 21);
         PARAM "Negative edge trigger[21]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_21 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 21);
         PARAM "Edge trigger[21]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_21 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 21);






         PARAM "Port[22]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_22.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 22);
         PARAM "Pin[22]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_22 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 22);
         PARAM "RESERVED_1[22]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 22);
         PARAM "Output mux[22]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_22."
               "The default value is 0"
               present_if ("GPIO Count" > 22);
         PARAM "Hysteresis[22]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 22);
         PARAM "RESERVED_2[22]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 22);
         PARAM "Drive[22]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 22);
         PARAM "Pullup Pulldown[22]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 22);
         PARAM "RESERVED_3[22]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 22);
         PARAM "RESERVED_4[22]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 22);
         PARAM "Global input[22]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 22);
         PARAM "Output control[22]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_22 output."
               "The default value is 0"
               present_if ("GPIO Count" > 22);
         PARAM "Interrupt enable[22]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_22 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 22);
         PARAM "Dual edge trigger[22]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_22 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 22);
         PARAM "Negative edge trigger[22]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_22 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 22);
         PARAM "Edge trigger[22]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_22 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 22);






         PARAM "Port[23]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_23.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 23);
         PARAM "Pin[23]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_23 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 23);
         PARAM "RESERVED_1[23]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 23);
         PARAM "Output mux[23]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_23."
               "The default value is 0"
               present_if ("GPIO Count" > 23);
         PARAM "Hysteresis[23]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 23);
         PARAM "RESERVED_2[23]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 23);
         PARAM "Drive[23]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 23);
         PARAM "Pullup Pulldown[23]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 23);
         PARAM "RESERVED_3[23]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 23);
         PARAM "RESERVED_4[23]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 23);
         PARAM "Global input[23]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 23);
         PARAM "Output control[23]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_23 output."
               "The default value is 0"
               present_if ("GPIO Count" > 23);
         PARAM "Interrupt enable[23]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_23 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 23);
         PARAM "Dual edge trigger[23]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_23 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 23);
         PARAM "Negative edge trigger[23]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_23 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 23);
         PARAM "Edge trigger[23]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_23 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 23);






         PARAM "Port[24]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_24.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 24);
         PARAM "Pin[24]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_24 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 24);
         PARAM "RESERVED_1[24]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 24);
         PARAM "Output mux[24]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_24."
               "The default value is 0"
               present_if ("GPIO Count" > 24);
         PARAM "Hysteresis[24]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 24);
         PARAM "RESERVED_2[24]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 24);
         PARAM "Drive[24]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 24);
         PARAM "Pullup Pulldown[24]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 24);
         PARAM "RESERVED_3[24]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 24);
         PARAM "RESERVED_4[24]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 24);
         PARAM "Global input[24]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 24);
         PARAM "Output control[24]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_24 output."
               "The default value is 0"
               present_if ("GPIO Count" > 24);
         PARAM "Interrupt enable[24]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_24 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 24);
         PARAM "Dual edge trigger[24]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_24 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 24);
         PARAM "Negative edge trigger[24]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_24 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 24);
         PARAM "Edge trigger[24]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_24 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 24);






         PARAM "Port[25]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_25.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 25);
         PARAM "Pin[25]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_25 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 25);
         PARAM "RESERVED_1[25]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 25);
         PARAM "Output mux[25]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_25."
               "The default value is 0"
               present_if ("GPIO Count" > 25);
         PARAM "Hysteresis[25]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 25);
         PARAM "RESERVED_2[25]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 25);
         PARAM "Drive[25]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 25);
         PARAM "Pullup Pulldown[25]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 25);
         PARAM "RESERVED_3[25]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 25);
         PARAM "RESERVED_4[25]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 25);
         PARAM "Global input[25]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 25);
         PARAM "Output control[25]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_25 output."
               "The default value is 0"
               present_if ("GPIO Count" > 25);
         PARAM "Interrupt enable[25]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_25 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 25);
         PARAM "Dual edge trigger[25]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_25 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 25);
         PARAM "Negative edge trigger[25]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_25 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 25);
         PARAM "Edge trigger[25]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_25 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 25);






         PARAM "Port[26]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_26.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 26);
         PARAM "Pin[26]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_26 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 26);
         PARAM "RESERVED_1[26]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 26);
         PARAM "Output mux[26]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_26."
               "The default value is 0"
               present_if ("GPIO Count" > 26);
         PARAM "Hysteresis[26]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 26);
         PARAM "RESERVED_2[26]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 26);
         PARAM "Drive[26]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 26);
         PARAM "Pullup Pulldown[26]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 26);
         PARAM "RESERVED_3[26]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 26);
         PARAM "RESERVED_4[26]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 26);
         PARAM "Global input[26]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 26);
         PARAM "Output control[26]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_26 output."
               "The default value is 0"
               present_if ("GPIO Count" > 26);
         PARAM "Interrupt enable[26]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_26 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 26);
         PARAM "Dual edge trigger[26]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_26 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 26);
         PARAM "Negative edge trigger[26]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_26 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 26);
         PARAM "Edge trigger[26]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_26 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 26);






         PARAM "Port[27]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_27.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 27);
         PARAM "Pin[27]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_27 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 27);
         PARAM "RESERVED_1[27]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 27);
         PARAM "Output mux[27]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_27."
               "The default value is 0"
               present_if ("GPIO Count" > 27);
         PARAM "Hysteresis[27]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 27);
         PARAM "RESERVED_2[27]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 27);
         PARAM "Drive[27]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 27);
         PARAM "Pullup Pulldown[27]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 27);
         PARAM "RESERVED_3[27]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 27);
         PARAM "RESERVED_4[27]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 27);
         PARAM "Global input[27]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 27);
         PARAM "Output control[27]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_27 output."
               "The default value is 0"
               present_if ("GPIO Count" > 27);
         PARAM "Interrupt enable[27]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_27 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 27);
         PARAM "Dual edge trigger[27]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_27 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 27);
         PARAM "Negative edge trigger[27]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_27 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 27);
         PARAM "Edge trigger[27]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_27 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 27);






         PARAM "Port[28]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_28.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 28);
         PARAM "Pin[28]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_28 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 28);
         PARAM "RESERVED_1[28]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 28);
         PARAM "Output mux[28]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_28."
               "The default value is 0"
               present_if ("GPIO Count" > 28);
         PARAM "Hysteresis[28]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 28);
         PARAM "RESERVED_2[28]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 28);
         PARAM "Drive[28]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 28);
         PARAM "Pullup Pulldown[28]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 28);
         PARAM "RESERVED_3[28]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 28);
         PARAM "RESERVED_4[28]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 28);
         PARAM "Global input[28]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 28);
         PARAM "Output control[28]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_28 output."
               "The default value is 0"
               present_if ("GPIO Count" > 28);
         PARAM "Interrupt enable[28]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_28 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 28);
         PARAM "Dual edge trigger[28]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_28 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 28);
         PARAM "Negative edge trigger[28]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_28 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 28);
         PARAM "Edge trigger[28]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_28 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 28);






         PARAM "Port[29]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_29.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 29);
         PARAM "Pin[29]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_29 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 29);
         PARAM "RESERVED_1[29]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 29);
         PARAM "Output mux[29]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_29."
               "The default value is 0"
               present_if ("GPIO Count" > 29);
         PARAM "Hysteresis[29]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 29);
         PARAM "RESERVED_2[29]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 29);
         PARAM "Drive[29]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 29);
         PARAM "Pullup Pulldown[29]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 29);
         PARAM "RESERVED_3[29]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 29);
         PARAM "RESERVED_4[29]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 29);
         PARAM "Global input[29]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 29);
         PARAM "Output control[29]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_29 output."
               "The default value is 0"
               present_if ("GPIO Count" > 29);
         PARAM "Interrupt enable[29]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_29 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 29);
         PARAM "Dual edge trigger[29]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_29 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 29);
         PARAM "Negative edge trigger[29]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_29 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 29);
         PARAM "Edge trigger[29]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_29 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 29);






         PARAM "Port[30]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_30.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 30);
         PARAM "Pin[30]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_30 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 30);
         PARAM "RESERVED_1[30]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 30);
         PARAM "Output mux[30]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_30."
               "The default value is 0"
               present_if ("GPIO Count" > 30);
         PARAM "Hysteresis[30]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 30);
         PARAM "RESERVED_2[30]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 30);
         PARAM "Drive[30]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 30);
         PARAM "Pullup Pulldown[30]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 30);
         PARAM "RESERVED_3[30]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 30);
         PARAM "RESERVED_4[30]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 30);
         PARAM "Global input[30]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 30);
         PARAM "Output control[30]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_30 output."
               "The default value is 0"
               present_if ("GPIO Count" > 30);
         PARAM "Interrupt enable[30]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_30 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 30);
         PARAM "Dual edge trigger[30]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_30 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 30);
         PARAM "Negative edge trigger[30]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_30 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 30);
         PARAM "Edge trigger[30]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_30 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 30);






         PARAM "Port[31]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_31.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 31);
         PARAM "Pin[31]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_31 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 31);
         PARAM "RESERVED_1[31]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 31);
         PARAM "Output mux[31]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_31."
               "The default value is 0"
               present_if ("GPIO Count" > 31);
         PARAM "Hysteresis[31]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 31);
         PARAM "RESERVED_2[31]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 31);
         PARAM "Drive[31]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 31);
         PARAM "Pullup Pulldown[31]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 31);
         PARAM "RESERVED_3[31]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 31);
         PARAM "RESERVED_4[31]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 31);
         PARAM "Global input[31]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 31);
         PARAM "Output control[31]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_31 output."
               "The default value is 0"
               present_if ("GPIO Count" > 31);
         PARAM "Interrupt enable[31]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_31 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 31);
         PARAM "Dual edge trigger[31]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_31 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 31);
         PARAM "Negative edge trigger[31]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_31 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 31);
         PARAM "Edge trigger[31]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_31 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 31);






         PARAM "Port[32]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_32.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 32);
         PARAM "Pin[32]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_32 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 32);
         PARAM "RESERVED_1[32]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 32);
         PARAM "Output mux[32]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_32."
               "The default value is 0"
               present_if ("GPIO Count" > 32);
         PARAM "Hysteresis[32]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 32);
         PARAM "RESERVED_2[32]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 32);
         PARAM "Drive[32]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 32);
         PARAM "Pullup Pulldown[32]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 32);
         PARAM "RESERVED_3[32]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 32);
         PARAM "RESERVED_4[32]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 32);
         PARAM "Global input[32]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 32);
         PARAM "Output control[32]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_32 output."
               "The default value is 0"
               present_if ("GPIO Count" > 32);
         PARAM "Interrupt enable[32]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_32 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 32);
         PARAM "Dual edge trigger[32]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_32 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 32);
         PARAM "Negative edge trigger[32]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_32 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 32);
         PARAM "Edge trigger[32]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_32 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 32);






         PARAM "Port[33]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_33.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 33);
         PARAM "Pin[33]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_33 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 33);
         PARAM "RESERVED_1[33]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 33);
         PARAM "Output mux[33]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_33."
               "The default value is 0"
               present_if ("GPIO Count" > 33);
         PARAM "Hysteresis[33]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 33);
         PARAM "RESERVED_2[33]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 33);
         PARAM "Drive[33]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 33);
         PARAM "Pullup Pulldown[33]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 33);
         PARAM "RESERVED_3[33]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 33);
         PARAM "RESERVED_4[33]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 33);
         PARAM "Global input[33]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 33);
         PARAM "Output control[33]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_33 output."
               "The default value is 0"
               present_if ("GPIO Count" > 33);
         PARAM "Interrupt enable[33]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_33 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 33);
         PARAM "Dual edge trigger[33]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_33 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 33);
         PARAM "Negative edge trigger[33]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_33 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 33);
         PARAM "Edge trigger[33]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_33 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 33);






         PARAM "Port[34]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_34.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 34);
         PARAM "Pin[34]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_34 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 34);
         PARAM "RESERVED_1[34]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 34);
         PARAM "Output mux[34]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_34."
               "The default value is 0"
               present_if ("GPIO Count" > 34);
         PARAM "Hysteresis[34]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 34);
         PARAM "RESERVED_2[34]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 34);
         PARAM "Drive[34]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 34);
         PARAM "Pullup Pulldown[34]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 34);
         PARAM "RESERVED_3[34]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 34);
         PARAM "RESERVED_4[34]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 34);
         PARAM "Global input[34]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 34);
         PARAM "Output control[34]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_34 output."
               "The default value is 0"
               present_if ("GPIO Count" > 34);
         PARAM "Interrupt enable[34]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_34 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 34);
         PARAM "Dual edge trigger[34]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_34 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 34);
         PARAM "Negative edge trigger[34]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_34 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 34);
         PARAM "Edge trigger[34]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_34 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 34);






         PARAM "Port[35]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_35.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 35);
         PARAM "Pin[35]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_35 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 35);
         PARAM "RESERVED_1[35]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 35);
         PARAM "Output mux[35]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_35."
               "The default value is 0"
               present_if ("GPIO Count" > 35);
         PARAM "Hysteresis[35]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 35);
         PARAM "RESERVED_2[35]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 35);
         PARAM "Drive[35]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 35);
         PARAM "Pullup Pulldown[35]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 35);
         PARAM "RESERVED_3[35]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 35);
         PARAM "RESERVED_4[35]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 35);
         PARAM "Global input[35]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 35);
         PARAM "Output control[35]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_35 output."
               "The default value is 0"
               present_if ("GPIO Count" > 35);
         PARAM "Interrupt enable[35]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_35 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 35);
         PARAM "Dual edge trigger[35]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_35 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 35);
         PARAM "Negative edge trigger[35]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_35 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 35);
         PARAM "Edge trigger[35]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_35 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 35);






         PARAM "Port[36]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_36.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 36);
         PARAM "Pin[36]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_36 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 36);
         PARAM "RESERVED_1[36]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 36);
         PARAM "Output mux[36]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_36."
               "The default value is 0"
               present_if ("GPIO Count" > 36);
         PARAM "Hysteresis[36]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 36);
         PARAM "RESERVED_2[36]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 36);
         PARAM "Drive[36]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 36);
         PARAM "Pullup Pulldown[36]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 36);
         PARAM "RESERVED_3[36]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 36);
         PARAM "RESERVED_4[36]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 36);
         PARAM "Global input[36]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 36);
         PARAM "Output control[36]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_36 output."
               "The default value is 0"
               present_if ("GPIO Count" > 36);
         PARAM "Interrupt enable[36]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_36 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 36);
         PARAM "Dual edge trigger[36]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_36 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 36);
         PARAM "Negative edge trigger[36]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_36 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 36);
         PARAM "Edge trigger[36]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_36 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 36);






         PARAM "Port[37]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_37.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 37);
         PARAM "Pin[37]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_37 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 37);
         PARAM "RESERVED_1[37]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 37);
         PARAM "Output mux[37]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_37."
               "The default value is 0"
               present_if ("GPIO Count" > 37);
         PARAM "Hysteresis[37]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 37);
         PARAM "RESERVED_2[37]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 37);
         PARAM "Drive[37]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 37);
         PARAM "Pullup Pulldown[37]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 37);
         PARAM "RESERVED_3[37]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 37);
         PARAM "RESERVED_4[37]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 37);
         PARAM "Global input[37]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 37);
         PARAM "Output control[37]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_37 output."
               "The default value is 0"
               present_if ("GPIO Count" > 37);
         PARAM "Interrupt enable[37]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_37 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 37);
         PARAM "Dual edge trigger[37]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_37 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 37);
         PARAM "Negative edge trigger[37]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_37 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 37);
         PARAM "Edge trigger[37]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_37 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 37);






         PARAM "Port[38]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_38.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 38);
         PARAM "Pin[38]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_38 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 38);
         PARAM "RESERVED_1[38]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 38);
         PARAM "Output mux[38]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_38."
               "The default value is 0"
               present_if ("GPIO Count" > 38);
         PARAM "Hysteresis[38]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 38);
         PARAM "RESERVED_2[38]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 38);
         PARAM "Drive[38]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 38);
         PARAM "Pullup Pulldown[38]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 38);
         PARAM "RESERVED_3[38]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 38);
         PARAM "RESERVED_4[38]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 38);
         PARAM "Global input[38]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 38);
         PARAM "Output control[38]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_38 output."
               "The default value is 0"
               present_if ("GPIO Count" > 38);
         PARAM "Interrupt enable[38]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_38 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 38);
         PARAM "Dual edge trigger[38]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_38 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 38);
         PARAM "Negative edge trigger[38]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_38 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 38);
         PARAM "Edge trigger[38]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_38 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 38);






         PARAM "Port[39]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_39.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 39);
         PARAM "Pin[39]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_39 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 39);
         PARAM "RESERVED_1[39]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 39);
         PARAM "Output mux[39]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_39."
               "The default value is 0"
               present_if ("GPIO Count" > 39);
         PARAM "Hysteresis[39]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 39);
         PARAM "RESERVED_2[39]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 39);
         PARAM "Drive[39]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 39);
         PARAM "Pullup Pulldown[39]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 39);
         PARAM "RESERVED_3[39]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 39);
         PARAM "RESERVED_4[39]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 39);
         PARAM "Global input[39]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 39);
         PARAM "Output control[39]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_39 output."
               "The default value is 0"
               present_if ("GPIO Count" > 39);
         PARAM "Interrupt enable[39]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_39 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 39);
         PARAM "Dual edge trigger[39]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_39 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 39);
         PARAM "Negative edge trigger[39]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_39 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 39);
         PARAM "Edge trigger[39]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_39 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 39);






         PARAM "Port[40]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_40.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 40);
         PARAM "Pin[40]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_40 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 40);
         PARAM "RESERVED_1[40]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 40);
         PARAM "Output mux[40]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_40."
               "The default value is 0"
               present_if ("GPIO Count" > 40);
         PARAM "Hysteresis[40]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 40);
         PARAM "RESERVED_2[40]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 40);
         PARAM "Drive[40]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 40);
         PARAM "Pullup Pulldown[40]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 40);
         PARAM "RESERVED_3[40]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 40);
         PARAM "RESERVED_4[40]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 40);
         PARAM "Global input[40]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 40);
         PARAM "Output control[40]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_40 output."
               "The default value is 0"
               present_if ("GPIO Count" > 40);
         PARAM "Interrupt enable[40]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_40 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 40);
         PARAM "Dual edge trigger[40]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_40 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 40);
         PARAM "Negative edge trigger[40]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_40 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 40);
         PARAM "Edge trigger[40]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_40 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 40);






         PARAM "Port[41]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_41.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 41);
         PARAM "Pin[41]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_41 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 41);
         PARAM "RESERVED_1[41]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 41);
         PARAM "Output mux[41]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_41."
               "The default value is 0"
               present_if ("GPIO Count" > 41);
         PARAM "Hysteresis[41]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 41);
         PARAM "RESERVED_2[41]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 41);
         PARAM "Drive[41]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 41);
         PARAM "Pullup Pulldown[41]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 41);
         PARAM "RESERVED_3[41]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 41);
         PARAM "RESERVED_4[41]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 41);
         PARAM "Global input[41]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 41);
         PARAM "Output control[41]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_41 output."
               "The default value is 0"
               present_if ("GPIO Count" > 41);
         PARAM "Interrupt enable[41]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_41 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 41);
         PARAM "Dual edge trigger[41]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_41 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 41);
         PARAM "Negative edge trigger[41]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_41 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 41);
         PARAM "Edge trigger[41]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_41 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 41);






         PARAM "Port[42]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_42.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 42);
         PARAM "Pin[42]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_42 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 42);
         PARAM "RESERVED_1[42]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 42);
         PARAM "Output mux[42]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_42."
               "The default value is 0"
               present_if ("GPIO Count" > 42);
         PARAM "Hysteresis[42]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 42);
         PARAM "RESERVED_2[42]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 42);
         PARAM "Drive[42]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 42);
         PARAM "Pullup Pulldown[42]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 42);
         PARAM "RESERVED_3[42]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 42);
         PARAM "RESERVED_4[42]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 42);
         PARAM "Global input[42]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 42);
         PARAM "Output control[42]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_42 output."
               "The default value is 0"
               present_if ("GPIO Count" > 42);
         PARAM "Interrupt enable[42]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_42 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 42);
         PARAM "Dual edge trigger[42]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_42 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 42);
         PARAM "Negative edge trigger[42]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_42 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 42);
         PARAM "Edge trigger[42]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_42 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 42);






         PARAM "Port[43]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_43.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 43);
         PARAM "Pin[43]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_43 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 43);
         PARAM "RESERVED_1[43]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 43);
         PARAM "Output mux[43]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_43."
               "The default value is 0"
               present_if ("GPIO Count" > 43);
         PARAM "Hysteresis[43]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 43);
         PARAM "RESERVED_2[43]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 43);
         PARAM "Drive[43]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 43);
         PARAM "Pullup Pulldown[43]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 43);
         PARAM "RESERVED_3[43]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 43);
         PARAM "RESERVED_4[43]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 43);
         PARAM "Global input[43]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 43);
         PARAM "Output control[43]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_43 output."
               "The default value is 0"
               present_if ("GPIO Count" > 43);
         PARAM "Interrupt enable[43]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_43 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 43);
         PARAM "Dual edge trigger[43]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_43 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 43);
         PARAM "Negative edge trigger[43]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_43 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 43);
         PARAM "Edge trigger[43]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_43 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 43);






         PARAM "Port[44]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_44.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 44);
         PARAM "Pin[44]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_44 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 44);
         PARAM "RESERVED_1[44]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 44);
         PARAM "Output mux[44]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_44."
               "The default value is 0"
               present_if ("GPIO Count" > 44);
         PARAM "Hysteresis[44]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 44);
         PARAM "RESERVED_2[44]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 44);
         PARAM "Drive[44]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 44);
         PARAM "Pullup Pulldown[44]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 44);
         PARAM "RESERVED_3[44]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 44);
         PARAM "RESERVED_4[44]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 44);
         PARAM "Global input[44]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 44);
         PARAM "Output control[44]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_44 output."
               "The default value is 0"
               present_if ("GPIO Count" > 44);
         PARAM "Interrupt enable[44]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_44 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 44);
         PARAM "Dual edge trigger[44]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_44 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 44);
         PARAM "Negative edge trigger[44]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_44 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 44);
         PARAM "Edge trigger[44]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_44 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 44);






         PARAM "Port[45]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_45.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 45);
         PARAM "Pin[45]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_45 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 45);
         PARAM "RESERVED_1[45]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 45);
         PARAM "Output mux[45]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_45."
               "The default value is 0"
               present_if ("GPIO Count" > 45);
         PARAM "Hysteresis[45]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 45);
         PARAM "RESERVED_2[45]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 45);
         PARAM "Drive[45]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 45);
         PARAM "Pullup Pulldown[45]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 45);
         PARAM "RESERVED_3[45]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 45);
         PARAM "RESERVED_4[45]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 45);
         PARAM "Global input[45]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 45);
         PARAM "Output control[45]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_45 output."
               "The default value is 0"
               present_if ("GPIO Count" > 45);
         PARAM "Interrupt enable[45]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_45 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 45);
         PARAM "Dual edge trigger[45]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_45 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 45);
         PARAM "Negative edge trigger[45]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_45 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 45);
         PARAM "Edge trigger[45]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_45 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 45);






         PARAM "Port[46]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_46.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 46);
         PARAM "Pin[46]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_46 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 46);
         PARAM "RESERVED_1[46]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 46);
         PARAM "Output mux[46]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_46."
               "The default value is 0"
               present_if ("GPIO Count" > 46);
         PARAM "Hysteresis[46]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 46);
         PARAM "RESERVED_2[46]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 46);
         PARAM "Drive[46]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 46);
         PARAM "Pullup Pulldown[46]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 46);
         PARAM "RESERVED_3[46]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 46);
         PARAM "RESERVED_4[46]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 46);
         PARAM "Global input[46]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 46);
         PARAM "Output control[46]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_46 output."
               "The default value is 0"
               present_if ("GPIO Count" > 46);
         PARAM "Interrupt enable[46]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_46 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 46);
         PARAM "Dual edge trigger[46]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_46 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 46);
         PARAM "Negative edge trigger[46]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_46 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 46);
         PARAM "Edge trigger[46]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_46 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 46);






         PARAM "Port[47]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_47.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 47);
         PARAM "Pin[47]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_47 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 47);
         PARAM "RESERVED_1[47]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 47);
         PARAM "Output mux[47]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_47."
               "The default value is 0"
               present_if ("GPIO Count" > 47);
         PARAM "Hysteresis[47]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 47);
         PARAM "RESERVED_2[47]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 47);
         PARAM "Drive[47]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 47);
         PARAM "Pullup Pulldown[47]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 47);
         PARAM "RESERVED_3[47]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 47);
         PARAM "RESERVED_4[47]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 47);
         PARAM "Global input[47]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 47);
         PARAM "Output control[47]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_47 output."
               "The default value is 0"
               present_if ("GPIO Count" > 47);
         PARAM "Interrupt enable[47]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_47 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 47);
         PARAM "Dual edge trigger[47]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_47 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 47);
         PARAM "Negative edge trigger[47]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_47 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 47);
         PARAM "Edge trigger[47]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_47 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 47);






         PARAM "Port[48]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_48.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 48);
         PARAM "Pin[48]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_48 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 48);
         PARAM "RESERVED_1[48]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 48);
         PARAM "Output mux[48]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_48."
               "The default value is 0"
               present_if ("GPIO Count" > 48);
         PARAM "Hysteresis[48]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 48);
         PARAM "RESERVED_2[48]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 48);
         PARAM "Drive[48]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 48);
         PARAM "Pullup Pulldown[48]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 48);
         PARAM "RESERVED_3[48]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 48);
         PARAM "RESERVED_4[48]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 48);
         PARAM "Global input[48]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 48);
         PARAM "Output control[48]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_48 output."
               "The default value is 0"
               present_if ("GPIO Count" > 48);
         PARAM "Interrupt enable[48]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_48 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 48);
         PARAM "Dual edge trigger[48]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_48 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 48);
         PARAM "Negative edge trigger[48]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_48 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 48);
         PARAM "Edge trigger[48]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_48 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 48);






         PARAM "Port[49]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_49.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 49);
         PARAM "Pin[49]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_49 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 49);
         PARAM "RESERVED_1[49]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 49);
         PARAM "Output mux[49]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_49."
               "The default value is 0"
               present_if ("GPIO Count" > 49);
         PARAM "Hysteresis[49]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 49);
         PARAM "RESERVED_2[49]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 49);
         PARAM "Drive[49]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 49);
         PARAM "Pullup Pulldown[49]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 49);
         PARAM "RESERVED_3[49]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 49);
         PARAM "RESERVED_4[49]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 49);
         PARAM "Global input[49]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 49);
         PARAM "Output control[49]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_49 output."
               "The default value is 0"
               present_if ("GPIO Count" > 49);
         PARAM "Interrupt enable[49]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_49 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 49);
         PARAM "Dual edge trigger[49]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_49 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 49);
         PARAM "Negative edge trigger[49]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_49 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 49);
         PARAM "Edge trigger[49]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_49 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 49);






         PARAM "Port[50]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_50.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 50);
         PARAM "Pin[50]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_50 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 50);
         PARAM "RESERVED_1[50]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 50);
         PARAM "Output mux[50]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_50."
               "The default value is 0"
               present_if ("GPIO Count" > 50);
         PARAM "Hysteresis[50]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 50);
         PARAM "RESERVED_2[50]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 50);
         PARAM "Drive[50]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 50);
         PARAM "Pullup Pulldown[50]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 50);
         PARAM "RESERVED_3[50]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 50);
         PARAM "RESERVED_4[50]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 50);
         PARAM "Global input[50]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 50);
         PARAM "Output control[50]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_50 output."
               "The default value is 0"
               present_if ("GPIO Count" > 50);
         PARAM "Interrupt enable[50]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_50 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 50);
         PARAM "Dual edge trigger[50]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_50 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 50);
         PARAM "Negative edge trigger[50]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_50 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 50);
         PARAM "Edge trigger[50]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_50 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 50);






         PARAM "Port[51]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_51.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 51);
         PARAM "Pin[51]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_51 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 51);
         PARAM "RESERVED_1[51]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 51);
         PARAM "Output mux[51]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_51."
               "The default value is 0"
               present_if ("GPIO Count" > 51);
         PARAM "Hysteresis[51]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 51);
         PARAM "RESERVED_2[51]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 51);
         PARAM "Drive[51]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 51);
         PARAM "Pullup Pulldown[51]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 51);
         PARAM "RESERVED_3[51]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 51);
         PARAM "RESERVED_4[51]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 51);
         PARAM "Global input[51]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 51);
         PARAM "Output control[51]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_51 output."
               "The default value is 0"
               present_if ("GPIO Count" > 51);
         PARAM "Interrupt enable[51]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_51 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 51);
         PARAM "Dual edge trigger[51]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_51 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 51);
         PARAM "Negative edge trigger[51]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_51 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 51);
         PARAM "Edge trigger[51]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_51 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 51);






         PARAM "Port[52]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_52.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 52);
         PARAM "Pin[52]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_52 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 52);
         PARAM "RESERVED_1[52]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 52);
         PARAM "Output mux[52]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_52."
               "The default value is 0"
               present_if ("GPIO Count" > 52);
         PARAM "Hysteresis[52]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 52);
         PARAM "RESERVED_2[52]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 52);
         PARAM "Drive[52]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 52);
         PARAM "Pullup Pulldown[52]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 52);
         PARAM "RESERVED_3[52]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 52);
         PARAM "RESERVED_4[52]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 52);
         PARAM "Global input[52]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 52);
         PARAM "Output control[52]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_52 output."
               "The default value is 0"
               present_if ("GPIO Count" > 52);
         PARAM "Interrupt enable[52]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_52 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 52);
         PARAM "Dual edge trigger[52]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_52 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 52);
         PARAM "Negative edge trigger[52]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_52 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 52);
         PARAM "Edge trigger[52]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_52 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 52);






         PARAM "Port[53]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_53.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 53);
         PARAM "Pin[53]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_53 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 53);
         PARAM "RESERVED_1[53]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 53);
         PARAM "Output mux[53]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_53."
               "The default value is 0"
               present_if ("GPIO Count" > 53);
         PARAM "Hysteresis[53]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 53);
         PARAM "RESERVED_2[53]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 53);
         PARAM "Drive[53]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 53);
         PARAM "Pullup Pulldown[53]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 53);
         PARAM "RESERVED_3[53]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 53);
         PARAM "RESERVED_4[53]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 53);
         PARAM "Global input[53]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 53);
         PARAM "Output control[53]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_53 output."
               "The default value is 0"
               present_if ("GPIO Count" > 53);
         PARAM "Interrupt enable[53]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_53 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 53);
         PARAM "Dual edge trigger[53]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_53 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 53);
         PARAM "Negative edge trigger[53]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_53 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 53);
         PARAM "Edge trigger[53]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_53 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 53);






         PARAM "Port[54]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_54.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 54);
         PARAM "Pin[54]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_54 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 54);
         PARAM "RESERVED_1[54]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 54);
         PARAM "Output mux[54]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_54."
               "The default value is 0"
               present_if ("GPIO Count" > 54);
         PARAM "Hysteresis[54]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 54);
         PARAM "RESERVED_2[54]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 54);
         PARAM "Drive[54]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 54);
         PARAM "Pullup Pulldown[54]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 54);
         PARAM "RESERVED_3[54]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 54);
         PARAM "RESERVED_4[54]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 54);
         PARAM "Global input[54]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 54);
         PARAM "Output control[54]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_54 output."
               "The default value is 0"
               present_if ("GPIO Count" > 54);
         PARAM "Interrupt enable[54]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_54 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 54);
         PARAM "Dual edge trigger[54]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_54 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 54);
         PARAM "Negative edge trigger[54]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_54 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 54);
         PARAM "Edge trigger[54]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_54 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 54);






         PARAM "Port[55]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_55.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 55);
         PARAM "Pin[55]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_55 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 55);
         PARAM "RESERVED_1[55]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 55);
         PARAM "Output mux[55]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_55."
               "The default value is 0"
               present_if ("GPIO Count" > 55);
         PARAM "Hysteresis[55]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 55);
         PARAM "RESERVED_2[55]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 55);
         PARAM "Drive[55]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 55);
         PARAM "Pullup Pulldown[55]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 55);
         PARAM "RESERVED_3[55]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 55);
         PARAM "RESERVED_4[55]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 55);
         PARAM "Global input[55]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 55);
         PARAM "Output control[55]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_55 output."
               "The default value is 0"
               present_if ("GPIO Count" > 55);
         PARAM "Interrupt enable[55]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_55 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 55);
         PARAM "Dual edge trigger[55]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_55 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 55);
         PARAM "Negative edge trigger[55]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_55 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 55);
         PARAM "Edge trigger[55]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_55 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 55);






         PARAM "Port[56]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_56.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 56);
         PARAM "Pin[56]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_56 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 56);
         PARAM "RESERVED_1[56]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 56);
         PARAM "Output mux[56]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_56."
               "The default value is 0"
               present_if ("GPIO Count" > 56);
         PARAM "Hysteresis[56]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 56);
         PARAM "RESERVED_2[56]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 56);
         PARAM "Drive[56]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 56);
         PARAM "Pullup Pulldown[56]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 56);
         PARAM "RESERVED_3[56]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 56);
         PARAM "RESERVED_4[56]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 56);
         PARAM "Global input[56]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 56);
         PARAM "Output control[56]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_56 output."
               "The default value is 0"
               present_if ("GPIO Count" > 56);
         PARAM "Interrupt enable[56]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_56 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 56);
         PARAM "Dual edge trigger[56]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_56 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 56);
         PARAM "Negative edge trigger[56]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_56 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 56);
         PARAM "Edge trigger[56]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_56 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 56);






         PARAM "Port[57]"
               uint8 {7:5}
               doc "This 3 bit value defines the port assigned to GPIO_57.The default value is 0 (port 0)"
               present_if ("GPIO Count" > 57);
         PARAM "Pin[57]"
               uint8 {4:0}
               doc "This 5 bit value defines the pin assigned to GPIO_57 .The default value is 0 (pin 0)"
               present_if ("GPIO Count" > 57);
         PARAM "RESERVED_1[57]"
               uint16{15}
               doc "Reserved"
               present_if ("GPIO Count" > 57);
         PARAM "Output mux[57]"
               uint16{14}
               doc "This boolean variable elects the output value multiplexing control of the GPIO_57."
               "The default value is 0"
               present_if ("GPIO Count" > 57);
         PARAM "Hysteresis[57]"
               bool in uint16{13}
               doc "This boolean variable indicates whether turning on the hysteresis."
               "The default value is false (no)"
               present_if ("GPIO Count" > 57);
         PARAM "RESERVED_2[57]"
               uint16{12}
               doc "Reserved"
               present_if ("GPIO Count" > 57);
         PARAM "Drive[57]"
               uint16{11}
               doc "This 1 bit variable indicates the drive strength."
               "The default value is 0"
               enum
               {
               {0, "2mA at 1.8v; 4mA at 3.3v"},
               {1, "4mA at 1.8v; 8mA at 3.3v"}
               }
               present_if ("GPIO Count" > 57);
         PARAM "Pullup Pulldown[57]"
               uint16{10:9}
               doc "This two bit value indicate how to config the pullup and pulldown resistors."
               "The default value is 0"
               enum
               {
               {0, "No pull resistor"},
               {1, "Pullup resistor enabled"},
               {2, "Pulldown resistor enabled"},
               {3, "Input disable the GPIO"}
               }
               present_if ("GPIO Count" > 57);
         PARAM "RESERVED_3[57]"
               uint16{8}
               doc "Reserved"
               present_if ("GPIO Count" > 57);
         PARAM "RESERVED_4[57]"
               uint16{7}
               doc "Reserved"
               present_if ("GPIO Count" > 57);
         PARAM "Global input[57]"
               bool in uint16{6}
               doc "This boolean variable indicates whether the global input is disabled or enabled."
               "The default value is 0"
               present_if ("GPIO Count" > 57);
         PARAM "Output control[57]"
               uint16{5:4}
               doc "This two bit value indicate how to config the GPIO_57 output."
               "The default value is 0"
               present_if ("GPIO Count" > 57);
         PARAM "Interrupt enable[57]"
               bool in uint16{3}
               doc "This boolean variable indicates whether the GPIO_57 interrupt is enabled."
               "The default value is false"
               present_if ("GPIO Count" > 57);
         PARAM "Dual edge trigger[57]"
               bool in uint16{2}
               doc "This boolean variable indicates whether the GPIO_57 interrupt is triggered by dual edge."
               "The default value is false"
               present_if ("GPIO Count" > 57);
         PARAM "Negative edge trigger[57]"
               bool in uint16{1}
               doc "This boolean variable indicates whether the GPIO_57 interrupt is triggered by negative edge or low level."
               "when the level trigger is selceted. The default value is false"
               present_if ("GPIO Count" > 57);
         PARAM "Edge trigger[57]"
               bool in uint16{0}
               doc "This boolean variable indicates whether the GPIO_57 interrupt is triggered by the edge."
               "The default value is false"
               present_if ("GPIO Count" > 57);
    }


    COMMAND "Button Driver Configuration" 0xAB
    {
        doc "Configuration for the button driver"
        PARAM "Number of buttons"
            uint8
            doc "Total bumber of buttons in the HID including the connect button if present"
	        "Default is 4"
            min = 0
            max = 16;
        PARAM "Process all buttons on flush"
            uint8
            doc "Whether flush requests to the driver cause the driver to process all pending events"
                "If disabled, the driver will process pending events normally"
            "Default is disabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Clear button state on flush"
            uint8
            doc "Whether flush requests cause the driver to reset the state of all buttons to up"
                "If disabled, the driver does not reset button state on receiving a flush"
            "Default is disabled"
            enum
            {
                {0, "Disable"},
                {1, "Enable"}
            };
        PARAM "Button 0 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
	        "Default is 0x0001"
            present_if ("Number of buttons" > 0);
        PARAM "Button 1 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            "Default is 0x0004"
            present_if ("Number of buttons" > 1);
        PARAM "Button 2 report bit"
            uint16
            doc "Maps detected button bit to report bit"
            "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            "Default is 0x0002"
           present_if ("Number of buttons" > 2);
        PARAM "Button 3 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
	        "Default is 0x8000"
            present_if ("Number of buttons" > 3);
        PARAM "Button 4 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 4);
        PARAM "Button 5 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 5);
        PARAM "Button 6 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 6);
        PARAM "Button 7 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 7);
        PARAM "Button 8 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 8);
        PARAM "Button 9 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 9);
        PARAM "Button 10 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 10);
        PARAM "Button 11 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 11);
        PARAM "Button 12 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 12);
        PARAM "Button 13 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 13);
        PARAM "Button 14 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 14);
        PARAM "Button 15 report bit"
            uint16
            doc "Maps detected button bit to report bit"
	        "Buttons are always detected in sequence; button tied to kso0 is detected"
            "as button 0, button tied to kso19 is detected as button 19, etc."
            present_if ("Number of buttons" > 15);
    }


    COMMAND "Mouse Application Config" 0xAC
    {
        doc "ROM Mouse application configuration - must be used with HID application"

        PARAM "Motion Report ID"
            uint8
            doc "ID used for motion reports. Should match SDP record."
	        "Default value is 2";
        PARAM "Motion Report Size - Boot Mode"
            uint8
            doc "Size of the motion reports sent in boot mode"
	        "Default value is 5";
        PARAM "Motion Report Size - Report Mode"
            uint8
            doc "Size of the motion reports sent in report mode. Must match SDP record"
	        "Default value is 7";
        PARAM "Connect button mask"
            uint16
            doc "Mask which identifies the connect button in the output of the button driver"
	        "Set to 0x8000 when using standard button driver"
	        "Default value is 0x8000";
        PARAM "Max XY Sensor Readings Per Poll"
            uint8
            doc "The maximum number of times an XY sensor should be polled even"
	        "if it continues to report accumulated motion"
                "Many XY sensors can track more motion than they can report in a single report"
	        "This value limits the maximum latency of the XY sensor poll routine"
	        "Default value is 3";
        PARAM "Swap XY"
            bool8
            doc "Instructs FW to swap the X/Y readings from the sensor"
	        "Motion sensors can be mounted in such a way that their X and Y outputs are"
            "swapped from the user perspective. Note that X/Y swapping is done before negating"
	        "Default value is 1";
        PARAM "Negate X"
            bool8
            doc "Instructs FW to negate the X value read from the sensor"
		"Note that negation is done after X/Y swap."
                "Combined with X/Y swap accomodates physical sensor orientation differences"
		"compared to what is expected by the XY sensor"
	        "Default value is 0";
        PARAM "Negate Y"
            bool8
            doc "Instructs FW to negate the Y value read from the sensor"
	        "Note that negation is done after X/Y swap."
                "Combined with X/Y swap accomodates physical sensor orientation differences"
		"compared to what is expected by the XY sensor"
	        "Default value is 0";
        PARAM "Negate scroll"
            bool8
            doc "Instructs FW to negate the scroll value read from the scroll wheel."
	        "Default value is 0";
        PARAM "Scaling For X Coordinate"
            uint8
            doc "Shifts the X motion reported by the sensor the specified number of bits to the right"
	        "Used to scale down reported motion. Set to 0 to disable scaling"
	        "Default value is 0"
            min = 0
            max = 15
            note "bits shifted right";
        PARAM "Scaling For Y Coordinate"
            uint8
            doc "Shifts the Y motion reported by the sensor the specified number of bits to the right"
	        "Used to scale down reported motion. Set to 0 to disable scaling"
	        "Default value is 0"
            min = 0
            max = 15
            note "bits shifted right";
        PARAM "Scaling For Scroll"
            uint8
            doc "Shifts scroll reported by the scroll wheel the specified number of bits to the right"
	        "Used to scale down reported scroll. Set to 0 to disable scaling"
	        "Default value is 1"
            min = 0
            max = 15
            note "bits shifted right";
        PARAM "Polls to keep fractional XY data"
            uint8
            doc "Specifies how many poll periods the fractional motion should be kept"
	        "When scaling is used, fractional unreportable XY motion is maintained and"
		"added to the next report if possible. However, we don't want to keep the"
		"unreported motion for long periods because it can cause visible motion"
                "after long periods of time. Fractional motion is discarded after this many"
		"polls have occurred without any detected motion. If set to 0, fractional"
		"motion is never discarded"
	        "Default value is 0";
        PARAM "Polls to keep fractional scroll data"
            uint8
            doc "Specifies how many poll periods the fractional motion should be kept"
	        "When scaling is used, fractional unreportable scroll motion is maintained"
		"and added to the next report if possible. However, we don't want to keep"
		"the unreported motion for long periods because it can cause visible activity"
		"after long periods of time. Fractional motion is discarded after this many"
		"polls have occurred without any detected motion. If set to 0, fractional"
		"motion is never discarded"
	        "Default value is 50";
        PARAM "Report Combining"
            bool8
            doc "Multiple motion events of the same type will be combined by the FW into a single report"
	        "Note that this only works for motion/scroll data and will not combine motion and"
		"scroll events together. Also note that events detected in the same poll period"
		"are always combined into a single mouse report regardless of the value of this flag."
		"Default is 1";
        PARAM "Spiffy block"
            uint8
            doc "Defines which spiffy block to use"
	        "Default is spiffy2"
            enum
            {
                {0, "spiffy1"},
                {1, "spiffy2"}
            };
        PARAM "maxEventSize"
            uint8
            doc "Size of each element in the app event queue. Note: This has to be at least as large as the"
                "largest event that the app will handle"
            min = 6;
        PARAM "maxEventNum"
            uint8
            doc "Maximum number of events that the app event queue can hold.";
    }


    COMMAND "Spiffy Config" 0xAD
    {
        #Spiffy1 Config
        doc "Spiffy1 GPIO configuration"

        PARAM "Spiffy Master or Slave"
	        uint8
	        doc "Master or Slave mode"
            enum
            {
                {1, "Master"},
                {2, "Slave"}
            };

        PARAM "Input Pin Pull Config"
            uint16
            doc "Set the input Pull-up, pull-down,float configuration"
            enum
            {
                {0x0400, "Pull-Up"},
                {0x0200, "Pull-Down"},
                {0x0000, "Floating"}
            };
        PARAM "Spiffy 1 GPIO Config"
	        uint32
	        doc "Configure for CLK/MOSI/MISO/CS"
            enum
            {

                {0x00030001, "MASTER2_P03_CLK_P00_MOSI_P01_MISO" },
                {0x00030005, "MASTER2_P03_CLK_P00_MOSI_P05_MISO" },
                {0x00030201, "MASTER2_P03_CLK_P02_MOSI_P01_MISO" },
                {0x00030205, "MASTER2_P03_CLK_P02_MOSI_P05_MISO" },
                {0x00030401, "MASTER2_P03_CLK_P04_MOSI_P01_MISO" },
                {0x00030405, "MASTER2_P03_CLK_P04_MOSI_P05_MISO" },
                {0x00031b01, "MASTER2_P03_CLK_P27_MOSI_P01_MISO" },
                {0x00031b05, "MASTER2_P03_CLK_P27_MOSI_P05_MISO" },
                {0x00032601, "MASTER2_P03_CLK_P38_MOSI_P01_MISO" },
                {0x00032605, "MASTER2_P03_CLK_P38_MOSI_P05_MISO" },

                {0x00070001, "MASTER2_P07_CLK_P00_MOSI_P01_MISO" },
                {0x00070005, "MASTER2_P07_CLK_P00_MOSI_P05_MISO" },
                {0x00070201, "MASTER2_P07_CLK_P02_MOSI_P01_MISO" },
                {0x00070205, "MASTER2_P07_CLK_P02_MOSI_P05_MISO" },
                {0x00070401, "MASTER2_P07_CLK_P04_MOSI_P01_MISO" },
                {0x00070405, "MASTER2_P07_CLK_P04_MOSI_P05_MISO" },
                {0x00071b01, "MASTER2_P07_CLK_P27_MOSI_P01_MISO" },
                {0x00071b05, "MASTER2_P07_CLK_P27_MOSI_P05_MISO" },
                {0x00072601, "MASTER2_P07_CLK_P38_MOSI_P01_MISO" },
                {0x00072605, "MASTER2_P07_CLK_P38_MOSI_P05_MISO" },
                {0x00180019, "MASTER2_P24_CLK_P00_MOSI_P25_MISO" },
                {0x00180219, "MASTER2_P24_CLK_P02_MOSI_P25_MISO" },
                {0x00180419, "MASTER2_P24_CLK_P04_MOSI_P25_MISO" },
                {0x00181b19, "MASTER2_P24_CLK_P27_MOSI_P25_MISO" },
                {0x00182619, "MASTER2_P24_CLK_P38_MOSI_P25_MISO" },
                {0x00240019, "MASTER2_P36_CLK_P00_MOSI_P25_MISO" },
                {0x00240219, "MASTER2_P36_CLK_P02_MOSI_P25_MISO" },
                {0x00240419, "MASTER2_P36_CLK_P04_MOSI_P25_MISO" },
                {0x00241b19, "MASTER2_P36_CLK_P27_MOSI_P25_MISO" },
                {0x00242619, "MASTER2_P36_CLK_P38_MOSI_P25_MISO" },
                {0x02030001 , "SLAVE2_P02_CS_P03_CLK_P00_MOSI_P01_MISO" },
                {0x02030005 , "SLAVE2_P02_CS_P03_CLK_P00_MOSI_P05_MISO" },
                {0x02030019 , "SLAVE2_P02_CS_P03_CLK_P00_MOSI_P25_MISO" },
                {0x02030401 , "SLAVE2_P02_CS_P03_CLK_P04_MOSI_P01_MISO" },
                {0x02030405 , "SLAVE2_P02_CS_P03_CLK_P04_MOSI_P05_MISO" },
                {0x02030419 , "SLAVE2_P02_CS_P03_CLK_P04_MOSI_P25_MISO" },
                {0x02070001 , "SLAVE2_P02_CS_P07_CLK_P00_MOSI_P01_MISO" },
                {0x02070005 , "SLAVE2_P02_CS_P07_CLK_P00_MOSI_P05_MISO" },
                {0x02070019 , "SLAVE2_P02_CS_P07_CLK_P00_MOSI_P25_MISO" },
                {0x02070401 , "SLAVE2_P02_CS_P07_CLK_P04_MOSI_P01_MISO" },
                {0x02070405 , "SLAVE2_P02_CS_P07_CLK_P04_MOSI_P05_MISO" },
                {0x02070419 , "SLAVE2_P02_CS_P07_CLK_P04_MOSI_P25_MISO" },
                {0x06030001 , "SLAVE2_P06_CS_P03_CLK_P00_MOSI_P01_MISO" },
                {0x06030005 , "SLAVE2_P06_CS_P03_CLK_P00_MOSI_P05_MISO" },
                {0x06030019 , "SLAVE2_P06_CS_P03_CLK_P00_MOSI_P25_MISO" },
                {0x06030401 , "SLAVE2_P06_CS_P03_CLK_P04_MOSI_P01_MISO" },
                {0x06030405 , "SLAVE2_P06_CS_P03_CLK_P04_MOSI_P05_MISO" },
                {0x06030419 , "SLAVE2_P06_CS_P03_CLK_P04_MOSI_P25_MISO" },
                {0x06070001 , "SLAVE2_P06_CS_P07_CLK_P00_MOSI_P01_MISO" },
                {0x06070005 , "SLAVE2_P06_CS_P07_CLK_P00_MOSI_P05_MISO" },
                {0x06070019 , "SLAVE2_P06_CS_P07_CLK_P00_MOSI_P25_MISO" },
                {0x06070401 , "SLAVE2_P06_CS_P07_CLK_P04_MOSI_P01_MISO" },
                {0x06070405 , "SLAVE2_P06_CS_P07_CLK_P04_MOSI_P05_MISO" },
                {0x06070419 , "SLAVE2_P06_CS_P07_CLK_P04_MOSI_P25_MISO" },
                {0x1a181b01 , "SLAVE2_P26_CS_P24_CLK_P27_MOSI_P01_MISO" },
                {0x1a181b05 , "SLAVE2_P26_CS_P24_CLK_P27_MOSI_P05_MISO" },
                {0x1a181b19 , "SLAVE2_P26_CS_P24_CLK_P27_MOSI_P25_MISO" },
                {0x1a182101 , "SLAVE2_P26_CS_P24_CLK_P33_MOSI_P01_MISO" },
                {0x1a182105 , "SLAVE2_P26_CS_P24_CLK_P33_MOSI_P05_MISO" },
                {0x1a182119 , "SLAVE2_P26_CS_P24_CLK_P33_MOSI_P25_MISO" },
                {0x1a182601 , "SLAVE2_P26_CS_P24_CLK_P38_MOSI_P01_MISO" },
                {0x1a182605 , "SLAVE2_P26_CS_P24_CLK_P38_MOSI_P05_MISO" },
                {0x1a182619 , "SLAVE2_P26_CS_P24_CLK_P38_MOSI_P25_MISO" },
                {0x1a241b01 , "SLAVE2_P26_CS_P36_CLK_P27_MOSI_P01_MISO" },
                {0x1a241b05 , "SLAVE2_P26_CS_P36_CLK_P27_MOSI_P05_MISO" },
                {0x1a241b19 , "SLAVE2_P26_CS_P36_CLK_P27_MOSI_P25_MISO" },
                {0x1a242101 , "SLAVE2_P26_CS_P36_CLK_P33_MOSI_P01_MISO" },
                {0x1a242105 , "SLAVE2_P26_CS_P36_CLK_P33_MOSI_P05_MISO" },
                {0x1a242119 , "SLAVE2_P26_CS_P36_CLK_P33_MOSI_P25_MISO" },
                {0x1a242601 , "SLAVE2_P26_CS_P36_CLK_P38_MOSI_P01_MISO" },
                {0x1a242605 , "SLAVE2_P26_CS_P36_CLK_P38_MOSI_P05_MISO" },
                {0x1a242619 , "SLAVE2_P26_CS_P36_CLK_P38_MOSI_P25_MISO" },
                {0x20181b01 , "SLAVE2_P32_CS_P24_CLK_P27_MOSI_P01_MISO" },
                {0x20181b05 , "SLAVE2_P32_CS_P24_CLK_P27_MOSI_P05_MISO" },
                {0x20181b19 , "SLAVE2_P32_CS_P24_CLK_P27_MOSI_P25_MISO" },
                {0x20182101 , "SLAVE2_P32_CS_P24_CLK_P33_MOSI_P01_MISO" },
                {0x20182105 , "SLAVE2_P32_CS_P24_CLK_P33_MOSI_P05_MISO" },
                {0x20182119 , "SLAVE2_P32_CS_P24_CLK_P33_MOSI_P25_MISO" },
                {0x20182601 , "SLAVE2_P32_CS_P24_CLK_P38_MOSI_P01_MISO" },
                {0x20182605 , "SLAVE2_P32_CS_P24_CLK_P38_MOSI_P05_MISO" },
                {0x20182619 , "SLAVE2_P32_CS_P24_CLK_P38_MOSI_P25_MISO" },
                {0x20241b01 , "SLAVE2_P32_CS_P36_CLK_P27_MOSI_P01_MISO" },
                {0x20241b05 , "SLAVE2_P32_CS_P36_CLK_P27_MOSI_P05_MISO" },
                {0x20241b19 , "SLAVE2_P32_CS_P36_CLK_P27_MOSI_P25_MISO" },
                {0x20242101 , "SLAVE2_P32_CS_P36_CLK_P33_MOSI_P01_MISO" },
                {0x20242105 , "SLAVE2_P32_CS_P36_CLK_P33_MOSI_P05_MISO" },
                {0x20242119 , "SLAVE2_P32_CS_P36_CLK_P33_MOSI_P25_MISO" },
                {0x20242601 , "SLAVE2_P32_CS_P36_CLK_P38_MOSI_P01_MISO" },
                {0x20242605 , "SLAVE2_P32_CS_P36_CLK_P38_MOSI_P05_MISO" },
                {0x20242619 , "SLAVE2_P32_CS_P36_CLK_P38_MOSI_P25_MISO" },
                {0x27181b01 , "SLAVE2_P39_CS_P24_CLK_P27_MOSI_P01_MISO" },
                {0x27181b05 , "SLAVE2_P39_CS_P24_CLK_P27_MOSI_P05_MISO" },
                {0x27181b19 , "SLAVE2_P39_CS_P24_CLK_P27_MOSI_P25_MISO" },
                {0x27182101 , "SLAVE2_P39_CS_P24_CLK_P33_MOSI_P01_MISO" },
                {0x27182105 , "SLAVE2_P39_CS_P24_CLK_P33_MOSI_P05_MISO" },
                {0x27182119 , "SLAVE2_P39_CS_P24_CLK_P33_MOSI_P25_MISO" },
                {0x27182601 , "SLAVE2_P39_CS_P24_CLK_P38_MOSI_P01_MISO" },
                {0x27182605 , "SLAVE2_P39_CS_P24_CLK_P38_MOSI_P05_MISO" },
                {0x27182619 , "SLAVE2_P39_CS_P24_CLK_P38_MOSI_P25_MISO" },
                {0x27241b01 , "SLAVE2_P39_CS_P36_CLK_P27_MOSI_P01_MISO" },
                {0x27241b05 , "SLAVE2_P39_CS_P36_CLK_P27_MOSI_P05_MISO" },
                {0x27241b19 , "SLAVE2_P39_CS_P36_CLK_P27_MOSI_P25_MISO" },
                {0x27242101 , "SLAVE2_P39_CS_P36_CLK_P33_MOSI_P01_MISO" },
                {0x27242105 , "SLAVE2_P39_CS_P36_CLK_P33_MOSI_P05_MISO" },
                {0x27242119 , "SLAVE2_P39_CS_P36_CLK_P33_MOSI_P25_MISO" },
                {0x27242601 , "SLAVE2_P39_CS_P36_CLK_P38_MOSI_P01_MISO" },
                {0x27242605 , "SLAVE2_P39_CS_P36_CLK_P38_MOSI_P05_MISO" },
                {0x27242619 , "SLAVE2_P39_CS_P36_CLK_P38_MOSI_P25_MISO" }
            };

        PARAM "Spiffy 2 GPIO Config"
	        uint32
	        doc "Configure for SPI-2 interface, for SPI-2 only support master mode."
            "SCL will be use as SPI clock, SDA will be uase as SPI MOSI, MISO can only works for following GPIO"
            enum
            {
                { 0xe0e1e218,"MASTER1_P24_MISO"},
                { 0xe0e1e21a,"MASTER1_P26_MISO"},
                { 0xe0e1e220,"MASTER1_P32_MISO"},
                { 0xe0e1e227,"MASTER1_P39_MISO"}
            };
    }


    COMMAND "ECI Configuration" 0xB9
    {
        doc "ECI (Enhanced COEX Interface) configurations"
        PARAM "Config"
            uint32
            doc "Enable/Disable ECI"
            bitmap
            {
                {0x80000000, "Enable ECI"},
                {0x40000000, "Enable Multi-level Prioirty"},
                {0x20000000, "Enable ECI-Rx Interrupt handler"},
                {0x10000000, "Enable ECI-Rx Polling function"}
            }
        default = 0;

    }


    COMMAND "BT LPM Config" 0xAE
    {
        doc "Configuration item for the concrete BT LPM instance"
        PARAM "sniffNegotiationBackOffTimeInMs"
              uint16
              doc "The time in milliseconds to back off if a sniff request is not accepted by the host."
                  "The default is 1000 milliseconds";
        PARAM "minimumAcceptableSubrateInSlots"
              uint16
              doc "The minimum acceptable subrate from the host, if not met, will use a multiple of the subrate"
              "enabled by the host, greater than the minimumAcceptableSubrateInSlots"
              min = 1;
        PARAM "waitTimeToStartLpmInOsTicks"
              uint8
              doc "Time in OS ticks to wait after connect notification before starting sniff transitions."
                  "Each tick is 12.5 ms.";
        PARAM "hostSuspendStateIndex"
              uint8 {7:4}
              doc "Index of the state in the default state list whic should be negotiated when"
              "the host sends a suspend control";
        PARAM "disconnectedStateIndex"
              uint8 {3:0}
              doc "Index of the disconnected state in BT Sniff Config";


        PARAM "Number of sniff params"
              uint8
              doc "The number of sniff parameters in this"
              not_in_binary_message
              decode_value = 0
              min = 2
              max = 8;           # We can have a max of 8 sniff params

        # Sniff params[0] - - - - - - - - - -
        PARAM "mode[0]"
              uint8
              doc "The current mode, the first mode has to be HIGH."
              enum
              {
                {0x01, "HIGH"}
              }
              present_if ("Number of sniff params" > 0);
        PARAM "maxNegotiationAttempts[0]"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              present_if ("Number of sniff params" > 0);
        PARAM "timeoutToNextInMs[0]"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              present_if ("Number of sniff params" > 0);
        PARAM "type[0]"
              uint8
              doc "The type of sniff to negotiate. This has to be NORMAL"
              enum
              {
                {0x00, "NORMAL"},
                {0x01, "ASYMMETRIC"}
              }
              present_if ("Number of sniff params" > 0);
        PARAM "asymmetricMultiplier[0]"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of sniff params" > 0);
              #enabled_if (("Number of sniff params" > 0) and ("type[0]" > 0));
        PARAM "minInterval[0]"
              uint16
              doc "Minimum sniff interval in BT slots"
              present_if ("Number of sniff params" > 0);
        PARAM "maxInterval[0]"
              uint16
              doc "Maximum sniff interval in BT slots"
              present_if ("Number of sniff params" > 0);
        PARAM "attempts[0]"
              uint16
              doc "Number of BT slots for sniff attempt"
              present_if ("Number of sniff params" > 0);
        PARAM "timeout[0]"
              uint16
              doc "Number of BT slots for timeout"
              present_if ("Number of sniff params" > 0);
        PARAM "RESERVED_21[0]"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 0);
        PARAM "earlyWakeQuad[0]"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 0);
        PARAM "earlyWakeKeyscan[0]"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 0);
        PARAM "earlyWakeGpio[0]"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 0);
        PARAM "RESERVED_7[0]"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 0);
        PARAM "sleepAllowed[0]"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 0);


        # Sniff params[1] - - - - - - - - - -
        PARAM "mode[1]"
              uint8
              doc "The current mode"
              enum
              {
                {0x01, "HIGH"},
                {0x02, "IDLE0"},
                {0x03, "IDLE1"},
                {0xF0, "SUSPEND"},
                {0xF1, "DISCONNECT"}
              }
              present_if ("Number of sniff params" > 1);
        PARAM "maxNegotiationAttempts[1]"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              default = 0
              enabled_if (("Number of sniff params" > 1) and ("mode[1]" < 0xF0));
        PARAM "timeoutToNextInMs[1]"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              default = 0
              enabled_if (("Number of sniff params" > 1) and ("mode[1]" < 0xF0));
        PARAM "type[1]"
              uint8
              doc "The type of sniff to negotiate"
              enum
              {
                {0x00, "NORMAL"},
                {0x01, "ASYMMETRIC"}
              }
              default = 0
              enabled_if (("Number of sniff params" > 1) and ("mode[1]" < 0xF0));
        PARAM "asymmetricMultiplier[1]"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of sniff params" > 1);
              #enabled_if (("Number of sniff params" > 1) and ("type[1]" > 0));
        PARAM "minInterval[1]"
              uint16
              doc "Minimum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 1) and ("mode[1]" < 0xF0));
        PARAM "maxInterval[1]"
              uint16
              doc "Maximum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 1) and ("mode[1]" < 0xF0));
        PARAM "attempts[1]"
              uint16
              doc "Number of BT slots for sniff attempt"
              default = 0
              enabled_if (("Number of sniff params" > 1) and ("mode[1]" < 0xF0));
        PARAM "timeout[1]"
              uint16
              doc "Number of BT slots for timeout"
              default = 0
              enabled_if (("Number of sniff params" > 1) and ("mode[1]" < 0xF0));
        PARAM "RESERVED_21[1]"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 1);
        PARAM "earlyWakeQuad[1]"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 1);
        PARAM "earlyWakeKeyscan[1]"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 1);
        PARAM "earlyWakeGpio[1]"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 1);
        PARAM "RESERVED_7[1]"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 1);
        PARAM "sleepAllowed[1]"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 1);

        # Sniff params[2] - - - - - - - - - -
        PARAM "mode[2]"
              uint8
              doc "The current mode"
              enum
              {
                {0x01, "HIGH"},
                {0x02, "IDLE0"},
                {0x03, "IDLE1"},
                {0xF0, "SUSPEND"},
                {0xF1, "DISCONNECT"}
              }
              present_if ("Number of sniff params" > 2);
        PARAM "maxNegotiationAttempts[2]"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              default = 0
              enabled_if (("Number of sniff params" > 2) and ("mode[2]" < 0xF0));
        PARAM "timeoutToNextInMs[2]"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              default = 0
              enabled_if (("Number of sniff params" > 2) and ("mode[2]" < 0xF0));
        PARAM "type[2]"
              uint8
              doc "The type of sniff to negotiate"
              enum
              {
                {0x00, "NORMAL"},
                {0x01, "ASYMMETRIC"}
              }
              default = 0
              enabled_if (("Number of sniff params" > 2) and ("mode[2]" < 0xF0));
        PARAM "asymmetricMultiplier[2]"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of sniff params" > 2);
              #enabled_if (("Number of sniff params" > 2) and ("type[2]" > 0));
        PARAM "minInterval[2]"
              uint16
              doc "Minimum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 2) and ("mode[2]" < 0xF0));
        PARAM "maxInterval[2]"
              uint16
              doc "Maximum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 2) and ("mode[2]" < 0xF0));
        PARAM "attempts[2]"
              uint16
              doc "Number of BT slots for sniff attempt"
              default = 0
              enabled_if (("Number of sniff params" > 2) and ("mode[2]" < 0xF0));
        PARAM "timeout[2]"
              uint16
              doc "Number of BT slots for timeout"
              default = 0
              enabled_if (("Number of sniff params" > 2) and ("mode[2]" < 0xF0));
        PARAM "RESERVED_21[2]"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 2);
        PARAM "earlyWakeQuad[2]"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 2);
        PARAM "earlyWakeKeyscan[2]"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 2);
        PARAM "earlyWakeGpio[2]"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 2);
        PARAM "RESERVED_7[2]"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 2);
        PARAM "sleepAllowed[2]"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 2);


        # Sniff params[3] - - - - - - - - - -
        PARAM "mode[3]"
              uint8
              doc "The current mode"
              enum
              {
                {0x01, "HIGH"},
                {0x02, "IDLE0"},
                {0x03, "IDLE1"},
                {0xF0, "SUSPEND"},
                {0xF1, "DISCONNECT"}
              }
              present_if ("Number of sniff params" > 3);
        PARAM "maxNegotiationAttempts[3]"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              default = 0
              enabled_if (("Number of sniff params" > 3) and ("mode[3]" < 0xF0));
        PARAM "timeoutToNextInMs[3]"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              default = 0
              enabled_if (("Number of sniff params" > 3) and ("mode[3]" < 0xF0));
        PARAM "type[3]"
              uint8
              doc "The type of sniff to negotiate"
              enum
              {
                {0x00, "NORMAL"},
                {0x01, "ASYMMETRIC"}
              }
              default = 0
              enabled_if (("Number of sniff params" > 3) and ("mode[3]" < 0xF0));
        PARAM "asymmetricMultiplier[3]"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of sniff params" > 3);
              #enabled_if (("Number of sniff params" > 3) and ("type[3]" > 0));
        PARAM "minInterval[3]"
              uint16
              doc "Minimum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 3) and ("mode[3]" < 0xF0));
        PARAM "maxInterval[3]"
              uint16
              doc "Maximum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 3) and ("mode[3]" < 0xF0));
        PARAM "attempts[3]"
              uint16
              doc "Number of BT slots for sniff attempt"
              default = 0
              enabled_if (("Number of sniff params" > 3) and ("mode[3]" < 0xF0));
        PARAM "timeout[3]"
              uint16
              doc "Number of BT slots for timeout"
              default = 0
              enabled_if (("Number of sniff params" > 3) and ("mode[3]" < 0xF0));
        PARAM "RESERVED_21[3]"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 3);
        PARAM "earlyWakeQuad[3]"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 3);
        PARAM "earlyWakeKeyscan[3]"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 3);
        PARAM "earlyWakeGpio[3]"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 3);
        PARAM "RESERVED_7[3]"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 3);
        PARAM "sleepAllowed[3]"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 3);

        # Sniff params[4] - - - - - - - - - -
        PARAM "mode[4]"
              uint8
              doc "The current mode"
              enum
              {
                {0x01, "HIGH"},
                {0x02, "IDLE0"},
                {0x03, "IDLE1"},
                {0xF0, "SUSPEND"},
                {0xF1, "DISCONNECT"}
              }
              present_if ("Number of sniff params" > 4);
        PARAM "maxNegotiationAttempts[4]"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              default = 0
              enabled_if (("Number of sniff params" > 4) and ("mode[4]" < 0xF0));
        PARAM "timeoutToNextInMs[4]"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              default = 0
              enabled_if (("Number of sniff params" > 4) and ("mode[4]" < 0xF0));
        PARAM "type[4]"
              uint8
              doc "The type of sniff to negotiate"
              enum
              {
                {0x00, "NORMAL"},
                {0x01, "ASYMMETRIC"}
              }
              default = 0
              enabled_if (("Number of sniff params" > 4) and ("mode[4]" < 0xF0));
        PARAM "asymmetricMultiplier[4]"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of sniff params" > 4);
              #enabled_if (("Number of sniff params" > 4) and ("type[4]" > 0));
        PARAM "minInterval[4]"
              uint16
              doc "Minimum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 4) and ("mode[4]" < 0xF0));
        PARAM "maxInterval[4]"
              uint16
              doc "Maximum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 4) and ("mode[4]" < 0xF0));
        PARAM "attempts[4]"
              uint16
              doc "Number of BT slots for sniff attempt"
              default = 0
              enabled_if (("Number of sniff params" > 4) and ("mode[4]" < 0xF0));
        PARAM "timeout[4]"
              uint16
              doc "Number of BT slots for timeout"
              default = 0
              enabled_if (("Number of sniff params" > 4) and ("mode[4]" < 0xF0));
        PARAM "RESERVED_21[4]"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 4);
        PARAM "earlyWakeQuad[4]"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 4);
        PARAM "earlyWakeKeyscan[4]"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 4);
        PARAM "earlyWakeGpio[4]"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 4);
        PARAM "RESERVED_7[4]"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 4);
        PARAM "sleepAllowed[4]"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 4);

        # Sniff params[5] - - - - - - - - - -
        PARAM "mode[5]"
              uint8
              doc "The current mode"
              enum
              {
                {0x01, "HIGH"},
                {0x02, "IDLE0"},
                {0x03, "IDLE1"},
                {0xF0, "SUSPEND"},
                {0xF1, "DISCONNECT"}
              }
              present_if ("Number of sniff params" > 5);
        PARAM "maxNegotiationAttempts[5]"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              default = 0
              enabled_if (("Number of sniff params" > 5) and ("mode[5]" < 0xF0));
        PARAM "timeoutToNextInMs[5]"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              default = 0
              enabled_if (("Number of sniff params" > 5) and ("mode[5]" < 0xF0));
        PARAM "type[5]"
              uint8
              doc "The type of sniff to negotiate"
              enum
              {
                {0x00, "NORMAL"},
                {0x01, "ASYMMETRIC"}
              }
              default = 0
              enabled_if (("Number of sniff params" > 5) and ("mode[5]" < 0xF0));
        PARAM "asymmetricMultiplier[5]"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of sniff params" > 5);
              #enabled_if (("Number of sniff params" > 5) and ("type[5]" > 0));
        PARAM "minInterval[5]"
              uint16
              doc "Minimum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 5) and ("mode[5]" < 0xF0));
        PARAM "maxInterval[5]"
              uint16
              doc "Maximum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 5) and ("mode[5]" < 0xF0));
        PARAM "attempts[5]"
              uint16
              doc "Number of BT slots for sniff attempt"
              default = 0
              enabled_if (("Number of sniff params" > 5) and ("mode[5]" < 0xF0));
        PARAM "timeout[5]"
              uint16
              doc "Number of BT slots for timeout"
              default = 0
              enabled_if (("Number of sniff params" > 5) and ("mode[5]" < 0xF0));
        PARAM "RESERVED_21[5]"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 5);
        PARAM "earlyWakeQuad[5]"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 5);
        PARAM "earlyWakeKeyscan[5]"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 5);
        PARAM "earlyWakeGpio[5]"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 5);
        PARAM "RESERVED_7[5]"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 5);
        PARAM "sleepAllowed[5]"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 5);

        # Sniff params[6] - - - - - - - - - -
        PARAM "mode[6]"
              uint8
              doc "The current mode"
              enum
              {
                {0x01, "HIGH"},
                {0x02, "IDLE0"},
                {0x03, "IDLE1"},
                {0xF0, "SUSPEND"},
                {0xF1, "DISCONNECT"}
              }
              present_if ("Number of sniff params" > 6);
        PARAM "maxNegotiationAttempts[6]"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              default = 0
              enabled_if (("Number of sniff params" > 6) and ("mode[6]" < 0xF0));
        PARAM "timeoutToNextInMs[6]"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              default = 0
              enabled_if (("Number of sniff params" > 6) and ("mode[6]" < 0xF0));
        PARAM "type[6]"
              uint8
              doc "The type of sniff to negotiate"
              enum
              {
                {0x00, "NORMAL"},
                {0x01, "ASYMMETRIC"}
              }
              default = 0
              enabled_if (("Number of sniff params" > 6) and ("mode[6]" < 0xF0));
        PARAM "asymmetricMultiplier[6]"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of sniff params" > 6);
              #enabled_if (("Number of sniff params" > 6) and ("type[6]" > 0));
        PARAM "minInterval[6]"
              uint16
              doc "Minimum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 6) and ("mode[6]" < 0xF0));
        PARAM "maxInterval[6]"
              uint16
              doc "Maximum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 6) and ("mode[6]" < 0xF0));
        PARAM "attempts[6]"
              uint16
              doc "Number of BT slots for sniff attempt"
              default = 0
              enabled_if (("Number of sniff params" > 6) and ("mode[6]" < 0xF0));
        PARAM "timeout[6]"
              uint16
              doc "Number of BT slots for timeout"
              default = 0
              enabled_if (("Number of sniff params" > 6) and ("mode[6]" < 0xF0));
        PARAM "RESERVED_21[6]"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 6);
        PARAM "earlyWakeQuad[6]"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 6);
        PARAM "earlyWakeKeyscan[6]"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 6);
        PARAM "earlyWakeGpio[6]"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 6);
        PARAM "RESERVED_7[6]"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 6);
        PARAM "sleepAllowed[6]"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 6);

        # Sniff params[7] - - - - - - - - - -
        PARAM "mode[7]"
              uint8
              doc "The current mode"
              enum
              {
                {0x01, "HIGH"},
                {0x02, "IDLE0"},
                {0x03, "IDLE1"},
                {0xF0, "SUSPEND"},
                {0xF1, "DISCONNECT"}
              }
              present_if ("Number of sniff params" > 7);
        PARAM "maxNegotiationAttempts[7]"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              default = 0
              enabled_if (("Number of sniff params" > 7) and ("mode[7]" < 0xF0));
        PARAM "timeoutToNextInMs[7]"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              default = 0
              enabled_if (("Number of sniff params" > 7) and ("mode[7]" < 0xF0));
        PARAM "type[7]"
              uint8
              doc "The type of sniff to negotiate"
              enum
              {
                {0x00, "NORMAL"},
                {0x01, "ASYMMETRIC"}
              }
              default = 0
              enabled_if (("Number of sniff params" > 7) and ("mode[7]" < 0xF0));
        PARAM "asymmetricMultiplier[7]"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of sniff params" > 7);
              #enabled_if (("Number of sniff params" > 7) and ("type[7]" > 0));
        PARAM "minInterval[7]"
              uint16
              doc "Minimum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 7) and ("mode[7]" < 0xF0));
        PARAM "maxInterval[7]"
              uint16
              doc "Maximum sniff interval in BT slots"
              default = 0
              enabled_if (("Number of sniff params" > 7) and ("mode[7]" < 0xF0));
        PARAM "attempts[7]"
              uint16
              doc "Number of BT slots for sniff attempt"
              default = 0
              enabled_if (("Number of sniff params" > 7) and ("mode[7]" < 0xF0));
        PARAM "timeout[7]"
              uint16
              doc "Number of BT slots for timeout"
              default = 0
              enabled_if (("Number of sniff params" > 7) and ("mode[7]" < 0xF0));
        PARAM "RESERVED_21[7]"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 7);
        PARAM "earlyWakeQuad[7]"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 7);
        PARAM "earlyWakeKeyscan[7]"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 7);
        PARAM "earlyWakeGpio[7]"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 7);
        PARAM "RESERVED_7[7]"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of sniff params" > 7);
        PARAM "sleepAllowed[7]"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of sniff params" > 7);

        PARAM "Number of subrate params"
              uint8
              doc "The number of sniff parameters in this"
              not_in_binary_message
              decode_value = 0
              min = 2
              max = 3;           # We can have a max of 3 subrate params

        # Sniff params[0] - - - - - - - - - -
        PARAM "mode[0] of SSR"
              uint8
              doc "The current mode, the first mode has to be HIGH."
              enum
              {
                {0x01, "HIGH"}
              }
              present_if ("Number of subrate params" > 0);
        PARAM "maxNegotiationAttempts[0] of SSR"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              default = 0
              present_if ("Number of subrate params" > 0);
        PARAM "timeoutToNextInMs[0] of SSR"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              present_if ("Number of subrate params" > 0);
        PARAM "type[0] of SSR"
              uint8
              doc "The type of sniff to negotiate. This has to be NORMAL"
              enum
              {
                {0x00, "NORMAL"}
              }
              default = 0
              present_if ("Number of subrate params" > 0);
        PARAM "asymmetricMultiplier[0] of SSR"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of subrate params" > 0);
        PARAM "minInterval[0] of SSR"
              uint16
              doc "Minimum sniff interval in BT slots"
              default = 0
              present_if ("Number of subrate params" > 0);
        PARAM "maxInterval[0] of SSR"
              uint16
              doc "Maximum sniff interval in BT slots"
              default = 0
              present_if ("Number of subrate params" > 0);
        PARAM "attempts[0] of SSR"
              uint16
              doc "Number of BT slots for sniff attempt"
              present_if ("Number of subrate params" > 0);
        PARAM "timeout[0] of SSR"
              uint16
              doc "Number of BT slots for timeout"
              default = 0
              present_if ("Number of subrate params" > 0);
        PARAM "RESERVED_21[0] of SSR"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of subrate params" > 0);
        PARAM "earlyWakeQuad[0] of SSR"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 0);
        PARAM "earlyWakeKeyscan[0] of SSR"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 0);
        PARAM "earlyWakeGpio[0] of SSR"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 0);
        PARAM "RESERVED_7[0] of SSR"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of subrate params" > 0);
        PARAM "sleepAllowed[0] of SSR"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 0);


        # Sniff params[1] - - - - - - - - - -
        PARAM "mode[1] of SSR"
              uint8
              doc "The current mode"
              enum
              {
                {0xF0, "SUSPEND"},
                {0xF1, "DISCONNECT"}
              }
              present_if ("Number of subrate params" > 1);
        PARAM "maxNegotiationAttempts[1] of SSR"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              default = 0
              present_if ("Number of subrate params" > 1);
        PARAM "timeoutToNextInMs[1] of SSR"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              default = 0
              present_if ("Number of subrate params" > 1);
        PARAM "type[1] of SSR"
              uint8
              doc "The type of sniff to negotiate"
              enum
              {
                {0x00, "NORMAL"}
              }
              default = 0
              present_if ("Number of subrate params" > 1);
        PARAM "asymmetricMultiplier[1] of SSR"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of subrate params" > 1);
        PARAM "minInterval[1] of SSR"
              uint16
              doc "Minimum sniff interval in BT slots"
              present_if ("Number of subrate params" > 1);
        PARAM "maxInterval[1] of SSR"
              uint16
              doc "Maximum sniff interval in BT slots"
              present_if ("Number of subrate params" > 1);
        PARAM "attempts[1] of SSR"
              uint16
              doc "Number of BT slots for sniff attempt"
              present_if ("Number of subrate params" > 1);
        PARAM "timeout[1] of SSR"
              uint16
              doc "Number of BT slots for timeout"
              present_if ("Number of subrate params" > 1);
        PARAM "RESERVED_21[1] of SSR"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of subrate params" > 1);
        PARAM "earlyWakeQuad[1] of SSR"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 1);
        PARAM "earlyWakeKeyscan[1] of SSR"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 1);
        PARAM "earlyWakeGpio[1] of SSR"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 1);
        PARAM "RESERVED_7[1] of SSR"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of subrate params" > 1);
        PARAM "sleepAllowed[1] of SSR"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 1);

        # Sniff params[2] - - - - - - - - - -
        PARAM "mode[2] of SSR"
              uint8
              doc "The current mode"
              enum
              {
                {0xF0, "SUSPEND"},
                {0xF1, "DISCONNECT"}
              }
              present_if ("Number of subrate params" > 2);
        PARAM "maxNegotiationAttempts[2] of SSR"
              uint8
              doc "The maximum number of times sniff should be attempted should the host reject sniff"
                  "requests from the device. 0 for infinite."
              present_if ("Number of subrate params" > 2);
        PARAM "timeoutToNextInMs[2] of SSR"
              uint32
              doc "Timeout in milliseconds to the next LPM state"
              default = 0
              present_if ("Number of subrate params" > 2);
        PARAM "type[2] of SSR"
              uint8
              doc "The type of sniff to negotiate"
              enum
              {
                {0x00, "NORMAL"}
              }
              present_if ("Number of subrate params" > 2);
        PARAM "asymmetricMultiplier[2] of SSR"
              uint8
              doc "Multiplier to apply to the base sniff interval if type is ASYMMETRIC."
              default = 1
              present_if ("Number of subrate params" > 2);
        PARAM "minInterval[2] of SSR"
              uint16
              doc "Minimum sniff interval in BT slots"
              present_if ("Number of subrate params" > 2);
        PARAM "maxInterval[2] of SSR"
              uint16
              doc "Maximum sniff interval in BT slots"
              present_if ("Number of subrate params" > 2);
        PARAM "attempts[2] of SSR"
              uint16
              doc "Number of BT slots for sniff attempt"
              present_if ("Number of subrate params" > 2);
        PARAM "timeout[2] of SSR"
              uint16
              doc "Number of BT slots for timeout"
              present_if ("Number of subrate params" > 2);
        PARAM "RESERVED_21[2] of SSR"
              uint32 {31:11}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of subrate params" > 2);
        PARAM "earlyWakeQuad[2] of SSR"
              uint32 {10}
              doc "Early wake from quadrature interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 2);
        PARAM "earlyWakeKeyscan[2] of SSR"
              uint32 {9}
              doc "Early wake from Keyscan interface. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 2);
        PARAM "earlyWakeGpio[2] of SSR"
              uint32 {8}
              doc "Early wake from LHL GPIO. Enabling early wake when type is ASYMMETRIC may improve latency."
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 2);
        PARAM "RESERVED_7[2] of SSR"
              uint32 {7:1}
              doc "Reserved for future use"
              binary_message_only
              encode_value = 0
              present_if ("Number of subrate params" > 2);
        PARAM "sleepAllowed[2] of SSR"
              uint32 {0}
              doc "If allowed to sleep in this state, set to TRUE, else set to FALSE"
              enum
              {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
              }
              present_if ("Number of subrate params" > 2);
    }


    COMMAND "BLE APP Config" 0xAF
    {
        #Device LPM Configuration
        doc "Hid application Low Power mode configuration"
        PARAM "Disconnect Low Power Mode"
                uint8
                doc "LOW power mode set to HIDOFF when disconnected"
                      "LOW power mode set to ADP when disconnected"
                       "LOW power mode set to SLEEP when disconnected"
                enum
                {
                    { 0,     "SLEEP"},
                    { 1,     "HID_OFF"}
                };
         PARAM "wakeFromHidoffInMs"
               uint32
               doc "Time to wake up from hid-off in milliseconds. 0 for never. Default is 0"
               default = 0;
         PARAM "wakeFromHidoffRefClk"
               uint8
               doc "The reference clock to use to wake from hid-off - 32 KHz Ext or 128 KHz MIA"
               enum
               {
                    {0, "TIMED_WAKE_CLK_SRC_32KHZ"},
                    {1, "TIMED_WAKE_CLK_SRC_128KHZ"}
               };

        PARAM "Hid-off allowed"
            uint8
            doc "Bit map of when hid-off is enabled";
    }


    COMMAND "Battery Monitor Config" 0xB0
    {
        doc "Parameters for Battery Monitor Configuration"
        PARAM "ADC Input"
            uint8
            doc "ADC input to be used for measurement."
                "Default value is 5"
            enum
            {
                {0x0,  "ADC_INPUT_P17"},
                {0x1,  "ADC_INPUT_P16"},
                {0x2,  "ADC_INPUT_P15"},
                {0x3,  "ADC_INPUT_P14"},
                {0x4,  "ADC_INPUT_P13"},
                {0x5,  "ADC_INPUT_P12"},
                {0x6,  "ADC_INPUT_P11"},
                {0x7,  "ADC_INPUT_P10"},
                {0x8,  "ADC_INPUT_P9"},
                {0x9,  "ADC_INPUT_P8"},
                {0xA,  "ADC_INPUT_P1"},
                {0xB,  "ADC_INPUT_P0"},
                {0xC,  "ADC_INPUT_VDDIO"},
                {0xD,  "ADC_INPUT_VDD_CORE"},
                {0xE,  "ADC_INPUT_ADC_BGREF"},
                {0xF,  "ADC_INPUT_ADC_REFGND"},
                {0x10,  "ADC_INPUT_P38"},
                {0x11,  "ADC_INPUT_P37"},
                {0x12,  "ADC_INPUT_P36"},
                {0x13,  "ADC_INPUT_P35"},
                {0x14,  "ADC_INPUT_P34"},
                {0x15,  "ADC_INPUT_P33"},
                {0x16,  "ADC_INPUT_P32"},
                {0x17,  "ADC_INPUT_P31"},
                {0x18,  "ADC_INPUT_P30"},
                {0x19,  "ADC_INPUT_P29"},
                {0x1A,  "ADC_INPUT_P28"},
                {0x1B,  "ADC_INPUT_P23"},
                {0x1C,  "ADC_INPUT_P22"},
                {0x1D,  "ADC_INPUT_P21"},
                {0x1E,  "ADC_INPUT_P19"},
                {0x1F,  "ADC_INPUT_P18"}
            };
        PARAM "Measurement Interval when connected"
            uint32
            doc "Period in millisecs between battery measurements."
	        "Default value is 3000";
        PARAM "Measurement Interval when disconnected"
            uint32
            doc "Period in millisecs between battery measurements."
	        "Default value is 360000000 (100hrs)";
        PARAM "Number Of Measurements"
            uint8
            doc "Number of measurements averaged for a report, max 16."
	        "Default value is 8";
        PARAM "Full Voltage"
            uint16
            doc "The nominal full battery voltage."
	        "Default value is 3200";
        PARAM "Empty Voltage"
            uint16
            doc "The voltage at which the batteries are considered drained in milli-volts."
	        "Default value is 1800";
        PARAM "Shutdown Voltage"
            uint16
            doc "System should shutdown if it detects battery voltage at or below this value Setting to 0 disables shutdown. In millivolts."
	        "Default value is 1700";
        PARAM "Max Level"
            uint8
            doc "Sets the range of the reported number of steps. Should not be set to 0. Set it to 100 to report battery in %, 0-100."
	        "Default value is 100";
        PARAM "Battery Monitor Report ID"
            uint8
            doc "ID of the battery report."
	        "Default value is 3";
        PARAM "Battery Monitor Report Size"
            uint8
            doc "Length of the battery report."
	        "Default value is 8";
        PARAM "Report On Connect"
            uint8
            doc "Flag indicating that a report should be sent when a connection is established."
	        "Default value is true";
        PARAM "Send Report Periodically"
            uint8
            doc "Flag indicating that a report would be sent periodcally while connected."
	        "Default value is false";
        PARAM "Battery Monitor Output"
            uint8
            doc "When FALSE, the device does not drive a GPIO when doing battery measurement"
	        "When TRUE, device does drive a GPIO when doing battery measurement"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            }
            default = 0;
        PARAM "Battery Monitor Output Connected to Port"
            uint8
            doc "Defines the port which Battery Monitor Output pin connects to"
                "Default is 0 (port 0)"
            max = 2
	    default = 0;
        PARAM "Battery Monitor Output Connected to Pin"
            uint8
            doc "Defines the pin of the above defined port connects to"
                "Default is 0 (pin 0)"
            max = 15
	    default = 9
            note "0=LSB, 15=MSB";
    }


    COMMAND "Remote App Config" 0xB1
    {
        doc "Remote application configuration."

        PARAM "Default LPM index"
            uint8
            doc "Default LPM index for mode HIGH"
            min = 0
            max = 5;

        PARAM "Motion LPM index"
            uint8
            doc "LPM index for motion"
            min = 0
            max = 5;

        PARAM "Voice LPM index"
            uint8
            doc "LPM index for voice"
            min = 0
            max = 5;

        PARAM "Motion Report ID"
            uint8
            doc "Report ID for motion data";

        PARAM "IR_ButtonScanIndex"
            uint8
            doc "Scan code of the IR button";
        PARAM "MotionStart_ButtonScanIndex"
            uint8
            doc "Scan code of the Motion START button";
        PARAM "MotionStop_ButtonScanIndex"
            uint8
            doc "Scan code of the Motion STOP button";
        PARAM "Voice_ButtonScanIndex"
            uint8
            doc "Scan code of the Voice button";

        PARAM "audio Delay in ms"
            uint16
            doc "delay sending audio, time peirod in ms";
        PARAM "audio mode"
            uint8
            doc "audio mode"
            enum
            {
                {0, "AUDIO_BUTTON_NONE"},
                {1, "AUDIO_BUTTON_SEND_MSG"},
                {2, "AUDIO_BUTTON_SEND_PCM"}
            };
        PARAM "audio gain"
            uint8
            doc "audio gain";
        PARAM "audio boost"
            uint8
            doc "audio boost"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            };

        PARAM "Max Bytes In Report"
            uint8
            doc "Maximum number of data bytes in remote report."
            min = 1
            max = 11;

        PARAM "Num Of Reports"
            uint8
            doc "Number of of remote reports that can be transmitted within a poll."
            min = 1
            max = 8;

        PARAM "Maximum Samples read in One Slot Callback"
            uint8
            doc "Maximum sample number read in one slot callback"
            min = 1
            max = 40;

        PARAM "RptID[0]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "TranslationCodeSize[0]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "RptID[1]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "TranslationCodeSize[1]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "RptID[2]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "TranslationCodeSize[2]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "RptID[3]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "TranslationCodeSize[3]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "RptID[4]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "TranslationCodeSize[4]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "RptID[5]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "TranslationCodeSize[5]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "RptID[6]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "TranslationCodeSize[6]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "RptID[7]"
            uint8
            doc "See description of 'Key Translation Codes'";
        PARAM "TranslationCodeSize[7]"
            uint8
            doc "See description of 'Key Translation Codes'";

        # Remote Key Translation Table
        # This is the key translation table for the remote application. This is used to extend the keyboard key translation table
        # since remote application uses two-byte key codes.

        PARAM "Number of columns"
            uint8
            doc "Defines the number of columns in the key translation table. Should be identical to the number of"
                "columns configured in the keyscan driver if the keyscan driver is in use"
            not_in_binary_message
            decode_value = 0
            min = 1
            max = 8;
        PARAM "Number of rows"
            uint8
            doc "Defines the number of rows in the key translation table. Should be identical to the number of"
                "rows configured in the keyscan driver if the keyscan driver is in use"
            not_in_binary_message
            decode_value = 0
            min = 1
            max = 7;

        PARAM "Key[Row0][Col0].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 0) and ("Number of columns" > 0));
        PARAM "Key[Row1][Col0].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 1) and ("Number of columns" > 0));
        PARAM "Key[Row2][Col0].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 2) and ("Number of columns" > 0));
        PARAM "Key[Row3][Col0].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 3) and ("Number of columns" > 0));
        PARAM "Key[Row4][Col0].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 4) and ("Number of columns" > 0));
        PARAM "Key[Row5][Col0].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 5) and ("Number of columns" > 0));
        PARAM "Key[Row6][Col0].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 6) and ("Number of columns" > 0));
        PARAM "Key[Row0][Col1].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 0) and ("Number of columns" > 1));
        PARAM "Key[Row1][Col1].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 1) and ("Number of columns" > 1));
        PARAM "Key[Row2][Col1].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 2) and ("Number of columns" > 1));
        PARAM "Key[Row3][Col1].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 3) and ("Number of columns" > 1));
        PARAM "Key[Row4][Col1].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 4) and ("Number of columns" > 1));
        PARAM "Key[Row5][Col1].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 5) and ("Number of columns" > 1));
        PARAM "Key[Row6][Col1].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 6) and ("Number of columns" > 1));
        PARAM "Key[Row0][Col2].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 0) and ("Number of columns" > 2));
        PARAM "Key[Row1][Col2].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 1) and ("Number of columns" > 2));
        PARAM "Key[Row2][Col2].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 2) and ("Number of columns" > 2));
        PARAM "Key[Row3][Col2].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 3) and ("Number of columns" > 2));
        PARAM "Key[Row4][Col2].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 4) and ("Number of columns" > 2));
        PARAM "Key[Row5][Col2].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 5) and ("Number of columns" > 2));
        PARAM "Key[Row6][Col2].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 6) and ("Number of columns" > 2));
        PARAM "Key[Row0][Col3].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 0) and ("Number of columns" > 3));
        PARAM "Key[Row1][Col3].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 1) and ("Number of columns" > 3));
        PARAM "Key[Row2][Col3].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 2) and ("Number of columns" > 3));
        PARAM "Key[Row3][Col3].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 3) and ("Number of columns" > 3));
        PARAM "Key[Row4][Col3].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 4) and ("Number of columns" > 3));
        PARAM "Key[Row5][Col3].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 5) and ("Number of columns" > 3));
        PARAM "Key[Row6][Col3].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 6) and ("Number of columns" > 3));
        PARAM "Key[Row0][Col4].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 0) and ("Number of columns" > 4));
        PARAM "Key[Row1][Col4].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 1) and ("Number of columns" > 4));
        PARAM "Key[Row2][Col4].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 2) and ("Number of columns" > 4));
        PARAM "Key[Row3][Col4].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 3) and ("Number of columns" > 4));
        PARAM "Key[Row4][Col4].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 4) and ("Number of columns" > 4));
        PARAM "Key[Row5][Col4].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 5) and ("Number of columns" > 4));
        PARAM "Key[Row6][Col4].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 6) and ("Number of columns" > 4));
        PARAM "Key[Row0][Col5].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 0) and ("Number of columns" > 5));
        PARAM "Key[Row1][Col5].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 1) and ("Number of columns" > 5));
        PARAM "Key[Row2][Col5].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 2) and ("Number of columns" > 5));
        PARAM "Key[Row3][Col5].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 3) and ("Number of columns" > 5));
        PARAM "Key[Row4][Col5].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 4) and ("Number of columns" > 5));
        PARAM "Key[Row5][Col5].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 5) and ("Number of columns" > 5));
        PARAM "Key[Row6][Col5].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 6) and ("Number of columns" > 5));
        PARAM "Key[Row0][Col6].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 0) and ("Number of columns" > 6));
        PARAM "Key[Row1][Col6].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 1) and ("Number of columns" > 6));
        PARAM "Key[Row2][Col6].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 2) and ("Number of columns" > 6));
        PARAM "Key[Row3][Col6].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 3) and ("Number of columns" > 6));
        PARAM "Key[Row4][Col6].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 4) and ("Number of columns" > 6));
        PARAM "Key[Row5][Col6].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 5) and ("Number of columns" > 6));
        PARAM "Key[Row6][Col6].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 6) and ("Number of columns" > 6));
        PARAM "Key[Row0][Col7].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 0) and ("Number of columns" > 7));
        PARAM "Key[Row1][Col7].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 1) and ("Number of columns" > 7));
        PARAM "Key[Row2][Col7].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 2) and ("Number of columns" > 7));
        PARAM "Key[Row3][Col7].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 3) and ("Number of columns" > 7));
        PARAM "Key[Row4][Col7].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 4) and ("Number of columns" > 7));
        PARAM "Key[Row5][Col7].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 5) and ("Number of columns" > 7));
        PARAM "Key[Row6][Col7].TranslationCode"
            uint16
            doc "See description of 'Key Translation Codes'"
            present_if (("Number of rows" > 6) and ("Number of columns" > 7));
    }


    COMMAND "BT Proximity Association Config" 0xB2
    {
        doc "Configuration item for proximity association."
        PARAM "mode"
            uint8
            doc "The Inqiry mode to use"
            enum
            {
                {0x01, "RSSI_ONLY"},
                {0x02, "RSSI_AND_EIR"}
            };

        PARAM "filterType"
            uint8 {7:4}
            doc "The type of filter we want to apply to the incoming inquiry responses."
            "Could be either no filtering, class-of-device based, class-of-device + EIR"
            enum
            {
                {0x00, "NONE"},
                {0x01, "COD_LIST"},
                {0x02, "COD_LIST_WITH_EIR"}
            };

        PARAM "codCount"
            uint8 {3:0}
            doc "The number of class-of-devices to compare with."
            present_if ("filterType" > 0)
            max = 3;

        PARAM "devClasses"
            uint8[9]
            doc "The device classes that need to be compared with."
            valid_length = ByteArrayValidLength("devClasses")
            present_if ("codCount" > 0);

        PARAM "eirManufId"
            uint16
            doc "The manufacturer ID of the EIR data to look for when filtering "
                "based on EIR"
            present_if ("filterType" > 0x01);

        PARAM "eirFlags"
            uint8
            doc "The bit pattern of the required EIR flags"
            bitmap
            {
                {0x01, "3D_CAPABLE_HOST"},
                {0x02, "MULTICAST_CAPABLE_HOST"},
                {0x08, "REMOTE_ASSOCIATED"}
            }
            present_if ("filterType" > 0x01);

        PARAM "eirFlagsMask"
            uint8
            doc "The bit pattern of eirFlags that absolutely have to match the ones in EIR"
            bitmap
            {
                {0x01, "3D_CAPABLE_HOST_MASK"},
                {0x02, "MULTICAST_CAPABLE_HOST_MASK"},
                {0x08, "REMOTE_ASSOCIATED_MASK"}
            }
            present_if ("filterType" > 0x01);

        PARAM "type"
            uint8
            doc "GENERAL or LIMITED mode inquiry to use"
            enum
            {
                {0x00, "GENERAL"},
                {0x01, "LIMITED"}
            };

        PARAM "maxNumHosts"
            uint8
            doc "Maximum number of hosts to accumulate in the window. Max is 10"
            max = 10;

        PARAM "updateRssiToNewestOnMultipleResponse"
            uint8
            doc "Whether to update the RSSI o the newest value or not when a new response"
                "from the same host is received"
            enum
            {
                {0x00, "FALSE"},
                {0x01, "TRUE"}
            };

        PARAM "defaultTxInqTxPowerLevel"
            int8
            doc "The default TX inquiry power level in dBm"
            default = 0;

        PARAM "extendedInquiryEnable"
            uint8
            doc "When FALSE, the device does a normal inquiry"
	        "When TRUE, device does a extended inquiry"
            enum
            {
                {0, "FALSE"},
                {1, "TRUE"}
            }
            default = 0;

        PARAM "extendedInquiryDuration"
           uint8
           doc "It define the  max inquiry time which is n*1.28 seconds "

           default = 0x08;
    }

    COMMAND "HidApp SDP Database" 0xBE
    {
        doc "Application specific SDP database"
        PARAM "Data"
            uint8[1024] omit_pad_bytes
            doc "The complete SDP database for the application if the default DB needs to be overridden"
            valid_length = ByteArrayValidLength("Data")
            min = 1;
    }


    COMMAND "Init BB Register Bit Fields With FAB ID" 0xD0
    {
        doc "This item is used to overwrite the selected bit fields of the "
            "BB register default values during firmware initialization if the fab ID is default"
	    "or match the device fab ID."
        PARAM "FAB ID"
            uint8
	    doc "Fab ID.";
        PARAM "Num entries"
            uint8
            doc "An abstract parameter used only for encoding purposes, not present in the"
                "actual configuration item. When encoding the configuration item, determines"
                "the number of address/mask/value entries to include."
            not_in_binary_message
            decode_value = 0                                    # Can only decode, not encode
            max = 10;
        PARAM "Register address[0]"
            uint32
            doc "Address of the baseband register"
            present_if ("Num entries" > 0);
        PARAM "Bit field mask[0]"
            uint32
            doc "Bit field mask. If a bit is 1 that bit value will be changed to the new value"
                "specified"
            present_if ("Num entries" > 0);
        PARAM "Value[0]"
            uint32
            doc "Data to be written to the baseband register"
            present_if ("Num entries" > 0);
        PARAM "Register address[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Bit field mask[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Value[1]"
            uint32
            present_if ("Num entries" > 1);
        PARAM "Register address[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Bit field mask[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Value[2]"
            uint32
            present_if ("Num entries" > 2);
        PARAM "Register address[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Bit field mask[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Value[3]"
            uint32
            present_if ("Num entries" > 3);
        PARAM "Register address[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Bit field mask[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Value[4]"
            uint32
            present_if ("Num entries" > 4);
        PARAM "Register address[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Bit field mask[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Value[5]"
            uint32
            present_if ("Num entries" > 5);
        PARAM "Register address[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Bit field mask[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Value[6]"
            uint32
            present_if ("Num entries" > 6);
        PARAM "Register address[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Bit field mask[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Value[7]"
            uint32
            present_if ("Num entries" > 7);
        PARAM "Register address[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Bit field mask[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Value[8]"
            uint32
            present_if ("Num entries" > 8);
        PARAM "Register address[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Bit field mask[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Value[9]"
            uint32
            present_if ("Num entries" > 9);
        PARAM "Register address[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Bit field mask[10]"
            uint32
            present_if ("Num entries" > 10);
        PARAM "Value[10]"
            uint32
            present_if ("Num entries" > 10);
    }


    COMMAND "Init RF Registers With FAB ID" 0xD1
    {
        doc "($$$ NEEDS EXPLANATION)"
        PARAM "FAB ID"
            uint8
	    doc "Fab ID.";
        PARAM "Num entries"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            not_in_binary_message
            decode_value = 0                    # Can only decode, not encode
            max = 10;
        PARAM "Register offset[0]"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            present_if ("Num entries" > 0);
        PARAM "Value[0]"
            uint8
            doc "($$$ NEEDS EXPLANATION)"
            present_if ("Num entries" > 0);
        PARAM "Register offset[1]"
            uint8
            present_if ("Num entries" > 1);
        PARAM "Value[1]"
            uint8
            present_if ("Num entries" > 1);
        PARAM "Register offset[2]"
            uint8
            present_if ("Num entries" > 2);
        PARAM "Value[2]"
            uint8
            present_if ("Num entries" > 2);
        PARAM "Register offset[3]"
            uint8
            present_if ("Num entries" > 3);
        PARAM "Value[3]"
            uint8
            present_if ("Num entries" > 3);
        PARAM "Register offset[4]"
            uint8
            present_if ("Num entries" > 4);
        PARAM "Value[4]"
            uint8
            present_if ("Num entries" > 4);
        PARAM "Register offset[5]"
            uint8
            present_if ("Num entries" > 5);
        PARAM "Value[5]"
            uint8
            present_if ("Num entries" > 5);
        PARAM "Register offset[6]"
            uint8
            present_if ("Num entries" > 6);
        PARAM "Value[6]"
            uint8
            present_if ("Num entries" > 6);
        PARAM "Register offset[7]"
            uint8
            present_if ("Num entries" > 7);
        PARAM "Value[7]"
            uint8
            present_if ("Num entries" > 7);
        PARAM "Register offset[8]"
            uint8
            present_if ("Num entries" > 8);
        PARAM "Value[8]"
            uint8
            present_if ("Num entries" > 8);
        PARAM "Register offset[9]"
            uint8
            present_if ("Num entries" > 9);
        PARAM "Value[9]"
            uint8
            present_if ("Num entries" > 9);
        PARAM "Register offset[10]"
            uint8
            present_if ("Num entries" > 10);
        PARAM "Value[10]"
            uint8
            present_if ("Num entries" > 10);
    }

    COMMAND "Init Masked RF Registers" 0xCF
    {
        doc "Performs a late initialization of RF registers, written through a"
            "mask to preserve those bits already in the register which are not"
            "covered by the mask."
        PARAM "Num entries"
            uint8
            doc "The number of registers to be written"
            not_in_binary_message
            decode_value = 0                    # Can only decode, not encode
            max = 10;
        PARAM "Register offset[0]"
            uint8
            doc "The BlueRF register to be written to"
            present_if ("Num entries" > 0);
        PARAM "Mask[0]"
            uint8
            doc "The mask through which the value is to be written.  Mask bits"
                "with a value of zero will have the existing register contents"
                "preserved."
            present_if ("Num entries" > 0);
        PARAM "Value[0]"
            uint8
            doc "The value to be written through the mask"
            present_if ("Num entries" > 0);
        PARAM "Register offset[1]"
            uint8
            present_if ("Num entries" > 1);
        PARAM "Mask[1]"
            uint8
            present_if ("Num entries" > 1);
        PARAM "Value[1]"
            uint8
            present_if ("Num entries" > 1);
        PARAM "Register offset[2]"
            uint8
            present_if ("Num entries" > 2);
        PARAM "Mask[2]"
            uint8
            present_if ("Num entries" > 2);
        PARAM "Value[2]"
            uint8
            present_if ("Num entries" > 2);
        PARAM "Register offset[3]"
            uint8
            present_if ("Num entries" > 3);
        PARAM "Mask[3]"
            uint8
            present_if ("Num entries" > 3);
        PARAM "Value[3]"
            uint8
            present_if ("Num entries" > 3);
        PARAM "Register offset[4]"
            uint8
            present_if ("Num entries" > 4);
        PARAM "Mask[4]"
            uint8
            present_if ("Num entries" > 4);
        PARAM "Value[4]"
            uint8
            present_if ("Num entries" > 4);
        PARAM "Register offset[5]"
            uint8
            present_if ("Num entries" > 5);
        PARAM "Mask[5]"
            uint8
            present_if ("Num entries" > 5);
        PARAM "Value[5]"
            uint8
            present_if ("Num entries" > 5);
        PARAM "Register offset[6]"
            uint8
            present_if ("Num entries" > 6);
        PARAM "Mask[6]"
            uint8
            present_if ("Num entries" > 6);
        PARAM "Value[6]"
            uint8
            present_if ("Num entries" > 6);
        PARAM "Register offset[7]"
            uint8
            present_if ("Num entries" > 7);
        PARAM "Mask[7]"
            uint8
            present_if ("Num entries" > 7);
        PARAM "Value[7]"
            uint8
            present_if ("Num entries" > 7);
        PARAM "Register offset[8]"
            uint8
            present_if ("Num entries" > 8);
        PARAM "Mask[8]"
            uint8
            present_if ("Num entries" > 8);
        PARAM "Value[8]"
            uint8
            present_if ("Num entries" > 8);
        PARAM "Register offset[9]"
            uint8
            present_if ("Num entries" > 9);
        PARAM "Mask[9]"
            uint8
            present_if ("Num entries" > 9);
        PARAM "Value[9]"
            uint8
            present_if ("Num entries" > 9);
    }

    COMMAND "Hardware Power LUT Config" 0xD8
    {
        doc "Config item to overwrite the hardware"
            "Power control LUT"
        PARAM "FAB ID"
            uint8
	    doc "Fab ID.";
        PARAM "NSteps"
            uint8
            doc "Number of entries in the LUT."
                "Hardware supports a maximum of 12"
            max=12;
        PARAM "Byte0[0]"
            uint8
            doc "Byte 0 of the first entry";
        PARAM "Byte1[0]"
            uint8
            doc "Byte 1 of the first entry"
            default = 0x0f;
        PARAM "Byte2[0]"
            uint8
            doc "Byte 2 of the first entry"
            default = 0;
        PARAM "Byte3[0]"
            uint8
            doc "Byte 3 of the first entry"
            default = 0;
        PARAM "Byte0[1]"
            uint8
            present_if ("NSteps" > 1);
        PARAM "Byte1[1]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 1);
        PARAM "Byte2[1]"
            uint8
            default = 0
            present_if ("NSteps" > 1);
        PARAM "Byte3[1]"
            uint8
            default = 0
            present_if ("NSteps" > 1);
        PARAM "Byte0[2]"
            uint8
            present_if ("NSteps" > 2);
        PARAM "Byte1[2]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 2);
        PARAM "Byte2[2]"
            uint8
            default = 0
            present_if ("NSteps" > 2);
        PARAM "Byte3[2]"
            uint8
            default = 0
            present_if ("NSteps" > 2);
        PARAM "Byte0[3]"
            uint8
            present_if ("NSteps" > 3);
        PARAM "Byte1[3]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 3);
        PARAM "Byte2[3]"
            uint8
            default = 0
            present_if ("NSteps" > 3);
        PARAM "Byte3[3]"
            uint8
            default = 0
            present_if ("NSteps" > 3);
        PARAM "Byte0[4]"
            uint8
            present_if ("NSteps" > 4);
        PARAM "Byte1[4]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 4);
        PARAM "Byte2[4]"
            uint8
            default = 0
            present_if ("NSteps" > 4);
        PARAM "Byte3[4]"
            uint8
            default = 0
            present_if ("NSteps" > 4);
        PARAM "Byte0[5]"
            uint8
            present_if ("NSteps" > 5);
        PARAM "Byte1[5]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 5);
        PARAM "Byte2[5]"
            uint8
            default = 0
            present_if ("NSteps" > 5);
        PARAM "Byte3[5]"
            uint8
            default = 0
            present_if ("NSteps" > 5);
        PARAM "Byte0[6]"
            uint8
            present_if ("NSteps" > 6);
        PARAM "Byte1[6]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 6);
        PARAM "Byte2[6]"
            uint8
            default = 0
            present_if ("NSteps" > 6);
        PARAM "Byte3[6]"
            uint8
            default = 0
            present_if ("NSteps" > 6);
        PARAM "Byte0[7]"
            uint8
            present_if ("NSteps" > 7);
        PARAM "Byte1[7]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 7);
        PARAM "Byte2[7]"
            uint8
            default = 0
            present_if ("NSteps" > 7);
        PARAM "Byte3[7]"
            uint8
            default = 0
            present_if ("NSteps" > 7);
        PARAM "Byte0[8]"
            uint8
            present_if ("NSteps" > 8);
        PARAM "Byte1[8]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 8);
        PARAM "Byte2[8]"
            uint8
            default = 0
            present_if ("NSteps" > 8);
        PARAM "Byte3[8]"
            uint8
            default = 0
            present_if ("NSteps" > 8);
        PARAM "Byte0[9]"
            uint8
            present_if ("NSteps" > 9);
        PARAM "Byte1[9]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 9);
        PARAM "Byte2[9]"
            uint8
            default = 0
            present_if ("NSteps" > 9);
        PARAM "Byte3[9]"
            uint8
            default = 0
            present_if ("NSteps" > 9);
        PARAM "Byte0[10]"
            uint8
            present_if ("NSteps" > 10);
        PARAM "Byte1[10]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 10);
        PARAM "Byte2[10]"
            uint8
            default = 0
            present_if ("NSteps" > 10);
        PARAM "Byte3[10]"
            uint8
            default = 0
            present_if ("NSteps" > 10);
        PARAM "Byte0[11]"
            uint8
            present_if ("NSteps" > 11);
        PARAM "Byte1[11]"
            uint8
            default = 0x0f
            present_if ("NSteps" > 11);
        PARAM "Byte2[11]"
            uint8
            default = 0
            present_if ("NSteps" > 11);
        PARAM "Byte3[11]"
            uint8
            default = 0
            present_if ("NSteps" > 11);

    }

    COMMAND "RCAL RCCAL" 0xBC
    {
        doc "Configures the baud rate, mode, and thresholds for the UART transport"
        PARAM "RCal Scale"
            int16
            doc "Configures RCal Scale";
        PARAM "RCal offset"
            int16
            doc "Configures Rcal offset";
        PARAM "RCCal Scale"
            int16
            doc "Configures RC Cal Scale";
        PARAM "RCCal Offset"
            int16
            doc "Configures RC Cal Offset";
        PARAM "BTTX RCAL Scale"
            int16
            doc "Configures BTTX RCal Scale";
        PARAM "BTTX RCAL Offset"
            int16
            doc "Configures BTTX RCal Offset";
        PARAM "BTADC RcCAL Scale"
            int16
            doc "Configures BTADC RCCal Scale";
        PARAM "BTADC RcCAL Offset"
            int16
            doc "Configures BTADC RCCal Offset";
        PARAM "BTTX RcCAL Scale"
            int16
            doc "Configures BTTX RCCal Scale";
        PARAM "BTTX RcCAL Offset"
            int16
            doc "Configures BTTX RCCal Offset";
    }


    COMMAND "Sensor Data Config" 0xDA
    {
         doc "Application based Sensor data"

        PARAM "Sensor Count"
        uint16
        doc "number of Sensors to be configured"
        min = 1
        max = 10;


        PARAM "sensor data length[0]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 0);

        PARAM "sensor data length[1]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 1);

        PARAM "sensor data length[2]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 2);

        PARAM "sensor data length[3]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 3);

        PARAM "sensor data length[4]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 4);

        PARAM "sensor data length[5]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 5);

        PARAM "sensor data length[6]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 6);

        PARAM "sensor data length[7]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 7);

        PARAM "sensor data length[8]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 8);

        PARAM "sensor data length[9]"
        uint16
        doc "Length of the Sensor Data"
        present_if ("Sensor Count" > 9);

        PARAM "Data"
        uint8[65536] omit_pad_bytes
        doc "External Sensor Data. This holds the combined data of all sensors";
    }


    COMMAND "Spiffy1 Clock Speed" 0xDC
    {
        doc "Configuration of Spiffy1 clock speed"
        PARAM "Speed"
            uint32
            doc "Spiffy1 Clock Speed";
    }


    COMMAND "Dual Boot SerialFlash Pad" 0xDB
    {
        doc "Pad for dual boot image, in order to push real image into the 4K boundary"
        PARAM "Data"
            uint8[4096] omit_pad_bytes
            doc "Padded data attached via external utility";
    }

    # COMMAND "RF_PLL Trim Reserved" 0xFD                               - Fixed header only

    COMMAND "Overlay data" 0xF1
    {
        doc "Overlay entry"
        PARAM "Overlay ID"
            uint32{31:24}
            doc "Index of the overlaid section.";
        PARAM "Address"
            uint32{23:0}
            doc "The address to which the Data bytes are to be loaded.";
        PARAM "Data"
            uint8[0xFF00] omit_pad_bytes
            doc "The data bytes to be loaded to the Address specified.";
    }
}
